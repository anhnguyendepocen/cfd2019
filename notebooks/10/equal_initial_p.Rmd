---
jupyter:
  jupytext:
    notebook_metadata_filter: all,-language_info
    split_at_heading: true
    text_representation:
      extension: .Rmd
      format_name: rmarkdown
      format_version: '1.1'
      jupytext_version: 1.2.4
  kernelspec:
    display_name: Python 3
    language: python
    name: python3
---

This page follows on from the [Bayes bars](bayes_bars) page.

In the first part of that page, we found that, in general, we can get the
reverse probabilities of the boxes (BOX4, BOX2), given we have seen a red
ball, by following three steps:

1. Get the probability of red given each box --- e.g: (0.8, 0.4);
2. Scale these by the probability of each box --- e.g.: (0.3, 0.7);
3. Divide the results by the sum of the results from step 2 to get the reverse
   probabilities --- e.g. (0.462, 0.538).

We found, in that page, that if the initial probabilities of the boxes were
the same --- (0.5, 0.5), we could miss out the second step --- scaling by the
box probabilities.

Let's see why in a little algebra mixed with code.

```{python}
import numpy as np
```

As you remember, the calculation works out like this:

```{python}
# Step 1 - P of reds.
red_probabilities = np.array([0.8, 0.4])
# Step 2 - scale by P of the boxes
box_probabilities = np.array([0.3, 0.7])
box_and_red_probs = box_probabilities * red_probabilities
# Step 3 - divide each bar by sum of bar heights.
box_given_red_probs = box_and_red_probs / np.sum(box_and_red_probs)
# Show result
box_given_red_probs
```

Now let's put those numbers into some variables, and do the calculation again.
We use the variables to refer back to the values in following the calculation.
Of course, just putting the numbers into variables gives the same calculation
and the same output:

```{python}
b = 0.3  # Probability of BOX4
c = 0.7  # Probability of BOX2
r = 0.8  # Probability of red if you have BOX4
s = 0.4  # Probability of red if you have BOX2
```

```{python}
# Step 1 - P of reds.
red_probabilities = np.array([r, s])
# Step 2 - scale by P of the boxes
box_probabilities = np.array([b, c])
box_and_red_probs = box_probabilities * red_probabilities
# Step 3 - divide each bar by sum of bar heights.
box_given_red_probs = box_and_red_probs / np.sum(box_and_red_probs)
# Show result
box_given_red_probs
```

Working through the calculation above, and knowing how multiplication of arrays
works, we see that:

```{python}
box_and_red_probs == np.array([r * b, s * c])
```

We also see that:

```{python}
np.sum(box_and_red_probs) == (r * b) + (s * c)
```

Therefore, the full calculation boils down to:

```{python}
box_given_red_probs == np.array([r * b, s * c]) / ((r * b) + (s * c))
```

Now --- what happens if the box probabilities are the same, and so `b == c`?

```{python}
b = 0.5  # Probability of BOX4
c = 0.5  # Probability of BOX2
```

```{python}
# Step 2 - scale by P of the boxes
eq_box_probabilities = np.array([b, c])
eq_box_and_red_probs = eq_box_probabilities * red_probabilities
# Step 3 - divide each bar by sum of bar heights.
eq_box_given_red_probs = eq_box_and_red_probs / np.sum(eq_box_and_red_probs)
 # Show result
eq_box_given_red_probs
```

In that case we can replace all the `c` instances by `b` in the calculation
above, and so we get:

```{python}
eq_box_given_red_probs == np.array([r * b, s * b]) / ((r * b) + (s * b))
```

Then we can take the `b` values outside the brackets to get:

```{python}
eq_box_given_red_probs == np.array([r, s]) * b / ((r + s) * b)
```

The `b`s on top and bottom cancel, and so:

```{python}
eq_box_given_red_probs == np.array([r, s]) / (r + s)
```

We can omit the box probabilities from the calculation, when the box
probabilities are equal.

You might be able to see that that this will also apply if we have three or
more boxes, all with equal probabilities.  That is the situation we find in the
[confidence in bars]({{ site.baseurl }}/chapters/10/second_bayes) page.
