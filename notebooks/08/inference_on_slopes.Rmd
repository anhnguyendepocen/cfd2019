---
jupyter:
  jupytext:
    metadata_filter:
      notebook:
        additional: all
        excluded:
        - language_info
    text_representation:
      extension: .Rmd
      format_name: rmarkdown
      format_version: '1.0'
      jupytext_version: 0.8.6
  kernelspec:
    display_name: Python 3
    language: python
    name: python3
---

In [finding slopes](finding_slopes), we found the line the did the best job of predicting one vector of values from another vector of values.

Our line was a slope and an intercept.  We used it to predict the Maternal Mortality Ratio (MMR) values from the Fertility Rate (FR) values.

We chose the line to minimize the average prediction errors, and the sum of squared prediction errors.

Now we may have another question.  Can we believe the slope?   Put more formally, is it possible that there is in fact no underlying positive or negative slope relating FR and MMR, and the slope that we found arose because of *sampling error*.  That is, there was some random fluctuation in the data, perhaps from year to year, and just by chance, the random fluctuation resulted in the slope we observe.

This is a very similar problem to the problem of comparing means between two groups.  Like that problem, we can get at our question using a permutation test.

```{python}
import numpy as np
import matplotlib.pyplot as plt
# %matplotlib inline
# Make plots look a little bit more fancy
plt.style.use('fivethirtyeight')
# Print to 2 decimal places, show tiny values as 0
np.set_printoptions(precision=2, suppress=True)
import pandas as pd
```

If you are running on your laptop, you will need to download the
[gender_stats.csv]({{ site.baseurl }}/data/gender_stats.csv) file to the same
directory as this notebook.

We fetch the data and process it again:

```{python}
# Load the data file
gender_data = pd.read_csv('gender_stats.csv')

# Make new data frame with only MMR and FR
just_mmr_fr = gender_data[['mat_mort_ratio', 'fert_rate']]

# Drop the NaN values, and make into arrays.
clean_mmr_fr = just_mmr_fr.dropna()
mmr = np.array(clean_mmr_fr['mat_mort_ratio'])
fert = np.array(clean_mmr_fr['fert_rate'])
```
