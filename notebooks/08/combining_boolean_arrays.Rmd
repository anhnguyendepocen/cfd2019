---
jupyter:
  jupytext:
    text_representation:
      extension: .Rmd
      format_name: rmarkdown
      format_version: '1.1'
      jupytext_version: 1.2.4
  kernelspec:
    display_name: Python 3
    language: python
    name: python3
---

Sometimes we want to be able to combine several different criteria to select
elements from arrays or tables.

So far we have used *boolean* Series and arrays to select rows.  This works fine when we have some simple criterion, such as whether the value in the column or array is greater than 10.

For example, consider the [students ratings dataset]({{ site.baseurl
}}/data/rate_my_professors) dataset. Download the data file via
[disciplines_SI.xlsx]({{ site.baseurl }}/data/disciplines_SI.xlsx).

```{python}
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
# %matplotlib inline
# Make plots look a little bit more fancy
plt.style.use('fivethirtyeight')
```

```{python}
# Read the Excel format data file
ratings = pd.read_excel('disciplines_SI.xlsx')
ratings.head()
```

We can select the rows from this table where the Easiness rating was above the median, using a *boolean series*:

```{python}
easiness = ratings['Easiness']
gt_median_easy = easiness > np.median(easiness)
gt_median_easy.head()
```

```{python}
above_median = ratings[gt_median_easy]
above_media.head()
```

What if we wanted to select the rows that were between the 25th and 75th centile?  Here's how to get the centile values:

```{python}
q25 = np.quartile(easiness, 0.25)
q75 = np.quartile(easiness, 0.75)
print(q25, q75)
```

We can do this more neatly with [unpacking](using_minimize):

```{python}
q25, q75 = np.quartile(easiness, [0.25, 0.75])
print(q25, q75)
```

Now we want to select the rows where the Easiness score is between these values.   We can do this the long way round, by selecting twice:

```{python}
# Select values above the 25% quartile.
above_q25 = ratings[easiness > q25]
# There are now fewer Easiness values, so we have to get the values remaining.
q25_easiness = above_q25['Easiness']
# Select values below the 75% quartile.
between_25_75 = above_q25[q25_easiness < q75]
between_25_75.head()
```

For example, we might want to find all the
movies with ratings from 7 through 8.  Now we need a Boolean Series that has
True only both of these things are true for the given Rating value:

* the Rating value is greater than or equal to 7, AND
* the Rating value is less than or equal to 8.

We can make a Boolean array for each of these two criteria:

```{python}
ratings = imdb["Rating"]
is_ge_7 = ratings >= 7
# Show the first 10 values
is_ge_7.head(10)
```

```{python}
is_le_8 = ratings <= 8
# Show the first 10 values
is_le_8.head(10)
```

We can combine these two with Numpy functions.  The function we need in this
case is `np.logical_and`.  It combines the Series into a new sequence that only
has True in positions where both of these Series have a True in the corresponding position:

```{python}
between_7_8 = np.logical_and(is_ge_7, is_le_8)
between_7_8.head(10)
```

```{python}

```
