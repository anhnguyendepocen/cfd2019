---
jupyter:
  jupytext:
    metadata_filter:
      notebook:
        additional: all
        excluded:
        - language_info
    text_representation:
      extension: .Rmd
      format_name: rmarkdown
      format_version: '1.0'
      jupytext_version: 0.8.6
  kernelspec:
    display_name: Python 3
    language: python
    name: python3
---

In [The Mean and Slopes](mean_and_slopes), we were looking for the best slope
to predict one vector of values from another vector of values.

Specifically, we wanted our slope to predict the Maternal Mortality Ratio (MMR) values from the Fertility Rate (FR) values.

By analogy with [The Mean as Predictor](mean_meaning), we decided to choose our line to minimize the average prediction errors, and the sum of squared prediction errors.

We found a solution.  Now we might ask the question, what if we wanted a line that had a (not zero) intercept, as well as a slope?

First we recover the slope we found.

```{python}
import numpy as np
import matplotlib.pyplot as plt
# %matplotlib inline
# Make plots look a little bit more fancy
plt.style.use('fivethirtyeight')
# Print to 2 decimal places, show tiny values as 0
np.set_printoptions(precision=2, suppress=True)
import pandas as pd
```

If you are running on your laptop, you will need to download the
[gender_stats.csv]({{ site.baseurl }}/data/gender_stats.csv) file to the same
directory as this notebook.

We fetch the data and process it again:

```{python}
# Load the data file
gender_data = pd.read_csv('gender_stats.csv')

# Make new data frame with only MMR and FR
just_mmr_fr = gender_data[['mat_mort_ratio', 'fert_rate']]

# Drop the NaN values, and make into arrays.
clean_mmr_fr = just_mmr_fr.dropna()
mmr = np.array(clean_mmr_fr['mat_mort_ratio'])
fert = np.array(clean_mmr_fr['fert_rate'])
```

We decided on sum of squared error as a criterion:

```{python}
def sos_error(slope):
    fitted = fert * slope  # 'fert' comes from the top level
    error = mmr - fitted     # 'mmr' comes from the top level
    return np.sum(error ** 2)
```

We tried many slopes, and found the one minimizing the `sos_error` value
above:

```{python}
# Slopes to try
some_slopes = np.arange(50, 110, 0.1)
n_slopes = len(some_slopes)
# Try all these slopes, calculate and record sum of squared error
sos_errors = np.zeros(n_slopes)
for i in np.arange(n_slopes):
    slope = some_slopes[i]
    sos_errors[i] = sos_error(slope)
# The slope minimizing the sum of squared error
best_slope = some_slopes[np.argmin(sos_errors)]
best_slope
```

This all comes from the [The Mean and Slopes](mean_and_slopes) notebook.

We also found, mysteriously, that there was a function called `minimize` in
Scipy that would do the search for us:

```{python}
from scipy.optimize import minimize
minimize(sos_error, 100)
```

We now how to search for the best slope.  What if we also have a not-zero intercept.  How do we search for a slope as well as an intercept?

```{python}
def sos_si_error(inter_slope):
    intercept = inter_slope[0]
    slope = inter_slope[1]
    fitted = intercept + fert * slope
    error = mmr - fitted
    return np.sum(error ** 2)
```

```{python}
sos_si_error([0, best_slope])
```

```{python}
sos_si_error([-100, 100])
```

```{python}
some_intercepts = np.arange(-300, 50)
n_intercepts = len(some_intercepts)
some_slopes = np.arange(0, 200)
n_slopes = len(some_slopes)
```

```{python}
errors = np.zeros((n_intercepts, n_slopes))
for inter_i in np.arange(n_intercepts):
    inter = some_intercepts[inter_i]
    for slope_i in np.arange(n_slopes):
        s = some_slopes[slope_i]
        errors[inter_i, slope_i] = sos_si_error([inter, s])
```

```{python}
plt.imshow(np.sqrt(errors))
plt.colorbar()
```

```{python}
min_error = np.min(errors)
min_error
```

```{python}
rows, cols = np.where(errors == min_error)
rows, cols
```

```{python}
best_intercept = some_intercepts[rows]
best_intercept
```

```{python}
best_si_slope = some_slopes[cols]
best_si_slope
```

```{python}
si_predicted = best_intercept + fert * best_si_slope
just_s_predicted = fert * best_slope
plt.plot(fert, mmr, 'o')
plt.plot(fert, just_s_predicted, 'o', color='red', label='Slope only')
plt.plot(fert, si_predicted, 'o', color='green', label='Slope and intercept')
plt.legend()
plt.axis([0, 8, -200, 1500])
```

```{python}
minimize(sos_si_error, [0, 0])
```

```{python}
from scipy.stats import linregress
```

```{python}
linregress(fert, mmr)
```
