FUNCTION  <SNR>74_GetMdIndent()
    Defined: /usr/local/Cellar/macvim/8.1-161_1/MacVim.app/Contents/Resources/vim/runtime/indent/rmd.vim:26
Called 7 times
Total time:   0.000156
 Self time:   0.000156

count  total (s)   self (s)
    7              0.000025   let pline = getline(v:lnum - 1)
    7              0.000016   let cline = getline(v:lnum)
    7              0.000048   if prevnonblank(v:lnum - 1) < v:lnum - 1 || cline =~ '^\s*[-\+\*]\s' || cline =~ '^\s*\d\+\.\s\+'
    4              0.000008     return indent(v:lnum)
    3              0.000012   elseif pline =~ '^\s*[-\+\*]\s'
                                return indent(v:lnum - 1) + 2
    3              0.000011   elseif pline =~ '^\s*\d\+\.\s\+'
                                return indent(v:lnum - 1) + 3
    3              0.000002   endif
    3              0.000010   return indent(prevnonblank(v:lnum - 1))

FUNCTION  <SNR>29_SetDefaultCompletionType()
    Defined: ~/dev_trees/myvim/bundle/supertab/plugin/supertab.vim:308
Called 2 times
Total time:   0.000082
 Self time:   0.000082

count  total (s)   self (s)
    2              0.000051   if exists('b:SuperTabDefaultCompletionType') && (!exists('b:complCommandLine') || !b:complCommandLine)
                                call SuperTabSetCompletionType(b:SuperTabDefaultCompletionType)
    2              0.000007   endif

FUNCTION  <SNR>37_YRInsertLeave()
    Defined: ~/dev_trees/myvim/bundle/yankring/plugin/yankring.vim:2395
Called 2 times
Total time:   0.003252
 Self time:   0.000182

count  total (s)   self (s)
                                " The YankRing uses omaps to execute the prescribed motion
                                " and then appends to the motion a call to a YankRing 
                                " function to record the contents of the changed register.
                                "
                                " We cannot append a function call to the end of a motion
                                " that results in Insert mode.  For example, any command
                                " like 'cw' enters insert mode.  Appending a function call
                                " after the w, simply writes out the call as if the user 
                                " typed it.
                                "
                                " Using the InsertLeave event, allows us to capture the 
                                " contents of any changed register after it completes.
                                
    2   0.002175   0.000083     call YRRecord(s:YRRegister())
                            
                                " When performing a change (not a yank or delete)
                                " it is not possible to call <SID>yrrecord at the end
                                " of the command (or it's contents will be inserted 
                                " into the buffer instead of executed).
                                " So, when using ".", we have to remove the _zap_
                                " keys and then re-add them back again after we 
                                " record the updates.
    2              0.000007     if s:yr_remove_omap_dot == 1
    2   0.001019   0.000041         call s:YRMapsCreate('add_only_zap_keys')
    2              0.000004     endif
                            

FUNCTION  <SNR>37_YRWindowUpdate()
    Defined: ~/dev_trees/myvim/bundle/yankring/plugin/yankring.vim:1880
Called 2 times
Total time:   0.000070
 Self time:   0.000070

count  total (s)   self (s)
    2              0.000022     let orig_win_bufnr = bufwinnr('%')
                            
                                " Switch to the yankring buffer
                                " only if it is already visible
    2              0.000014     if bufwinnr(s:yr_buffer_id) != -1
                                    call s:YRShow(0)
                                    " Switch back to the original buffer
                                    exec orig_win_bufnr . "wincmd w"
    2              0.000004     endif

FUNCTION  <SNR>37_YRHistoryRead()
    Defined: ~/dev_trees/myvim/bundle/yankring/plugin/yankring.vim:1795
Called 2 times
Total time:   0.000804
 Self time:   0.000804

count  total (s)   self (s)
    2              0.000008     let refresh_needed  = 1
    2              0.000008     let yr_history_list = []
    2              0.000019     let yr_filename     = s:yr_history_file_{s:yr_history_version}
                            
    2              0.000527     if filereadable(yr_filename)
    2              0.000142         let last_upd = getftime(yr_filename)
                            
    2              0.000019         if s:yr_history_last_upd != 0 && last_upd <= s:yr_history_last_upd
    2              0.000007             let refresh_needed = 0
    2              0.000005         endif
                            
    2              0.000008         if refresh_needed == 1
                                        let s:yr_history_list = readfile(yr_filename)
                                        let s:yr_history_last_upd = last_upd
                                        let s:yr_count = len(s:yr_history_list)
                                        return
    2              0.000004         else
    2              0.000004             return
                                    endif
                                else
                                    if s:yr_history_version == 'v2'
                                        " Check to see if an upgrade is required
                                        " else, let the empty yr_history_list be returned.
                                        if filereadable(s:yr_history_file_v1)
                                            " Perform upgrade to v2 of the history file
                                            call s:YRHistoryUpgrade('v1')
                                            return
                                        endif
                                    endif
                                endif
                            
                                let s:yr_history_list = yr_history_list
                                call s:YRHistorySave()
                            

FUNCTION  GetRmdIndent()
    Defined: /usr/local/Cellar/macvim/8.1-161_1/MacVim.app/Contents/Resources/vim/runtime/indent/rmd.vim:49
Called 7 times
Total time:   0.001165
 Self time:   0.001009

count  total (s)   self (s)
    7              0.000071   if getline(".") =~ '^[ \t]*```{r .*}$' || getline(".") =~ '^[ \t]*```$'
                                return 0
    7              0.000003   endif
    7              0.000619   if search('^[ \t]*```{r', "bncW") > search('^[ \t]*```$', "bncW")
                                return s:RIndent()
    7              0.000195   elseif v:lnum > 1 && search('^---$', "bnW") == 1 && (search('^---$', "nW") > v:lnum || search('^...$', "nW") > v:lnum)
                                return s:GetYamlIndent()
    7              0.000004   else
    7   0.000220   0.000064     return s:GetMdIndent()
                              endif

FUNCTION  pandoc#folding#MarkdownLevelSA()
    Defined: ~/dev_trees/myvim/bundle/vim-pandoc/autoload/pandoc/folding.vim:226
Called 19084 times
Total time:   1.940359
 Self time:   1.940359

count  total (s)   self (s)
19084              0.055530     let vline = getline(v:lnum)
19084              0.068140     let vline1 = getline(v:lnum + 1)
19084              0.087302     if vline =~# '^#\{1,6}[^.]'
  498              0.047698         if synIDattr(synID(v:lnum, 1, 1), 'name') =~# '^pandoc\(DelimitedCodeBlock$\)\@!'
                                        if g:pandoc#folding#mode ==# 'relative'
                                            return '>'. len(markdown#headers#CurrentHeaderAncestors(v:lnum))
                                        elseif g:pandoc#folding#mode ==# 'stacked'
                                            return '>1'
                                        else
                                            return '>'. len(matchstr(vline, '^#\{1,6}'))
                                        endif
  498              0.000390         endif
18586              0.193936     elseif vline =~# '^[^-=].\+$' && vline1 =~# '^=\+$'
                                    if synIDattr(synID(v:lnum, 1, 1), 'name') =~# '^pandoc\(DelimitedCodeBlock$\)\@!'  && synIDattr(synID(v:lnum + 1, 1, 1), 'name') ==# 'pandocSetexHeader'
                                        return '>1'
                                    endif
18586              0.169682     elseif vline =~# '^[^-=].\+$' && vline1 =~# '^-\+$'
  166              0.062192         if synIDattr(synID(v:lnum, 1, 1), 'name') =~# '^pandoc\(DelimitedCodeBlock$\)\@!'  && synIDattr(synID(v:lnum + 1, 1, 1), 'name') ==# 'pandocSetexHeader'
                                        if g:pandoc#folding#mode ==# 'relative'
                                            return  '>'. len(markdown#headers#CurrentHeaderAncestors(v:lnum))
                                        elseif g:pandoc#folding#mode ==# 'stacked'
                                            return '>1'
                                        else
                                            return '>2'
                                        endif
  166              0.000114         endif
18420              0.086632     elseif vline =~? '^<!--.*fold-begin -->'
                                    return 'a1'
18420              0.076400     elseif vline =~? '^<!--.*fold-end -->'
                                    return 's1'
18420              0.089865     elseif vline =~# '^\s*[`~]\{3}'
 1660              0.003271         if g:pandoc#folding#fold_fenced_codeblocks == 1
                                        let synId = synIDattr(synID(v:lnum, match(vline, '[`~]') + 1, 1), 'name')
                                        if synId ==# 'pandocDelimitedCodeBlockStart'
                                            return 'a1'
                                        elseif synId =~# '^pandoc\(DelimitedCodeBlock$\)\@!'
                                            return 's1'
                                        endif
 1660              0.001373         endif
19084              0.011842     endif
19084              0.019910     return '='

FUNCTION  <SNR>37_YRMRUHas()
    Defined: ~/dev_trees/myvim/bundle/yankring/plugin/yankring.vim:1712
Called 2 times
Total time:   0.000047
 Self time:   0.000047

count  total (s)   self (s)
                                " This function will find a string and return the element #
    2              0.000033     let find_idx = index({a:mru_list}, a:find_str)
                            
    2              0.000006     return find_idx

FUNCTION  <SNR>37_YRMRUAdd()
    Defined: ~/dev_trees/myvim/bundle/yankring/plugin/yankring.vim:1727
Called 2 times
Total time:   0.001409
 Self time:   0.000328

count  total (s)   self (s)
                                " Only add new items if they do not already exist in the MRU.
                                " If the item is found, move it to the start of the MRU.
    2              0.000009     let found   = -1
                                " let elem    = a:element
                                " if g:yankring_max_element_length != 0
                                "     let elem    = strpart(a:element, 0, g:yankring_max_element_length)
                                " endif
                                " if s:yr_history_version == 'v1'
                                "     let elem    = escape(elem, '@')
                                "     let elem    = substitute(elem, "\n", s:yr_history_v1_nl, 'g')
                                " else
                                "     let elem    = substitute(elem, "\n", s:yr_history_v2_nl, 'g')
                                " endif
                                " " Append the regtype to the end so we have it available
                                " let elem    = elem.",".a:element_type
                            
    2              0.000020     if strlen(a:element) < g:yankring_min_element_length
                                    return 1
    2              0.000004     endif
                            
    2   0.000277   0.000047     let elem = s:YRMRUElemFormat(a:element, a:element_type)
                            
                                " Refresh the List
    2   0.000848   0.000044     call s:YRHistoryRead()
                            
    2   0.000101   0.000054     let found   = s:YRMRUHas(a:mru_list, elem)
                            
                                " Special case for efficiency, if it is first item in the 
                                " List, do nothing
    2              0.000006     if found != 0
                                    if found != -1
                                        " Remove found item since we will add it to the top
                                        call remove({a:mru_list}, found)
                                    endif
                                    call insert({a:mru_list}, elem, 0)
                                    call s:YRHistorySave()
    2              0.000011     endif
                            
    2              0.000007     return 1

FUNCTION  <SNR>37_YRMapsCreate()
    Defined: ~/dev_trees/myvim/bundle/yankring/plugin/yankring.vim:1460
Called 2 times
Total time:   0.000978
 Self time:   0.000978

count  total (s)   self (s)
                                " 7.1.patch205 introduces the v:operator function which was 
                                " essential to gain the omap support.
    2              0.000008     if s:yr_has_voperator == 1
    2              0.000010         let s:yr_remove_omap_dot   = 1
   16              0.000117         for key in split(g:yankring_zap_keys)
   14              0.000025             try
   14              0.000056                 if key != '@'
   12              0.000481                     exec 'omap <expr>' key 'YRMapsExpression("<SID>", "'. key. '", 1)'
   14              0.000021                 endif
                                        catch
   14              0.000022             endtry
   16              0.000032         endfor
    2              0.000003     endif
                            
    2              0.000056     silent! nmap <expr> @ YRMapsExpression("<SID>", "@", "1")
                            
    2              0.000011     let s:yr_maps_created_zap = 1
                            
    2              0.000006     if a:0 > 0
                                    " We have only removed the _zap_ keys temporarily
                                    " so abandon further changes.
    2              0.000006         return
                                endif
                            
                                " 7.1.patch205 introduces the v:operator function which was essential
                                " to gain the omap support.
                                if s:yr_has_voperator == 1
                                    let s:yr_remove_omap_dot   = 1
                                    " Set option to add and remove _zap_ keys when
                                    " repeating commands
                                    let o_maps = split(g:yankring_o_keys)
                                    " Loop through and prompt the user for all buffer connection parameters.
                                    for key in o_maps
                                        exec 'omap <expr>' key 'YRMapsExpression("<SID>", "'. escape(key,'\"'). '")'
                                    endfor
                                endif
                            
                                " Iterate through a space separated list of mappings and create
                                " calls to the YRYankCount function
                                let n_maps = split(g:yankring_n_keys)
                                " Loop through and prompt the user for all buffer connection parameters.
                                for key in n_maps
                                    " exec 'nnoremap <silent>'.key." :<C-U>YRYankCount '".key."'<CR>"
                                    " exec 'nnoremap <silent>'.key." :<C-U>YRYankCount '".key."'<CR>"
                                    " Andy Wokula's suggestion
                                    exec 'nmap' key key."<SID>yrrecord"
                                endfor
                            
                                if g:yankring_map_dot == 1
                                    if s:yr_has_voperator == 1
                                        nmap <expr> . YRMapsExpression("<SID>", ".")
                                    else
                                        nnoremap <silent> . :<C-U>YRYankCount '.'<CR>
                                    endif
                                endif
                            
                                if g:yankring_v_key != ''
                                    exec 'xnoremap <silent>'.g:yankring_v_key." :YRYankRange 'v'<CR>"
                                endif
                                if g:yankring_del_v_key != ''
                                    for v_map in split(g:yankring_del_v_key)
                                        if strlen(v_map) > 0
                                            try
                                                exec 'xnoremap <silent>'.v_map." :YRDeleteRange 'v'<CR>"
                                            catch
                                            endtry
                                        endif
                                    endfor
                                endif
                                if g:yankring_paste_n_bkey != ''
                                    exec 'nnoremap <silent>'.g:yankring_paste_n_bkey." :<C-U>YRPaste 'P'<CR>"
                                    if g:yankring_paste_using_g == 1
                                        exec 'nnoremap <silent> g'.g:yankring_paste_n_bkey." :<C-U>YRPaste 'gP'<CR>"
                                    endif
                                endif
                                if g:yankring_paste_n_akey != ''
                                    exec 'nnoremap <silent>'.g:yankring_paste_n_akey." :<C-U>YRPaste 'p'<CR>"
                                    if g:yankring_paste_using_g == 1
                                        exec 'nnoremap <silent> g'.g:yankring_paste_n_akey." :<C-U>YRPaste 'gp'<CR>"
                                    endif
                                endif
                                if g:yankring_paste_v_bkey != ''
                                    exec 'xnoremap <silent>'.g:yankring_paste_v_bkey." :<C-U>YRPaste 'P', 'v'<CR>"
                                endif
                                if g:yankring_paste_v_akey != ''
                                    exec 'xnoremap <silent>'.g:yankring_paste_v_akey." :<C-U>YRPaste 'p', 'v'<CR>"
                                endif
                                if g:yankring_replace_n_pkey != ''
                                    exec 'nnoremap <silent>'.g:yankring_replace_n_pkey." :<C-U>YRReplace '-1', 'P'<CR>"
                                endif
                                if g:yankring_replace_n_nkey != ''
                                    exec 'nnoremap <silent>'.g:yankring_replace_n_nkey." :<C-U>YRReplace '1', 'p'<CR>"
                                endif
                            
                                let g:yankring_enabled    = 1
                                let s:yr_maps_created     = 1
                            
                                if exists('*YRRunAfterMaps') 
                                    " This will allow you to override the default maps if necessary
                                    call YRRunAfterMaps()
                                endif

FUNCTION  <SNR>42_Highlight_Matching_Pair()
    Defined: /usr/local/Cellar/macvim/8.1-161_1/MacVim.app/Contents/Resources/vim/runtime/plugin/matchparen.vim:39
Called 159 times
Total time:   0.012290
 Self time:   0.012290

count  total (s)   self (s)
                              " Remove any previous match.
  159              0.000571   if exists('w:paren_hl_on') && w:paren_hl_on
                                silent! call matchdelete(3)
                                let w:paren_hl_on = 0
  159              0.000110   endif
                            
                              " Avoid that we remove the popup menu.
                              " Return when there are no colors (looks like the cursor jumps).
  159              0.000636   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
                                return
  159              0.000068   endif
                            
                              " Get the character under the cursor and check if it's in 'matchpairs'.
  159              0.000389   let c_lnum = line('.')
  159              0.000352   let c_col = col('.')
  159              0.000163   let before = 0
                            
  159              0.000355   let text = getline(c_lnum)
  159              0.002048   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
  159              0.000315   if empty(matches)
                                let [c_before, c] = ['', '']
  159              0.000105   else
  159              0.000669     let [c_before, c] = matches[1:2]
  159              0.000084   endif
  159              0.001768   let plist = split(&matchpairs, '.\zs[:,]')
  159              0.000418   let i = index(plist, c)
  159              0.000158   if i < 0
                                " not found, in Insert mode try character before the cursor
  159              0.000597     if c_col > 1 && (mode() == 'i' || mode() == 'R')
  142              0.000349       let before = strlen(c_before)
  142              0.000176       let c = c_before
  142              0.000285       let i = index(plist, c)
  159              0.000092     endif
  159              0.000129     if i < 0
                                  " not found, nothing to do
  159              0.000165       return
                                endif
                              endif
                            
                              " Figure out the arguments for searchpairpos().
                              if i % 2 == 0
                                let s_flags = 'nW'
                                let c2 = plist[i + 1]
                              else
                                let s_flags = 'nbW'
                                let c2 = c
                                let c = plist[i - 1]
                              endif
                              if c == '['
                                let c = '\['
                                let c2 = '\]'
                              endif
                            
                              " Find the match.  When it was just before the cursor move it there for a
                              " moment.
                              if before > 0
                                let has_getcurpos = exists("*getcurpos")
                                if has_getcurpos
                                  " getcurpos() is more efficient but doesn't exist before 7.4.313.
                                  let save_cursor = getcurpos()
                                else
                                  let save_cursor = winsaveview()
                                endif
                                call cursor(c_lnum, c_col - before)
                              endif
                            
                              if !has("syntax") || !exists("g:syntax_on")
                                let s_skip = "0"
                              else
                                " Build an expression that detects whether the current cursor position is
                                " in certain syntax types (string, comment, etc.), for use as
                                " searchpairpos()'s skip argument.
                                " We match "escape" for special items, such as lispEscapeSpecial.
                                let s_skip = '!empty(filter(map(synstack(line("."), col(".")), ''synIDattr(v:val, "name")''), ' . '''v:val =~? "string\\|character\\|singlequote\\|escape\\|comment"''))'
                                " If executing the expression determines that the cursor is currently in
                                " one of the syntax types, then we want searchpairpos() to find the pair
                                " within those syntax types (i.e., not skip).  Otherwise, the cursor is
                                " outside of the syntax types and s_skip should keep its value so we skip
                                " any matching pair inside the syntax types.
                                " Catch if this throws E363: pattern uses more memory than 'maxmempattern'.
                                try
                                  execute 'if ' . s_skip . ' | let s_skip = "0" | endif'
                                catch /^Vim\%((\a\+)\)\=:E363/
                                  " We won't find anything, so skip searching, should keep Vim responsive.
                                  return
                                endtry
                              endif
                            
                              " Limit the search to lines visible in the window.
                              let stoplinebottom = line('w$')
                              let stoplinetop = line('w0')
                              if i % 2 == 0
                                let stopline = stoplinebottom
                              else
                                let stopline = stoplinetop
                              endif
                            
                              " Limit the search time to 300 msec to avoid a hang on very long lines.
                              " This fails when a timeout is not supported.
                              if mode() == 'i' || mode() == 'R'
                                let timeout = exists("b:matchparen_insert_timeout") ? b:matchparen_insert_timeout : g:matchparen_insert_timeout
                              else
                                let timeout = exists("b:matchparen_timeout") ? b:matchparen_timeout : g:matchparen_timeout
                              endif
                              try
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline, timeout)
                              catch /E118/
                                " Can't use the timeout, restrict the stopline a bit more to avoid taking
                                " a long time on closed folds and long lines.
                                " The "viewable" variables give a range in which we can scroll while
                                " keeping the cursor at the same position.
                                " adjustedScrolloff accounts for very large numbers of scrolloff.
                                let adjustedScrolloff = min([&scrolloff, (line('w$') - line('w0')) / 2])
                                let bottom_viewable = min([line('$'), c_lnum + &lines - adjustedScrolloff - 2])
                                let top_viewable = max([1, c_lnum-&lines+adjustedScrolloff + 2])
                                " one of these stoplines will be adjusted below, but the current values are
                                " minimal boundaries within the current window
                                if i % 2 == 0
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = min([line2byte("$"), line2byte(".") + col(".") + &smc * 2])
                            	let stopline = min([bottom_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = min([bottom_viewable, c_lnum + 100])
                                  endif
                                  let stoplinebottom = stopline
                                else
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = max([1, line2byte(".") + col(".") - &smc * 2])
                            	let stopline = max([top_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = max([top_viewable, c_lnum - 100])
                                  endif
                                  let stoplinetop = stopline
                                endif
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline)
                              endtry
                            
                              if before > 0
                                if has_getcurpos
                                  call setpos('.', save_cursor)
                                else
                                  call winrestview(save_cursor)
                                endif
                              endif
                            
                              " If a match is found setup match highlighting.
                              if m_lnum > 0 && m_lnum >= stoplinetop && m_lnum <= stoplinebottom 
                                if exists('*matchaddpos')
                                  call matchaddpos('MatchParen', [[c_lnum, c_col - before], [m_lnum, m_col]], 10, 3)
                                else
                                  exe '3match MatchParen /\(\%' . c_lnum . 'l\%' . (c_col - before) . 'c\)\|\(\%' . m_lnum . 'l\%' . m_col . 'c\)/'
                                endif
                                let w:paren_hl_on = 1
                              endif

FUNCTION  <SNR>37_YRMRUElemFormat()
    Defined: ~/dev_trees/myvim/bundle/yankring/plugin/yankring.vim:1685
Called 2 times
Total time:   0.000230
 Self time:   0.000230

count  total (s)   self (s)
    2              0.000009     let elem    = a:element
    2              0.000008     if g:yankring_max_element_length != 0
    2              0.000018         let elem    = strpart(a:element, 0, g:yankring_max_element_length)
    2              0.000008         if (g:yankring_warn_on_truncate > 0)
    2              0.000028             let bytes = len (a:element) - len(elem)
    2              0.000006             if (bytes > 0)
                                            call s:YRWarningMsg("Yankring truncated its element by ". bytes. " bytes due to a g:yankring_max_element_length of ". g:yankring_max_element_length )
    2              0.000004             endif
    2              0.000003         endif
    2              0.000002     endif
    2              0.000010     if s:yr_history_version == 'v1'
                                    let elem    = escape(elem, '@')
                                    let elem    = substitute(elem, "\n", s:yr_history_v1_nl, 'g')
    2              0.000003     else
    2              0.000045         let elem    = substitute(elem, "\n", s:yr_history_v2_nl, 'g')
    2              0.000003     endif
                                " Append the regtype to the end so we have it available
    2              0.000015     let elem    = elem.",".a:element_type
                            
    2              0.000006     return elem

FUNCTION  pandoc#folding#FoldExpr()
    Defined: ~/dev_trees/myvim/bundle/vim-pandoc/autoload/pandoc/folding.vim:109
Called 19084 times
Total time:   4.078486
 Self time:   2.138127

count  total (s)   self (s)
                                " with multiple splits in the same buffer, the folding code can be called
                                " way too many times too often, so it's best to disable it to keep good
                                " performance. Only enable when using the built-in method of improving
                                " performance of folds.
19084              0.032246     if g:pandoc#folding#fastfolds == 1
                                    if count(map(range(1, winnr('$')), 'bufname(winbufnr(v:val))'), bufname('')) > 1
                                        return
                                    endif
19084              0.011826     endif
                            
19084              0.055134     let vline = getline(v:lnum)
                                " fold YAML headers
19084              0.027305     if g:pandoc#folding#fold_yaml == 1
                                    if vline =~# '\(^---$\|^...$\)' && synIDattr(synID(v:lnum , 1, 1), 'name') =~? '\(delimiter\|yamldocumentstart\)'
                                        if vline =~# '^---$' && v:lnum == 1
                                            return '>1'
                                        elseif synIDattr(synID(v:lnum - 1, 1, 1), 'name') ==# 'yamlkey'
                                            return '<1'
                                        elseif synIDattr(synID(v:lnum - 1, 1, 1), 'name') ==# 'pandocYAMLHeader'
                                            return '<1'
                                        elseif synIDattr(synID(v:lnum - 1, 1, 1), 'name') ==# 'yamlBlockMappingKey'
                                            return '<1'
                                        else
                                            return '='
                                        endif
                                    endif
19084              0.011434     endif
                            
                                " fold divs for special classes
19084              0.104656     let div_classes_regex = '('.join(g:pandoc#folding#fold_div_classes, '|').')'
19084              0.111836     if vline =~? '<div class=.'.div_classes_regex
                                    return 'a1'
                                " the `endfold` attribute must be set, otherwise we can remove folds
                                " incorrectly (see issue #32)
                                " pandoc ignores this attribute, so this is safe.
19084              0.079035     elseif vline =~? '</div endfold>'
                                    return 's1'
19084              0.012946     endif
                            
                                " fold markers?
19084              0.029977     if g:pandoc#folding#fold_vim_markers == 1
19084              0.133287         if vline =~# '[{}]\{3}'
                                        if g:pandoc#folding#vim_markers_in_comments_only == 1
                                            let mark_head = '<!--.*'
                                        else
                                            let mark_head = ''
                                        endif
                                        if vline =~# mark_head.'{\{3}'
                                            let level = matchstr(vline, '\({\{3}\)\@<=\d')
                                            if level !=# ''
                                                return '>'.level
                                            else
                                                return 'a1'
                                            endif
                                        endif
                                        if vline =~# mark_head.'}\{3}'
                                            let level = matchstr(vline, '\(}\{3}\)\@<=\d')
                                            if level !=# ''
                                                return '<'.level
                                            else
                                                return 's1'
                                            endif
                                        endif
19084              0.013211         endif
19084              0.012332     endif
                            
                                " Delegate to filetype specific functions
19084              0.100869     if &filetype =~# 'markdown' || &filetype ==# 'pandoc' || &filetype ==# 'rmd'
                                    " vim-pandoc-syntax sets this variable, so we can check if we can use
                                    " syntax assistance in our foldexpr function
19084              0.079947         if exists('g:vim_pandoc_syntax_exists') && b:pandoc_folding_basic != 1
19084   2.103642   0.163283             return pandoc#folding#MarkdownLevelSA()
                                    " otherwise, we use a simple, but less featureful foldexpr
                                    else
                                        return pandoc#folding#MarkdownLevelBasic()
                                    endif
                                elseif &filetype ==# 'textile'
                                    return pandoc#folding#TextileLevel()
                                endif
                            

FUNCTION  <SNR>37_YRRegister()
    Defined: ~/dev_trees/myvim/bundle/yankring/plugin/yankring.vim:699
Called 2 times
Total time:   0.000118
 Self time:   0.000118

count  total (s)   self (s)
                                " v:register can be blank in some (unknown) cases
                                " so test for this condition and return the 
                                " default register
    2              0.000067     let user_register = ((v:register=='')?('"'):(v:register))
    2              0.000019     if &clipboard == 'unnamed' && user_register == '"'
                                    let user_register = '+'
    2              0.000003     endif
    2              0.000008     return user_register

FUNCTION  YRRecord()
    Defined: ~/dev_trees/myvim/bundle/yankring/plugin/yankring.vim:773
Called 2 times
Total time:   0.001974
 Self time:   0.000495

count  total (s)   self (s)
                            
    2              0.000010     let register = '"'
    2              0.000010     if a:0 > 0
                                    " If no yank command has been supplied, assume it is
                                    " a full line yank
    2              0.000057         let register = ((a:1 == '') ? register : a:1)
    2              0.000008     endif
                            
                                " v:register can be blank in some (unknown) cases
                                " if v:register == '' || v:register == '_'
    2              0.000012     if v:register == '_'
                                    " Black hole register, ignore recording the operation
                                    return ""
    2              0.000004     endif
                            
    2              0.000016     let register = ((&clipboard=='unnamed')?'+':register)
                            
                                " let s:yr_prev_changenr    = changenr()
    2              0.000008     if register == '"'
                                    " If the change has occurred via an omap, we must delay
                                    " the capture of the default register until this event
                                    " since register updates are not reflected until the 
                                    " omap function completes
    2              0.000024         let s:yr_prev_reg_unnamed = getreg('"')
    2              0.000014         let s:yr_prev_reg_small   = getreg('-')
    2              0.000002     endif
                            
                                " Add item to list
                                " This will also account for duplicates.
    2   0.001516   0.000107     call s:YRMRUAdd( 's:yr_history_list' , getreg(register) , getregtype(register)  )
                            
    2              0.000072     if register =~ '[+*]'
                                    let s:yr_prev_clipboard = @+
    2              0.000003     endif
                            
                                " If the yankring window is open, refresh it
    2   0.000113   0.000043     call s:YRWindowUpdate()
                            
                                " Manage the numbered registers
    2              0.000008     if g:yankring_manage_numbered_reg == 1
                                    call s:YRSetNumberedReg()
    2              0.000004     endif
                            
    2              0.000004     return ""

FUNCTION  <SNR>29_SelectCompletion()
    Defined: ~/dev_trees/myvim/bundle/supertab/plugin/supertab.vim:684
Called 6 times
Total time:   0.001118
 Self time:   0.001118

count  total (s)   self (s)
                                  " selecting a completion
    6              0.000084       if pumvisible()
                                    " ugly hack to let other <cr> mappings for other plugins cooperate
                                    " with supertab
                                    let b:supertab_pumwasvisible = 1
                                    return "\<c-y>"
    6              0.000018       endif
                            
    6              0.000075       if exists('b:supertab_pumwasvisible')
                                    unlet b:supertab_pumwasvisible
                                    return ''
    6              0.000016       endif
                            
                                  " not so pleasant hack to keep <cr> working for abbreviations
    6              0.000345       let word = substitute(getline('.'), '^.*\s\+\(.*\%' . col('.') . 'c\).*', '\1', '')
    6              0.000077       if maparg(word, 'i', 1) != ''
                                    call feedkeys("\<c-]>", 't')
                                    call feedkeys("\<cr>", 'n')
                                    return ''
    6              0.000010       endif
                            
                                  " only return a cr if nothing else is mapped to it since we don't want
                                  " to duplicate a cr returned by another mapping.
    6              0.000045       return a:cr ? "\<cr>" : ""

FUNCTIONS SORTED ON TOTAL TIME
count  total (s)   self (s)  function
19084   4.078486   2.138127  pandoc#folding#FoldExpr()
19084   1.940359             pandoc#folding#MarkdownLevelSA()
  159   0.012290             <SNR>42_Highlight_Matching_Pair()
    2   0.003252   0.000182  <SNR>37_YRInsertLeave()
    2   0.001974   0.000495  YRRecord()
    2   0.001409   0.000328  <SNR>37_YRMRUAdd()
    7   0.001165   0.001009  GetRmdIndent()
    6   0.001118             <SNR>29_SelectCompletion()
    2   0.000978             <SNR>37_YRMapsCreate()
    2   0.000804             <SNR>37_YRHistoryRead()
    2   0.000230             <SNR>37_YRMRUElemFormat()
    7   0.000156             <SNR>74_GetMdIndent()
    2   0.000118             <SNR>37_YRRegister()
    2   0.000082             <SNR>29_SetDefaultCompletionType()
    2   0.000070             <SNR>37_YRWindowUpdate()
    2   0.000047             <SNR>37_YRMRUHas()

FUNCTIONS SORTED ON SELF TIME
count  total (s)   self (s)  function
19084   4.078486   2.138127  pandoc#folding#FoldExpr()
19084              1.940359  pandoc#folding#MarkdownLevelSA()
  159              0.012290  <SNR>42_Highlight_Matching_Pair()
    6              0.001118  <SNR>29_SelectCompletion()
    7   0.001165   0.001009  GetRmdIndent()
    2              0.000978  <SNR>37_YRMapsCreate()
    2              0.000804  <SNR>37_YRHistoryRead()
    2   0.001974   0.000495  YRRecord()
    2   0.001409   0.000328  <SNR>37_YRMRUAdd()
    2              0.000230  <SNR>37_YRMRUElemFormat()
    2   0.003252   0.000182  <SNR>37_YRInsertLeave()
    7              0.000156  <SNR>74_GetMdIndent()
    2              0.000118  <SNR>37_YRRegister()
    2              0.000082  <SNR>29_SetDefaultCompletionType()
    2              0.000070  <SNR>37_YRWindowUpdate()
    2              0.000047  <SNR>37_YRMRUHas()

