SCRIPT  /Users/brettmz-admin/dev_trees/myvim/bundle/vim-snipmate/autoload/snipMate.vim
Sourced 1 time
Total time:   0.014994
 Self time:   0.001837

count  total (s)   self (s)
                            " config which can be overridden (shared lines)
    1              0.000022 if !exists('g:snipMate')
                              let g:snipMate = {}
    1              0.000004 endif
                            
    1              0.000004 try
    1   0.014263   0.001106 	call tlib#input#List('mi', '', [])
                            catch /.*/
                            	echoe "tlib is missing. See install instructions at ".expand('<sfile>:h:h').'/README.md'
    1              0.000002 endtry
                            
    1              0.000002 fun! Filename(...) abort
                            	let filename = expand('%:t:r')
                            	if filename == '' | return a:0 == 2 ? a:2 : '' | endif
                            	return !a:0 || a:1 == '' ? filename : substitute(a:1, '$1', filename, 'g')
                            endf
                            
    1              0.000003 let s:cache = {}
                            
    1              0.000003 function! snipMate#expandSnip(snip, version, col) abort
                            	let lnum = line('.')
                            	let col = a:col
                            	let line = getline(lnum)
                            	let indent = match(line, '\S\|$') + 1
                            	let b:snip_state = snipmate#jumping#state()
                            
                            	if a:version == 1
                            		let [snippet, b:snip_state.stops] = snipmate#parse#snippet(a:snip)
                            		" Build stop/mirror info
                            		let b:snip_state.stop_count = s:build_stops(snippet, b:snip_state.stops, lnum, col, indent)
                            	else
                            		let snippet = snipmate#legacy#process_snippet(a:snip)
                            		let [b:snip_state.stops, b:snip_state.stop_count] = snipmate#legacy#build_stops(snippet, lnum, col - indent, indent)
                            	endif
                            
                            	" Abort if the snippet is empty
                            	if empty(snippet)
                            		return ''
                            	endif
                            
                            	let col = s:insert_snippet_text(snippet, lnum, col, indent)
                            
                            	" Open any folds snippet expands into
                            	if &foldenable
                            		silent! exec lnum . ',' . (lnum + len(snipLines) - 1) . 'foldopen'
                            	endif
                            
                            	aug snipmate_changes
                            		au CursorMoved,CursorMovedI <buffer> if exists('b:snip_state') |
                            					\     call b:snip_state.update_changes() |
                            					\ else |
                            					\     silent! au! snipmate_changes * <buffer> |
                            					\ endif
                            	aug END
                            
                            	let b:snip_state.stop_no = 0
                            	return b:snip_state.set_stop(0)
                            endfunction
                            
    1              0.000004 function! s:insert_snippet_text(snippet, lnum, col, indent)
                            	let line = getline(a:lnum)
                            	let col = a:col
                            	let snippet = type(a:snippet) == type([]) ? a:snippet : split(a:snippet, "\n", 1)
                            	let lnum = a:lnum
                            
                            	" Keep text after the cursor
                            	let afterCursor = strpart(line, col - 1)
                            	if afterCursor != "\t" && afterCursor != ' '
                            		let line = strpart(line, 0, col - 1)
                            	else
                            		let afterCursor = ''
                            		" For some reason the cursor needs to move one right after this
                            		if line != '' && col == 1 && &ve != 'all' && &ve != 'onemore'
                            			let col += 1
                            		endif
                            	endif
                            
                            	call setline(lnum, '')
                            	call append(lnum, repeat([''], len(snippet) - 1))
                            
                            	for item in snippet
                            		let add = lnum == a:lnum ? line : strpart(line, 0, a:indent - 1)
                            
                            		if !(empty(item) || (type(item) == type([]) && empty(item[0])))
                            			if type(item) == type([])
                            				call setline(lnum, add .
                            							\ snipMate#sniplist_str(item, b:snip_state.stops))
                            			else
                            				call setline(lnum, add .
                            							\ substitute(item, printf('%s\d\+\|%s{\d\+.\{-}}',
                            							\ g:snipmate#legacy#sigil, g:snipmate#legacy#sigil),
                            							\ '', 'g'))
                            			endif
                            		endif
                            
                            		let lnum += 1
                            	endfor
                            
                            	call setline(lnum - 1, getline(lnum - 1) . afterCursor)
                            
                            	return col
                            endfunction
                            
    1              0.000003 function! snipMate#placeholder_str(num, stops) abort
                            	return snipMate#sniplist_str(a:stops[a:num].placeholder, a:stops)
                            endfunction
                            
    1              0.000002 function! snipMate#sniplist_str(snippet, stops) abort
                            	let str = ''
                            	let pos = 0
                            	let add_to = 1
                            	let seen_stops = []
                            
                            	while pos < len(a:snippet)
                            		let item = a:snippet[pos]
                            
                            		if type(item) == type('')
                            			let str .= item
                            		elseif type(item) == type([])
                            			let placeholder = snipMate#placeholder_str(item[0], a:stops)
                            			if len(item) > 1 && type(item[1]) == type({})
                            				let placeholder = substitute(placeholder,
                            							\ get(item[1], 'pat', ''),
                            							\ get(item[1], 'sub', ''),
                            							\ get(item[1], 'flags', ''))
                            			endif
                            			let str .= placeholder
                            		endif
                            
                            		let pos += 1
                            		unlet item " avoid E706
                            	endwhile
                            
                            	return str
                            endfunction
                            
    1              0.000004 function! s:build_stops(snippet, stops, lnum, col, indent) abort
                            	let stops = a:stops
                            	let lnum  = a:lnum
                            	let col   = a:col
                            
                            	for line in a:snippet
                            		let col = s:build_loc_info(line, stops, lnum, col, [])
                            		if line isnot a:snippet[-1]
                            			let lnum += 1
                            			let col = a:indent
                            		endif
                            	endfor
                            
                            	" add zero tabstop if it doesn't exist and then link it to the highest stop
                            	" number
                            	let stops[0] = get(stops, 0,
                            				\ { 'placeholder' : [], 'line' : lnum, 'col' : col })
                            	let stop_count = max(keys(stops)) + 2
                            	let stops[stop_count - 1] = stops[0]
                            
                            	return stop_count
                            endfunction
                            
    1              0.000004 function! s:build_loc_info(snippet, stops, lnum, col, seen_items) abort
                            	let stops   = a:stops
                            	let lnum    = a:lnum
                            	let col     = a:col
                            	let pos     = 0
                            	let in_text = 0
                            	let seen_items = a:seen_items
                            
                            	for item in a:snippet
                            		if type(item) == type('')
                            			let col += len(item)
                            		elseif type(item) == type([])
                            			let id = item[0]
                            			let stub = item[-1]
                            			let stub.line = lnum
                            			let stub.col = col
                            			call s:add_update_objects(stub, seen_items)
                            
                            			if len(item) > 2 && type(item[1]) != type({})
                            				let col = s:build_loc_info(item[1:-2], stops, lnum, col, seen_items)
                            			else
                            				let col += len(snipMate#placeholder_str(id, stops))
                            			endif
                            
                            			let in_text = 0
                            		endif
                            		unlet item " avoid E706
                            	endfor
                            
                            	return col
                            endfunction
                            
    1              0.000002 function! s:add_update_objects(object, targets) abort
                            	let targets = a:targets
                            
                            	for item in targets
                            		let item.update_objects = get(item, 'update_objects', [])
                            		call add(item.update_objects, a:object)
                            	endfor
                            
                            	call add(targets, a:object)
                            endfunction
                            
                            " reads a .snippets file
                            " returns list of
                            " ['triggername', 'name', 'contents']
                            " if triggername is not set 'default' is assumed
                            " TODO: better error checking
    1              0.000002 fun! snipMate#ReadSnippetsFile(file) abort
                            	let result = []
                            	let new_scopes = []
                            	if !filereadable(a:file) | return [result, new_scopes] | endif
                            	let inSnip = 0
                            	let line_no = 0
                            	let snipversion = get(g:snipMate, 'snippet_version', 0)
                            	for line in readfile(a:file) + ["\n"]
                            		let line_no += 1
                            
                            		if inSnip && (line[0] == "\t" || line == '')
                            			let content .= strpart(line, 1)."\n"
                            			continue
                            		elseif inSnip
                            			call add(result, [trigger, name,
                            						\     content[:-2], bang, snipversion])
                            			let inSnip = 0
                            		endif
                            
                            		if line[:6] == 'snippet'
                            			let inSnip = 1
                            			let bang = (line[7] == '!')
                            			if bang
                            				let bang += line[8] == '!'
                            			endif
                            			let trigger = strpart(line, 8 + bang)
                            			let name = ''
                            			let space = stridx(trigger, ' ') + 1
                            			if space " Process multi snip
                            				let name = strpart(trigger, space)
                            				let trigger = strpart(trigger, 0, space - 1)
                            			endif
                            			let content = ''
                            			if trigger =~ '^\s*$' " discard snippets with empty triggers
                            				echom 'Invalid snippet in' a:file 'near line' line_no
                            				let inSnip = 0
                            			endif
                            		elseif line[:6] == 'extends'
                            			call extend(new_scopes, map(split(strpart(line, 8)),
                            						\ "substitute(v:val, ',*$', '', '')"))
                            		elseif line[:6] == 'version'
                            			let snipversion = +strpart(line, 8)
                            		endif
                            	endfor
                            	return [result, new_scopes]
                            endf
                            
    1              0.000002 function! s:GetScopes() abort
                            	let ret = exists('b:snipMate.scope_aliases') ? copy(b:snipMate.scope_aliases) : {}
                            	let global = get(g:snipMate, 'scope_aliases', {})
                            	for alias in keys(global)
                            		if has_key(ret, alias)
                            			let ret[alias] = join(split(ret[alias], ',')
                            						\ + split(global[alias], ','), ',')
                            		else
                            			let ret[alias] = global[alias]
                            		endif
                            	endfor
                            	return ret
                            endfunction
                            
                            " adds scope aliases to list.
                            " returns new list
                            " the aliases of aliases are added recursively
    1              0.000002 fun! s:AddScopeAliases(list) abort
                              let did = {}
                              let scope_aliases = s:GetScopes()
                              let new = a:list
                              let new2 =  []
                              while !empty(new)
                            	for i in new
                            	  if !has_key(did, i)
                            		let did[i] = 1
                            		call extend(new2, split(get(scope_aliases,i,''),','))
                            	  endif
                            	endfor
                            	let new = new2
                            	let new2 = []
                              endwhile
                              return keys(did)
                            endf
                            
    1              0.000003 augroup SnipMateSource
    1              0.000014 	au SourceCmd *.snippet,*.snippets call s:source_snippet()
    1              0.000001 augroup END
                            
    1              0.000003 function! s:info_from_filename(file) abort
                            	let parts = split(fnamemodify(a:file, ':r'), '/')
                            	let snipidx = len(parts) - index(reverse(copy(parts)), 'snippets') - 1
                            	let rtp_prefix = join(parts[(snipidx -
                            				\ (parts[snipidx - 1] == 'after' ? 3 : 2)):snipidx - 1], '/')
                            	let trigger = get(parts, snipidx + 2, '')
                            	let desc = get(parts, snipidx + 3, get(g:snipMate, 'override', 0) ?
                            				\ '' : fnamemodify(a:file, ':t'))
                            	return [rtp_prefix, trigger, desc]
                            endfunction
                            
    1              0.000002 function! s:source_snippet() abort
                            	let file = expand('<afile>:p')
                            	let [rtp_prefix, trigger, desc] = s:info_from_filename(file)
                            	let new_snips = []
                            	if fnamemodify(file, ':e') == 'snippet'
                            		call add(new_snips, [trigger, desc, join(readfile(file), "\n"), 0,
                            					\ get(g:snipMate, 'snippet_version', 0)])
                            	else
                            		let [snippets, extends] = s:CachedSnips(file)
                            		let new_snips = deepcopy(snippets)
                            		call extend(s:lookup_state.extends, extends)
                            	endif
                            	for snip in new_snips
                            		if get(g:snipMate, 'override', 0)
                            			let snip[1] = join([s:lookup_state.scope, snip[1]])
                            		else
                            			let snip[1] = join([s:lookup_state.scope, rtp_prefix,
                            						\ empty(snip[1]) ? desc : snip[1]])
                            		endif
                            	endfor
                            	call extend(s:lookup_state.snips, new_snips)
                            endfunction
                            
    1              0.000002 function! s:CachedSnips(file) abort
                            	let mtime = getftime(a:file)
                            	if has_key(s:cache, a:file) && s:cache[a:file].mtime >= mtime
                            		return s:cache[a:file].contents
                            	endif
                            	let s:cache[a:file] = {}
                            	let s:cache[a:file].mtime = mtime
                            	let s:cache[a:file].contents = snipMate#ReadSnippetsFile(a:file)
                            	return s:cache[a:file].contents
                            endfunction
                            
    1              0.000002 function! s:snippet_filenames(scope, trigger) abort
                            	let mid = ['', '_*', '/*']
                            	let mid += map(copy(mid), "'/' . a:trigger . '*' . v:val")
                            	call map(mid, "'snippets/' . a:scope . v:val . '.snippet'")
                            	return map(mid[:2], 'v:val . "s"') + mid[3:]
                            endfunction
                            
    1              0.000003 function! snipMate#SetByPath(dict, trigger, path, snippet, bang, snipversion) abort
                            	let d = a:dict
                            	if a:bang == 2
                            		unlet! d[a:trigger]
                            		return
                            	elseif !has_key(d, a:trigger) || a:bang == 1
                            		let d[a:trigger] = {}
                            	endif
                            	let d[a:trigger][a:path] = [a:snippet, a:snipversion]
                            endfunction
                            
    1              0.000005 if v:version < 704 || has('win32')
                            	function! s:Glob(path, expr)
                            		let res = []
                            		for p in split(a:path, ',')
                            			let h = split(fnamemodify(a:expr, ':h'), '/')[0]
                            			if isdirectory(p . '/' . h)
                            				call extend(res, split(glob(p . '/' . a:expr), "\n"))
                            			endif
                            		endfor
                            		return filter(res, 'filereadable(v:val)')
                            	endfunction
    1              0.000002 else
    1              0.000002 	function! s:Glob(path, expr)
                            		return split(globpath(a:path, a:expr), "\n")
                            	endfunction
    1              0.000001 endif
                            
                            " default triggers based on paths
    1              0.000002 function! snipMate#DefaultPool(scopes, trigger, result) abort
                            	let scopes = s:AddScopeAliases(a:scopes)
                            	let scopes_done = []
                            	let s:lookup_state = {}
                            	let s:lookup_state.snips = []
                            
                            	while !empty(scopes)
                            		let scope = remove(scopes, 0)
                            		let s:lookup_state.scope = scope
                            		let s:lookup_state.extends = []
                            
                            		for expr in s:snippet_filenames(scope, escape(a:trigger, "*[]?{}`'$|#%"))
                            			for path in s:snippet_dirs()
                            				for file in s:Glob(path, expr)
                            					source `=file`
                            				endfor
                            			endfor
                            		endfor
                            
                            		call add(scopes_done, scope)
                            		call extend(scopes, s:lookup_state.extends)
                            		call filter(scopes, 'index(scopes_done, v:val) == -1')
                            	endwhile
                            
                            	for [trigger, desc, contents, bang, snipversion] in s:lookup_state.snips
                            		if trigger =~ '\V\^' . escape(a:trigger, '\')
                            			call snipMate#SetByPath(a:result, trigger, desc, contents, bang, snipversion)
                            		endif
                            	endfor
                            endfunction
                            
                            " return a dict of snippets found in runtimepath matching trigger
                            " scopes: list of scopes. usually this is the filetype. eg ['c','cpp']
                            " trigger may contain glob patterns. Thus use '*' to get all triggers
                            "
    1              0.000002 fun! snipMate#GetSnippets(scopes, trigger) abort
                            	let result = {}
                            
                            	for F in values(g:snipMateSources)
                            	  call funcref#Call(F, [a:scopes, a:trigger, result])
                            	endfor
                            	return result
                            endf
                            
    1              0.000002 function! s:snippet_dirs() abort
                            	return get(g:snipMate, 'snippet_dirs', split(&rtp, ','))
                            endfunction
                            
    1              0.000001 function! snipMate#OpenSnippetFiles() abort
                            	let files = []
                            	let scopes_done = []
                            	let exists = []
                            	let notexists = []
                            	for scope in s:AddScopeAliases(snipMate#ScopesByFile())
                            		let files += s:snippet_filenames(scope, '')
                            	endfor
                            	call filter(files, "v:val !~# '\\*'")
                            	for path in s:snippet_dirs()
                            		let fullpaths = map(copy(files), 'printf("%s/%s", path, v:val)')
                            		let exists += filter(copy(fullpaths), 'filereadable(v:val)')
                            		let notexists += map(filter(copy(fullpaths),
                            					\ 'v:val =~# "\.snippets" && !filereadable(v:val)'),
                            					\       '"does not exist: " . v:val')
                            	endfor
                            	let all = exists + notexists
                            	let select = tlib#input#List('mi', 'select files to be opened in splits', all)
                            	for idx in select
                            		exec 'sp' all[idx - 1]
                            	endfor
                            endfunction
                            
    1              0.000002 fun! snipMate#ScopesByFile() abort
                            	" duplicates are removed in AddScopeAliases
                            	return filter(funcref#Call(g:snipMate.get_scopes), "v:val != ''")
                            endf
                            
                            " used by both: completion and insert snippet
    1              0.000002 fun! snipMate#GetSnippetsForWordBelowCursor(word, exact) abort
                            	" Split non-word characters into their own piece
                            	" so 'foo.bar..baz' becomes ['foo', '.', 'bar', '.', '.', 'baz']
                            	" First split just after a \W and then split each resultant string just
                            	" before a \W
                            	let parts = filter(tlib#list#Flatten(
                            				\ map(split(a:word, '\W\zs'), 'split(v:val, "\\ze\\W")')),
                            				\ '!empty(v:val)')
                            	" Only look at the last few possibilities. Too many can be slow.
                            	if len(parts) > 5
                            		let parts = parts[-5:]
                            	endif
                            	let lookups = [a:word]
                            	let lookup = ''
                            	for w in reverse(parts)
                            		let lookup = w . lookup
                            		if index(lookups, lookup) == -1
                            			call add(lookups, lookup)
                            		endif
                            	endfor
                            
                            	" Remove empty lookup entries, but only if there are other nonempty lookups
                            	if len(lookups) > 1
                            		call filter(lookups, 'v:val != ""')
                            	endif
                            
                            	let matching_snippets = []
                            	let snippet = ''
                            	" prefer longest word
                            	for word in lookups
                            		let g:snipMate.word = word
                            		for [k,snippetD] in items(funcref#Call(g:snipMate['get_snippets'], [snipMate#ScopesByFile(), word]))
                            			" hack: require exact match
                            			if a:exact && k !=# word
                            				continue
                            			endif
                            			call add(matching_snippets, [k, snippetD])
                            			if a:exact
                            				break
                            			endif
                            		endfor
                            	endfor
                            	return matching_snippets
                            endf
                            
                            " snippets: dict containing snippets by name
                            " usually this is just {'default' : snippet_contents }
    1              0.000003 fun! s:ChooseSnippet(snippets) abort
                            	let snippet = []
                            	let keys = keys(a:snippets)
                            	let i = 1
                            	for snip in keys
                            		let snippet += [i.'. '.snip]
                            		let i += 1
                            	endfor
                            	if len(snippet) == 1 || get(g:snipMate, 'always_choose_first', 0) == 1
                            		" there's only a single snippet, choose it
                            		let idx = 0
                            	else
                            		let idx = tlib#input#List('si','select snippet by name',snippet) -1
                            		if idx == -1
                            			return ''
                            		endif
                            	endif
                            	" if a:snippets[..] is a String Call returns it
                            	" If it's a function or a function string the result is returned
                            	return funcref#Call(a:snippets[keys(a:snippets)[idx]])
                            endf
                            
    1              0.000001 fun! snipMate#WordBelowCursor() abort
                            	return matchstr(getline('.'), '\S\+\%' . col('.') . 'c')
                            endf
                            
    1              0.000003 fun! snipMate#GetSnippetsForWordBelowCursorForComplete(word) abort
                            	let matches = snipMate#GetSnippetsForWordBelowCursor(a:word, 0)
                            	let snippets = []
                            	for [trigger, dict] in matches
                            		if get(g:snipMate, 'description_in_completion', 0)
                            			call extend(snippets, map(keys(dict),
                            						\ '{ "word" : trigger, "menu" : v:val, "dup" : 1 }'))
                            		else
                            			call add(snippets, { "word" : trigger })
                            		endif
                            	endfor
                            	return filter(snippets,
                            				\ 'v:val.word =~# "\\V\\^' . escape(a:word, '"\') . '"')
                            endf
                            
    1              0.000002 fun! snipMate#CanBeTriggered() abort
                            	let word    = snipMate#WordBelowCursor()
                            	let matches = snipMate#GetSnippetsForWordBelowCursorForComplete(word)
                            	return len(matches) > 0
                            endf
                            
    1              0.000002 fun! snipMate#ShowAvailableSnips() abort
                            	let col     = col('.')
                            	let word    = snipMate#WordBelowCursor()
                            	let matches = snipMate#GetSnippetsForWordBelowCursorForComplete(word)
                            
                            	" Pretty hacky, but really can't have the tab swallowed!
                            	if len(matches) == 0
                            		call feedkeys(g:snipMate['no_match_completion_feedkeys_chars'], 'n')
                            		return ""
                            	endif
                            
                            	call complete(col - len(word), sort(matches))
                            	return ''
                            endf
                            
                            " Pass an argument to force snippet expansion instead of triggering or jumping
    1              0.000002 function! snipMate#TriggerSnippet(...) abort
                            	if exists('g:SuperTabMappingForward')
                            		if g:SuperTabMappingForward == "<tab>"
                            			let SuperTabPlug = maparg('<Plug>SuperTabForward', 'i')
                            			if SuperTabPlug == ""
                            				let SuperTabKey = "\<c-n>"
                            			else
                            				exec "let SuperTabKey = \"" . escape(SuperTabPlug, '<') . "\""
                            			endif
                            		elseif g:SuperTabMappingBackward == "<tab>"
                            			let SuperTabPlug = maparg('<Plug>SuperTabBackward', 'i')
                            			if SuperTabPlug == ""
                            				let SuperTabKey = "\<c-p>"
                            			else
                            				exec "let SuperTabKey = \"" . escape(SuperTabPlug, '<') . "\""
                            			endif
                            		endif
                            	endif
                            
                            	if pumvisible() " Update snippet if completion is used, or deal with supertab
                            		if exists('SuperTabKey')
                            			call feedkeys(SuperTabKey) | return ''
                            		endif
                            		call feedkeys("\<esc>a", 'n') " Close completion menu
                            		call feedkeys("\<tab>") | return ''
                            	endif
                            
                            	if exists('b:snip_state') && a:0 == 0 " Jump only if no arguments
                            		let jump = b:snip_state.jump_stop(0)
                            		if type(jump) == 1 " returned a string
                            			return jump
                            		endif
                            	endif
                            
                            	let word = matchstr(getline('.'), '\S\+\%'.col('.').'c')
                            	let list = snipMate#GetSnippetsForWordBelowCursor(word, 1)
                            	if empty(list)
                            		let snippet = ''
                            	else
                            		let [trigger, snippetD] = list[0]
                            		let snippet = s:ChooseSnippet(snippetD)
                            		" Before expanding snippet, create new undo point |i_CTRL-G|
                            		let &undolevels = &undolevels
                            		let col = col('.') - len(trigger)
                            		sil exe 's/\V'.escape(trigger, '/\.').'\%#//'
                            		return snipMate#expandSnip(snippet[0], snippet[1], col)
                            	endif
                            
                            	" should allow other plugins to register hooks instead (duplicate code)
                            	if exists('SuperTabKey')
                            		call feedkeys(SuperTabKey)
                            		return ''
                            	endif
                            	return word == ''
                            	  \ ? "\<tab>"
                            	  \ : "\<c-r>=snipMate#ShowAvailableSnips()\<cr>"
                            endfunction
                            
    1              0.000002 fun! snipMate#BackwardsSnippet() abort
                            	if exists('b:snip_state') | return b:snip_state.jump_stop(1) | endif
                            
                            	if exists('g:SuperTabMappingForward')
                            		if g:SuperTabMappingForward == "<s-tab>"
                            			let SuperTabPlug = maparg('<Plug>SuperTabForward', 'i')
                            			if SuperTabPlug == ""
                            				let SuperTabKey = "\<c-n>"
                            			else
                            				exec "let SuperTabKey = \"" . escape(SuperTabPlug, '<') . "\""
                            			endif
                            		elseif g:SuperTabMappingBackward == "<s-tab>"
                            			let SuperTabPlug = maparg('<Plug>SuperTabBackward', 'i')
                            			if SuperTabPlug == ""
                            				let SuperTabKey = "\<c-p>"
                            			else
                            				exec "let SuperTabKey = \"" . escape(SuperTabPlug, '<') . "\""
                            			endif
                            		endif
                            	endif
                            	" should allow other plugins to register hooks instead (duplicate code)
                            	if exists('SuperTabKey')
                            		call feedkeys(SuperTabKey)
                            		return ''
                            	endif
                            	return "\<s-tab>"
                            endf
                            
                            " vim:noet:sw=4:ts=4:ft=vim

SCRIPT  /Users/brettmz-admin/dev_trees/myvim/bundle/tlib_vim/autoload/tlib/input.vim
Sourced 1 time
Total time:   0.002700
 Self time:   0.002700

count  total (s)   self (s)
                            " @Author:      Tom Link (micathom AT gmail com?subject=[vim])
                            " @Website:     http://www.vim.org/account/profile.php?user_id=4037
                            " @License:     GPL (see http://www.gnu.org/licenses/gpl.txt)
                            " @Revision:    1428
                            
                            " :filedoc:
                            " Input-related, select from a list etc.
                            
                            " If a list is bigger than this value, don't try to be smart when 
                            " selecting an item. Be slightly faster instead.
                            " See |tlib#input#List()|.
    1              0.000082 TLet g:tlib#input#sortprefs_threshold = 200
                            
                            
                            " If a list contains more items, |tlib#input#List()| does not perform an 
                            " incremental "live search" but uses |input()| to query the user for a 
                            " filter. This is useful on slower machines or with very long lists.
    1              0.000055 TLet g:tlib#input#livesearch_threshold = 1000
                            
                            
                            " Determine how |tlib#input#List()| and related functions work.
                            " Can be "glob", "cnf", "cnfd", "seq", or "fuzzy". See:
                            "   glob ... Like cnf but "*" and "?" (see |g:tlib#Filter_glob#seq|, 
                            "       |g:tlib#Filter_glob#char|) are interpreted as glob-like 
                            "       |wildcards| (this is the default method)
                            "     - Examples:
                            "         - "f*o" matches "fo", "fxo", and "fxxxoo", but doesn't match 
                            "           "far".
                            "     - Otherwise it is a derivate of the cnf method (see below).
                            "     - See also |tlib#Filter_glob#New()|.
                            "   cnfd ... Like cnf but "." is interpreted as a wildcard, i.e. it is 
                            "            expanded to "\.\{-}"
                            "     - A period character (".") acts as a wildcard as if ".\{-}" (see 
                            "       |/\{-|) were entered.
                            "     - Examples:
                            "         - "f.o" matches "fo", "fxo", and "fxxxoo", but doesn't match 
                            "           "far".
                            "     - Otherwise it is a derivate of the cnf method (see below).
                            "     - See also |tlib#Filter_cnfd#New()|.
                            "   cnf .... Match substrings
                            "     - A blank creates an AND conjunction, i.e. the next pattern has to 
                            "       match too.
                            "     - A pipe character ("|") creates an OR conjunction, either this or 
                            "       the next next pattern has to match.
                            "     - Patterns are very 'nomagic' |regexp| with a |\V| prefix.
                            "     - A pattern starting with "-" makes the filter exclude items 
                            "       matching that pattern.
                            "     - Examples:
                            "         - "foo bar" matches items that contain the strings "foo" AND 
                            "           "bar".
                            "         - "foo|bar boo|far" matches items that contain either ("foo" OR 
                            "           "bar") AND ("boo" OR "far").
                            "     - See also |tlib#Filter_cnf#New()|.
                            "   seq .... Match sequences of characters
                            "     - |tlib#Filter_seq#New()|
                            "   fuzzy .. Match fuzzy character sequences
                            "     - |tlib#Filter_fuzzy#New()|
    1              0.000048 TLet g:tlib#input#filter_mode = 'glob'
                            
                            
                            " The highlight group to use for showing matches in the input list 
                            " window.
                            " See |tlib#input#List()|.
    1              0.000044 TLet g:tlib#input#higroup = 'IncSearch'
                            
                            " When 1, automatically select the last remaining item only if the list 
                            " had only one item to begin with.
                            " When 2, automatically select a last remaining item after applying 
                            " any filters.
                            " See |tlib#input#List()|.
    1              0.000042 TLet g:tlib_pick_last_item = 1
                            
                            
                            " :doc:
                            " Keys for |tlib#input#List|~
                            
    1              0.000071 TLet g:tlib#input#and = ' '
    1              0.000040 TLet g:tlib#input#or  = '|'
    1              0.000039 TLet g:tlib#input#not = '-'
                            
                            " When editing a list with |tlib#input#List|, typing these numeric chars 
                            " (as returned by getchar()) will select an item based on its index, not 
                            " based on its name. I.e. in the default setting, typing a "4" will 
                            " select the fourth item, not the item called "4".
                            " In order to make keys 0-9 filter the items in the list and make 
                            " <m-[0-9]> select an item by its index, remove the keys 48 to 57 from 
                            " this dictionary.
                            " Format: [KEY] = BASE ... the number is calculated as KEY - BASE.
                            " :nodefault:
    1              0.000095 TLet g:tlib#input#numeric_chars = {
                                        \ 176: 176,
                                        \ 177: 176,
                                        \ 178: 176,
                                        \ 179: 176,
                                        \ 180: 176,
                                        \ 181: 176,
                                        \ 182: 176,
                                        \ 183: 176,
                                        \ 184: 176,
                                        \ 185: 176,
                                        \}
                                        " \ 48: 48,
                                        " \ 49: 48,
                                        " \ 50: 48,
                                        " \ 51: 48,
                                        " \ 52: 48,
                                        " \ 53: 48,
                                        " \ 54: 48,
                                        " \ 55: 48,
                                        " \ 56: 48,
                                        " \ 57: 48,
                            
                            
                            " :nodefault:
                            " The default key bindings for single-item-select list views.
                            "
                            " This variable is best customized via the variable 
                            " g:tlib_extend_keyagents_InputList_s. If you want to use <c-j>, <c-k> 
                            " to move the cursor up and down, add these two lines to your |vimrc| 
                            " file:
                            "
                            "   let g:tlib_extend_keyagents_InputList_s = {
                            "       \ 10: 'tlib#agent#Down',
                            "       \ 11: 'tlib#agent#Up'
                            "       \ }
    1              0.000206 TLet g:tlib#input#keyagents_InputList_s = {
                                        \ "\<PageUp>":   'tlib#agent#PageUp',
                                        \ "\<PageDown>": 'tlib#agent#PageDown',
                                        \ "\<Home>":     'tlib#agent#Home',
                                        \ "\<End>":      'tlib#agent#End',
                                        \ "\<Up>":       'tlib#agent#Up',
                                        \ "\<Down>":     'tlib#agent#Down',
                                        \ 9:             'tlib#agent#Complete',
                                        \ "\<c-Up>":     'tlib#agent#UpN',
                                        \ "\<c-Down>":   'tlib#agent#DownN',
                                        \ "\<Left>":     'tlib#agent#ShiftLeft',
                                        \ "\<Right>":    'tlib#agent#ShiftRight',
                                        \ 18:            'tlib#agent#Reset',
                                        \ 242:           'tlib#agent#Reset',
                                        \ 17:            'tlib#agent#Input',
                                        \ 241:           'tlib#agent#Input',
                                        \ 27:            'tlib#agent#Exit',
                                        \ 26:            'tlib#agent#Suspend',
                                        \ 250:           'tlib#agent#Suspend',
                                        \ 15:            'tlib#agent#SuspendToParentWindow',  
                                        \ "\<F1>":       'tlib#agent#Help',
                                        \ "\<F10>":      'tlib#agent#ExecAgentByName',
                                        \ "\<S-Esc>":    'tlib#agent#ExecAgentByName',
                                        \ "\<bs>":       'tlib#agent#ReduceFilter',
                                        \ "\<del>":      'tlib#agent#ReduceFilter',
                                        \ "\<c-bs>":     'tlib#agent#PopFilter',
                                        \ "\<m-bs>":     'tlib#agent#PopFilter',
                                        \ "\<c-del>":    'tlib#agent#PopFilter',
                                        \ "\<m-del>":    'tlib#agent#PopFilter',
                                        \ "\<s-space>":  'tlib#agent#Wildcard',
                                        \ 191:           'tlib#agent#Debug',
                                        \ char2nr(g:tlib#input#or):  'tlib#agent#OR',
                                        \ char2nr(g:tlib#input#and): 'tlib#agent#AND',
                                        \ }
                                        " \ 63:            'tlib#agent#Help',
                            
    1              0.000006 if exists('g:tlib_extend_keyagents_InputList_s')
                                let g:tlib#input#keyagents_InputList_s = extend(g:tlib#input#keyagents_InputList_s, g:tlib_extend_keyagents_InputList_s)
    1              0.000001 endif
                            
                            
                            " :nodefault:
    1              0.000070 TLet g:tlib#input#keyagents_InputList_m = {
                                        \ 35:          'tlib#agent#Select',
                                        \ "\<s-up>":   'tlib#agent#SelectUp',
                                        \ "\<s-down>": 'tlib#agent#SelectDown',
                                        \ 1:           'tlib#agent#SelectAll',
                                        \ 225:         'tlib#agent#SelectAll',
                                        \ "\<F9>":     'tlib#agent#ToggleRestrictView',
                                        \ }
                            " "\<c-space>": 'tlib#agent#Select'
                            
    1              0.000005 if exists('g:tlib_extend_keyagents_InputList_m')
                                let g:tlib#input#keyagents_InputList_m = extend(g:tlib#input#keyagents_InputList_m, g:tlib_extend_keyagents_InputList_m)
    1              0.000001 endif
                            
                            
                            
                            " :nodefault:
    1              0.000124 TLet g:tlib#input#handlers_EditList = [
                                        \ {'key': 5,  'agent': 'tlib#agent#EditItem',    'key_name': '<c-e>', 'help': 'Edit item'},
                                        \ {'key': 4,  'agent': 'tlib#agent#DeleteItems', 'key_name': '<c-d>', 'help': 'Delete item(s)'},
                                        \ {'key': 14, 'agent': 'tlib#agent#NewItem',     'key_name': '<c-n>', 'help': 'New item'},
                                        \ {'key': 24, 'agent': 'tlib#agent#Cut',         'key_name': '<c-x>', 'help': 'Cut item(s)'},
                                        \ {'key':  3, 'agent': 'tlib#agent#Copy',        'key_name': '<c-c>', 'help': 'Copy item(s)'},
                                        \ {'key': 22, 'agent': 'tlib#agent#Paste',       'key_name': '<c-v>', 'help': 'Paste item(s)'},
                                        \ {'pick_last_item': 0},
                                        \ {'return_agent': 'tlib#agent#EditReturnValue'},
                                        \ {'help_extra': [
                                        \      'Submit changes by pressing ENTER or <c-s> or <c-w><cr>',
                                        \      'Cancel editing by pressing <c-w>c'
                                        \ ]},
                                        \ ]
                            
                            
                            " A dictionary KEY => {'agent': AGENT, 'key_name': KEY_NAME} to 
                            " customize keyboard shortcuts in the list view.
    1              0.000032 TLet g:tlib#input#user_shortcuts = {}
                            
                            
                            " If true, define a popup menu for |tlib#input#List()| and related 
                            " functions.
    1              0.000052 TLet g:tlib#input#use_popup = has('menu') && (has('gui_gtk') || has('gui_gtk2') || has('gui_win32'))
                            
                            
                            " How to format filenames:
                            "     l ... Show basenames on the left side, separated from the 
                            "           directory names
                            "     r ... Show basenames on the right side
    1              0.000030 TLet g:tlib#input#format_filename = 'l'
                            
                            
                            " If g:tlib#input#format_filename == 'r', how much space should be kept 
                            " free on the right side.
    1              0.000030 TLet g:tlib#input#filename_padding_r = '&co / 10'
                            
                            
                            " If g:tlib#input#format_filename == 'l', an expression that 
                            " |eval()|uates to the maximum display width of filenames.
    1              0.000030 TLet g:tlib#input#filename_max_width = '&co / 2'
                            
                            
                            " Functions related to tlib#input#List(type, ...) "{{{2
                            
                            " :def: function! tlib#input#List(type. ?query='', ?list=[], ?handlers=[], ?default="", ?timeout=0)
                            " Select a single or multiple items from a list. Return either the list 
                            " of selected elements or its indexes.
                            "
                            " By default, typing numbers will select an item by its index. See 
                            " |g:tlib#input#numeric_chars| to find out how to change this.
                            "
                            " The item is automatically selected if the numbers typed equals the 
                            " number of digits of the list length. I.e. if a list contains 20 items, 
                            " typing 1 will first highlight item 1 but it won't select/use it 
                            " because 1 is an ambiguous input in this context. If you press enter, 
                            " the first item will be selected. If you press another digit (e.g. 0), 
                            " item 10 will be selected. Another way to select item 1 would be to 
                            " type 01. If the list contains only 9 items, typing 1 would select the 
                            " first item right away.
                            "
                            " type can be:
                            "     s  ... Return one selected element
                            "     si ... Return the index of the selected element
                            "     m  ... Return a list of selected elements
                            "     mi ... Return a list of indexes
                            "
                            " Several pattern matching styles are supported. See 
                            " |g:tlib#input#filter_mode|.
                            "
                            " Users can type <Tab> to complete the current filter with the longest 
                            " match.
                            "
                            " EXAMPLES: >
                            "   echo tlib#input#List('s', 'Select one item', [100,200,300])
                            "   echo tlib#input#List('si', 'Select one item', [100,200,300])
                            "   echo tlib#input#List('m', 'Select one or more item(s)', [100,200,300])
                            "   echo tlib#input#List('mi', 'Select one or more item(s)', [100,200,300])
                            "
                            " See ../samples/tlib/input/tlib_input_list.vim (move the cursor over 
                            " the filename and press gf) for a more elaborated example.
    1              0.000006 function! tlib#input#List(type, ...) "{{{3
                                exec tlib#arg#Let([
                                    \ ['query', ''],
                                    \ ['list', []],
                                    \ ['handlers', []],
                                    \ ['rv', ''],
                                    \ ['timeout', 0],
                                    \ ])
                                " let handlers = a:0 >= 1 ? a:1 : []
                                " let rv       = a:0 >= 2 ? a:2 : ''
                                " let timeout  = a:0 >= 3 ? a:3 : 0
                                " let backchar = ["\<bs>", "\<del>"]
                            
                                if a:type =~ '^resume'
                                    let world = b:tlib_{matchstr(a:type, ' \zs.\+')}
                                else
                                    let world = tlib#World#New({
                                                \ 'type': a:type,
                                                \ 'base': list,
                                                \ 'query': query,
                                                \ 'timeout': timeout,
                                                \ 'rv': rv,
                                                \ 'handlers': handlers,
                                                \ })
                                    let scratch_name     = tlib#list#Find(handlers, 'has_key(v:val, "scratch_name")', '', 'v:val.scratch_name')
                                    if !empty(scratch_name)
                                        let world.scratch = scratch_name
                                    endif
                                    let world.scratch_vertical = tlib#list#Find(handlers, 'has_key(v:val, "scratch_vertical")', 0, 'v:val.scratch_vertical')
                                    call world.Set_display_format(tlib#list#Find(handlers, 'has_key(v:val, "display_format")', '', 'v:val.display_format'))
                                    let world.initial_index    = tlib#list#Find(handlers, 'has_key(v:val, "initial_index")', 1, 'v:val.initial_index')
                                    let world.index_table      = tlib#list#Find(handlers, 'has_key(v:val, "index_table")', [], 'v:val.index_table')
                                    let world.state_handlers   = filter(copy(handlers),   'has_key(v:val, "state")')
                                    let world.post_handlers    = filter(copy(handlers),   'has_key(v:val, "postprocess")')
                                    let world.filter_format    = tlib#list#Find(handlers, 'has_key(v:val, "filter_format")', '', 'v:val.filter_format')
                                    let world.return_agent     = tlib#list#Find(handlers, 'has_key(v:val, "return_agent")', '', 'v:val.return_agent')
                                    let world.help_extra       = tlib#list#Find(handlers, 'has_key(v:val, "help_extra")', '', 'v:val.help_extra')
                                    let world.resize           = tlib#list#Find(handlers, 'has_key(v:val, "resize")', '', 'v:val.resize')
                                    let world.show_empty       = tlib#list#Find(handlers, 'has_key(v:val, "show_empty")', 0, 'v:val.show_empty')
                                    let world.pick_last_item   = tlib#list#Find(handlers, 'has_key(v:val, "pick_last_item")', 
                                                \ tlib#var#Get('tlib_pick_last_item', 'bg'), 'v:val.pick_last_item')
                                    let world.numeric_chars    = tlib#list#Find(handlers, 'has_key(v:val, "numeric_chars")', 
                                                \ g:tlib#input#numeric_chars, 'v:val.numeric_chars')
                                    let world.key_handlers     = filter(copy(handlers), 'has_key(v:val, "key")')
                                    let filter                 = tlib#list#Find(handlers, 'has_key(v:val, "filter")', '', 'v:val.filter')
                                    if !empty(filter)
                                        " let world.initial_filter = [[''], [filter]]
                                        " let world.initial_filter = [[filter]]
                                        Tlibtrace 'tlib', world.initial_filter, filter
                                        call world.SetInitialFilter(filter)
                                    endif
                                endif
                                return tlib#input#ListW(world)
                            endf
                            
                            
                            " A wrapper for |tlib#input#ListW()| that builds |tlib#World#New| from 
                            " dict.
    1              0.000003 function! tlib#input#ListD(dict) "{{{3
                                return tlib#input#ListW(tlib#World#New(a:dict))
                            endf
                            
                            
                            " :def: function! tlib#input#ListW(world, ?command='')
                            " The second argument (command) is meant for internal use only.
                            " The same as |tlib#input#List| but the arguments are packed into world 
                            " (an instance of tlib#World as returned by |tlib#World#New|).
    1              0.000002 function! tlib#input#ListW(world, ...) "{{{3
                                TVarArg 'cmd'
                                let time0 = str2float(reltimestr(reltime()))
                                Tlibtrace 'tlib', time0
                                let world = a:world
                                if world.pick_last_item >= 1 && stridx(world.type, 'e') == -1 && len(world.base) <= 1
                                    call world.CloseScratch(1)
                                    let rv = get(world.base, 0, world.rv)
                                    if stridx(world.type, 'm') != -1
                                        return [rv]
                                    else
                                        return rv
                                    endif
                                endif
                                call s:Init(world, cmd)
                                Tlibtrace 'tlib', world.state, world.sticky, world.initial_index
                                " let statusline  = &l:statusline
                                " let laststatus  = &laststatus
                                let showmode = &showmode
                                set noshowmode
                                let lastsearch  = @/
                                let scrolloff = &l:scrolloff
                                let &l:scrolloff = 0
                                let @/ = ''
                                let dlist = []
                                let post_keys = ''
                                " let &laststatus = 2
                            
                                try
                                    while !empty(world.state) && world.state !~ '^exit' && (world.show_empty || !empty(world.base))
                                        let post_keys = ''
                                        Tlibtrace 'tlib', 'while', world.state
                                        let time01 = str2float(reltimestr(reltime()))
                                        Tlibtrace 'tlib', time01, time01 - time0
                                        try
                                            let world = s:RunStateHandlers(world)
                            
                                            let time02 = str2float(reltimestr(reltime()))
                                            Tlibtrace 'tlib', time02, time02 - time0
                                            if world.state =~ '\<reset\>'
                                                call world.Reset()
                                                continue
                                            endif
                            
                                            call s:SetOffset(world)
                            
                                            let time02 = str2float(reltimestr(reltime()))
                                            Tlibtrace 'tlib', time02, time02 - time0
                                            Tlibtrace 'tlib', world.state
                                            if world.state == 'scroll'
                                                let world.prefidx = world.offset
                                                let world.state = 'redisplay'
                                            endif
                            
                                            if world.state =~ '\<sticky\>'
                                                let world.sticky = 1
                                            endif
                            
                                            Tlibtrace 'tlib', world.filter
                                            Tlibtrace 'tlib', world.sticky
                                            if world.state =~ '\<picked\>'
                                                Tlibtrace 'tlib', world.rv
                                                throw 'picked'
                                            elseif world.state =~ '\<pick\>'
                                                let world.rv = world.CurrentItem()
                                                Tlibtrace 'tlib', world.rv
                                                throw 'picked'
                                            elseif world.state =~ 'display'
                                                if world.state =~ '^display'
                                                    let time03 = str2float(reltimestr(reltime()))
                                                    Tlibtrace 'tlib', time03, time03 - time0
                                                    if world.IsValidFilter()
                                                        let time1 = str2float(reltimestr(reltime()))
                                                        Tlibtrace 'tlib', time1, time1 - time0
                                                        call world.BuildTableList()
                                                        let time2 = str2float(reltimestr(reltime()))
                                                        Tlibtrace 'tlib', time2, time2 - time0
                                                        let world.llen = len(world.list)
                                                        if empty(world.index_table)
                                                            let dindex = range(1, world.llen)
                                                            let world.index_width = len(world.llen)
                                                        else
                                                            let dindex = world.index_table
                                                            let world.index_width = len(max(dindex))
                                                        endif
                                                        let time3 = str2float(reltimestr(reltime()))
                                                        Tlibtrace 'tlib', time3, time3 - time0
                                                        if world.llen == 0 && !world.show_empty
                                                            call world.ReduceFilter()
                                                            let world.offset = 1
                                                            continue
                                                        else
                                                            if world.llen == 1
                                                                let world.last_item = world.list[0]
                                                                if world.pick_last_item >= 2
                                                                    " echom 'Pick last item: '. world.list[0]
                                                                    let world.prefidx = '1'
                                                                    throw 'pick'
                                                                endif
                                                            else
                                                                let world.last_item = ''
                                                            endif
                                                        endif
                                                        let time4 = str2float(reltimestr(reltime()))
                                                        Tlibtrace 'tlib', time4, time4 - time0
                                                        Tlibtrace 'tlib', world.idx, world.llen, world.state
                                                        if world.state == 'display'
                                                            if world.idx == '' && world.llen < g:tlib#input#sortprefs_threshold && !world.FilterIsEmpty()
                                                                call world.SetPrefIdx()
                                                            else
                                                                let world.prefidx = world.idx == '' ? world.initial_index : world.idx
                                                            endif
                                                            if world.prefidx > world.llen
                                                                let world.prefidx = world.llen
                                                            elseif world.prefidx < 1
                                                                let world.prefidx = 1
                                                            endif
                                                        endif
                                                        let time5 = str2float(reltimestr(reltime()))
                                                        Tlibtrace 'tlib', time5, time5 - time0
                                                        Tlibtrace 'tlib', world.initial_index, world.prefidx
                                                        Tlibtrace 'tlib', len(world.list)
                                                        let dlist = world.DisplayFormat(world.list)
                                                        Tlibtrace 'tlib', world.prefidx
                                                        let time6 = str2float(reltimestr(reltime()))
                                                        Tlibtrace 'tlib', time6, time6 - time0
                                                        if world.offset_horizontal > 0
                                                            call map(dlist, 'tlib#string#Strcharpart(v:val, world.offset_horizontal)')
                                                        endif
                                                        let time7 = str2float(reltimestr(reltime()))
                                                        Tlibtrace 'tlib', time7, time7 - time0
                                                        let dlist = map(range(0, world.llen - 1), 'printf("%0'. world.index_width .'d", dindex[v:val]) .": ". dlist[v:val]')
                                                        let time8 = str2float(reltimestr(reltime()))
                                                        Tlibtrace 'tlib', time8, time8 - time0
                            
                                                    else
                            
                                                        let dlist = ['Malformed filter']
                            
                                                    endif
                                                else
                                                    if world.prefidx == 0
                                                        let world.prefidx = 1
                                                    endif
                                                endif
                                                Tlibtrace 'tlib', world.idx, world.prefidx
                            
                                                Tlibtrace 'tlib', world.prefidx, world.offset
                                                Tlibtrace 'tlib', world.initial_display, !tlib#char#IsAvailable()
                                                if world.state =~ '\<update\>' || world.initial_display || !tlib#char#IsAvailable()
                                                    call world.DisplayList(world.Query(), dlist)
                                                    call world.FollowCursor()
                                                    let world.initial_display = 0
                                                endif
                                                if world.state =~ '\<hibernate\>'
                                                    let world.state = 'suspend'
                                                else
                                                    let world.state = ''
                                                endif
                                            else
                                                " if world.state == 'scroll'
                                                "     let world.prefidx = world.offset
                                                " endif
                                                call world.DisplayList()
                                                if world.state == 'help' || world.state == 'printlines'
                                                    let world.state = 'display'
                                                else
                                                    let world.state = ''
                                                    call world.FollowCursor()
                                                endif
                                            endif
                                            " TAssert IsNotEmpty(world.scratch)
                                            let world.list_wid = tlib#win#GetID()
                                            let world.list_wnr = winnr()
                            
                                            Tlibtrace 'tlib', world.state, world.next_state
                                            if !empty(world.next_state)
                                                let world.state = world.next_state
                                                let world.next_state = ''
                                            endif
                            
                                            if world.state =~ '\<suspend\>'
                                                let world = tlib#agent#SuspendToParentWindow(world, world.rv)
                                                continue
                                            endif
                            
                                            if world.state =~ '\<eval\>'
                                                let query = matchstr(world.state, '\<eval\[\zs.\{-}\ze\]')
                                                if empty(query)
                                                    let query = 'Waiting for input ... Press ESC to continue'
                                                endif
                                                if has('gui_win32')
                                                    let exec_cmd = input(query, '')
                                                    Tlibtrace 'tlib', exec_cmd
                                                    if exec_cmd == ''
                                                        let world.state = 'redisplay'
                                                    else
                                                        exec exec_cmd
                                                    endif
                                                elseif has('gui_gtk') || has('gui_gtk2')
                                                    let c = s:GetModdedChar(world)
                                                    Tlibtrace 'tlib', c
                                                endif
                                            else
                                                Tlibtrace 'tlib', world.timeout
                                                let c = s:GetModdedChar(world)
                                                Tlibtrace 'tlib', c, has_key(world.key_map[world.key_mode],c)
                                            endif
                                            Tlibtrace 'tlib', c
                                            Tlibtrace 'tlib', world.next_agent, world.next_eval
                                            if !empty(world.next_agent)
                                                let nagent = world.next_agent
                                                let world.next_agent = ''
                                                " let world = call(nagent, [world, world.GetSelectedItems(world.CurrentItem())])
                                                " call s:CheckAgentReturnValue(nagent, world)
                                                let world = s:CallAgent({'agent': nagent}, world, world.GetSelectedItems(world.CurrentItem()))
                                            elseif !empty(world.next_eval)
                                                let selected = world.GetSelectedItems(world.CurrentItem())
                                                let neval = world.next_eval
                                                let world.next_eval = ''
                                                exec neval
                                                call s:CheckAgentReturnValue(neval, world)
                                            elseif world.state != ''
                                                " continue
                                            elseif has_key(world.key_map[world.key_mode], c)
                                                let sr = @/
                                                silent! let @/ = lastsearch
                                                Tlibtrace 'tlib', c, world.key_map[world.key_mode][c]
                                                " TLog "Agent: ". string(world.key_map[world.key_mode][c])
                                                let handler = world.key_map[world.key_mode][c]
                                                Tlibtrace 'tlib', handler
                                                let world = s:CallAgent(handler, world, world.GetSelectedItems(world.CurrentItem()))
                                                silent! let @/ = sr
                                                " continue
                                            elseif c == 13
                                                throw 'pick'
                                            elseif c == 27
                                                Tlibtrace 'tlib', c, world.key_mode
                                                if world.key_mode != 'default'
                                                    let world.key_mode = 'default'
                                                    let world.state = 'redisplay'
                                                else
                                                    let world.state = 'exit empty'
                                                endif
                                            elseif c == "\<LeftMouse>"
                                                if v:mouse_win == world.list_wnr
                                                    let world.prefidx = world.GetLineIdx(v:mouse_lnum)
                                                    " let world.offset  = world.prefidx
                                                    if empty(world.prefidx)
                                                        " call feedkeys(c, 't')
                                                        let c = s:GetModdedChar(world)
                                                        let world.state = 'help'
                                                        continue
                                                    endif
                                                    throw 'pick'
                                                else
                                                    let post_keys = v:mouse_lnum .'gg'. v:mouse_col .'|'. c
                                                    if world.allow_suspend
                                                        let world = tlib#agent#SuspendToParentWindow(world, world.rv)
                                                    else
                                                        let world.state = 'exit empty'
                                                    endif
                                                endif
                                            elseif c == "\<RightMouse>"
                                                if v:mouse_win == world.list_wnr
                                                    call s:BuildMenu(world)
                                                    let world.state = 'redisplay'
                                                    if s:PopupmenuExists() == 1
                                                        " if v:mouse_lnum != line('.')
                                                        " endif
                                                        let world.prefidx = world.GetLineIdx(v:mouse_lnum)
                                                        let world.next_state = 'eval[Waiting for popup menu ... Press ESC to continue]'
                                                        call world.DisplayList()
                                                        if line('w$') - v:mouse_lnum < 6
                                                            popup ]TLibInputListPopupMenu
                                                        else
                                                            popup! ]TLibInputListPopupMenu
                                                        endif
                                                    endif
                                                else
                                                    let post_keys = v:mouse_lnum .'gg'. v:mouse_col .'|'. c
                                                    if world.allow_suspend
                                                        let world = tlib#agent#SuspendToParentWindow(world, world.rv)
                                                    else
                                                        let world.state = 'exit empty'
                                                    endif
                                                endif
                                                Tlibtrace 'tlib', world.prefidx, world.state
                                            elseif has_key(world.key_map[world.key_mode], 'unknown_key')
                                                let agent = world.key_map[world.key_mode].unknown_key.agent
                                                " let world = call(agent, [world, c])
                                                " call s:CheckAgentReturnValue(agent, world)
                                                let world = s:CallAgent({'agent': agent}, world, c)
                                            elseif c >= 32
                                                let world.state = 'display'
                                                let numbase = get(world.numeric_chars, c, -99999)
                                                Tlibtrace 'tlib', numbase, world.numeric_chars, c
                                                if numbase != -99999
                                                    let world.idx .= (c - numbase)
                                                    if len(world.idx) == world.index_width
                                                        let world.prefidx = world.idx
                                                        Tlibtrace 'tlib', world.prefidx
                                                        throw 'pick'
                                                    endif
                                                else
                                                    let world.idx = ''
                                                    Tlibtrace 'tlib', world.filter
                                                    if world.llen > g:tlib#input#livesearch_threshold
                                                        let pattern = input('Filter: ', world.CleanFilter(world.filter[0][0]) . nr2char(c))
                                                        if empty(pattern)
                                                            let world.state = 'exit empty'
                                                        else
                                                            call world.SetFrontFilter(pattern)
                                                            echo
                                                        endif
                                                    elseif c == 124
                                                        call insert(world.filter[0], [])
                                                    else
                                                        call world.PushFrontFilter(c)
                                                    endif
                                                    " continue
                                                    if c == 45 && world.filter[0][0] == '-'
                                                        let world.state = 'redisplay'
                                                    end
                                                endif
                                            else
                                                let world.state = 'redisplay'
                                                " let world.state = 'continue'
                                            endif
                            
                                        catch /^picked$/
                                            call world.ClearAllMarks()
                                            call world.MarkCurrent(world.prefidx)
                                            let world.state = 'exit'
                            
                                        catch /^pick$/
                                            call world.ClearAllMarks()
                                            call world.MarkCurrent(world.prefidx)
                                            let world.state = ''
                            
                                        finally
                                            if world.state =~ '\<suspend\>'
                                                " if !world.allow_suspend
                                                "     echom "Cannot be suspended"
                                                "     let world.state = 'redisplay'
                                                " endif
                                            elseif !empty(world.list) && !empty(world.base)
                                                if empty(world.state)
                                                    let world.rv = world.CurrentItem()
                                                    Tlibtrace 'tlib', world.state, world.rv
                                                endif
                                                for handler in world.post_handlers
                                                    let state = get(handler, 'postprocess', '')
                                                    Tlibtrace 'tlib', handler
                                                    Tlibtrace 'tlib', state
                                                    Tlibtrace 'tlib', world.state
                                                    if state == world.state
                                                        let agent = handler.agent
                                                        let [world, world.rv] = call(agent, [world, world.rv])
                                                        Tlibtrace 'tlib', world.state, world.rv
                                                        call s:CheckAgentReturnValue(agent, world)
                                                    endif
                                                endfor
                                            endif
                                        endtry
                                    endwh
                            
                                    Tlibtrace 'tlib', world.state
                                    Tlibtrace 'tlib', len(world.list)
                                    Tlibtrace 'tlib', world.sel_idx
                                    Tlibtrace 'tlib', world.idx
                                    Tlibtrace 'tlib', world.prefidx
                                    Tlibtrace 'tlib', world.rv
                                    if world.state =~ '\<\(empty\|escape\)\>'
                                        let world.sticky = 0
                                    endif
                                    if world.state =~ '\<suspend\>'
                                        Tlibtrace 'tlib', world.prefidx
                                        " exec world.prefidx
                                        return
                                    elseif world.state =~ '\<empty\>'
                                        " TLog "empty"
                                        Tlibtrace 'tlib', world.type
                                        if stridx(world.type, 'm') != -1
                                            return []
                                        elseif stridx(world.type, 'i') != -1
                                            return 0
                                        else
                                            return ''
                                        endif
                                    elseif !empty(world.return_agent)
                                        Tlibtrace 'tlib', world.return_agent
                                        call world.CloseScratch(1)
                                        " TAssert IsNotEmpty(world.scratch)
                                        return call(world.return_agent, [world, world.GetSelectedItems(world.rv)])
                                    elseif stridx(world.type, 'w') != -1
                                        " TLog "return_world"
                                        return world
                                    elseif stridx(world.type, 'm') != -1
                                        " TLog "return_multi"
                                        return world.GetSelectedItems(world.rv)
                                    elseif stridx(world.type, 'i') != -1
                                        " TLog "return_index"
                                        if empty(world.index_table)
                                            return world.rv
                                        else
                                            return world.index_table[world.rv - 1]
                                        endif
                                    else
                                        " TLog "return_else"
                                        return world.rv
                                    endif
                            
                                finally
                                    call world.Leave()
                            
                                    " Tlibtrace 'tlib', statusline
                                    " let &l:statusline = statusline
                                    " let &laststatus = laststatus
                                    if &showmode != showmode
                                        let &showmode = showmode
                                    endif
                                    silent! let @/  = lastsearch
                                    let &l:scrolloff = scrolloff
                                    if s:PopupmenuExists() == 1
                                        silent! aunmenu ]TLibInputListPopupMenu
                                    endif
                            
                                    Tlibtrace 'tlib', world.state
                                    if world.state !~ '\<suspend\>'
                                        " redraw
                                        Tlibtrace 'tlib', world.sticky, bufnr("%")
                                        if world.sticky
                                            Tlibtrace 'tlib', world.bufnr
                                            if world.scratch_split > 0
                                                if bufwinnr(world.bufnr) == -1
                                                    call world.UseScratch()
                                                endif
                                                let world = tlib#agent#SuspendToParentWindow(world, world.GetSelectedItems(world.rv))
                                            endif
                                        else
                                            Tlibtrace 'tlib', world.state, world.win_id, world.bufnr
                                            if world.CloseScratch(1)
                                                Tlibtrace 'tlib', world.winview
                                                call tlib#win#SetLayout(world.winview)
                                            endif
                                        endif
                                    endif
                                    if world.state !~ '\<norestore\>'
                                        call world.RestoreWindow()
                                    endif
                                    " for i in range(0,5)
                                    "     call getchar(0)
                                    " endfor
                                    echo
                                    redraw!
                                    if !empty(post_keys)
                                        Tlibtrace 'tlib', post_keys
                                        call feedkeys(post_keys)
                                    endif
                                    let world.state = ''
                                endtry
                            endf
                            
                            
    1              0.000007 function! s:CallAgent(handler, world, list) abort "{{{3
                                let agent = a:handler.agent
                                let args = [a:world, a:list]
                                if has_key(a:handler, 'args')
                                    let args += a:handler.args
                                endif
                                let world = call(agent, args)
                                Tlibtrace 'tlib', world.state, world.rv
                                call s:CheckAgentReturnValue(agent, world)
                                return world
                            endf
                            
    1              0.000004 function! s:GetModdedChar(world) "{{{3
                                let [char, mode] = tlib#char#Get(a:world.timeout, a:world.timeout_resolution, 1)
                                if char !~ '\D' && char > 0 && mode != 0
                                    return printf("<%s-%s>", mode, char)
                                else
                                    return char
                                endif
                            endf
                            
                            
    1              0.000003 function! s:Init(world, cmd) "{{{3
                                Tlibtrace 'tlib', a:cmd
                                let a:world.initial_display = 1
                                if a:cmd =~ '\<sticky\>'
                                    let a:world.sticky = 1
                                endif
                                if a:cmd =~ '^resume'
                                    call a:world.UseInputListScratch()
                                    let a:world.initial_index = line('.')
                                    if a:cmd =~ '\<pick\>'
                                        let a:world.state = 'pick'
                                        let a:world.prefidx = a:world.initial_index
                                    else
                                        call a:world.Retrieve(1)
                                    endif
                                    " if !empty(a:world.resume_state)
                                    "     let a:world.state = a:world.resume_state
                                    " endif
                                elseif !a:world.initialized
                                    Tlibtrace 'tlib', a:world.initialized, a:world.win_id, a:world.bufnr
                                    let a:world.filetype = &filetype
                                    let a:world.fileencoding = &fileencoding
                                    call a:world.SetMatchMode(tlib#var#Get('tlib#input#filter_mode', 'wb'))
                                    call a:world.Initialize()
                                    if !has_key(a:world, 'key_mode')
                                        let a:world.key_mode = 'default'
                                    endif
                                    Tlibtrace 'tlib', has_key(a:world,'key_map')
                                    if has_key(a:world, 'key_map')
                                        Tlibtrace 'tlib', has_key(a:world.key_map,a:world.key_mode)
                                        if has_key(a:world.key_map, a:world.key_mode)
                                            let a:world.key_map[a:world.key_mode] = extend(
                                                        \ a:world.key_map[a:world.key_mode],
                                                        \ copy(g:tlib#input#keyagents_InputList_s),
                                                        \ 'keep')
                                        else
                                            let a:world.key_map[a:world.key_mode] = copy(g:tlib#input#keyagents_InputList_s)
                                        endif
                                    else
                                        let a:world.key_map = {
                                                    \ a:world.key_mode : copy(g:tlib#input#keyagents_InputList_s)
                                                    \ }
                                    endif
                                    Tlibtrace 'tlib', a:world.type
                                    if stridx(a:world.type, 'm') != -1
                                        call extend(a:world.key_map[a:world.key_mode], g:tlib#input#keyagents_InputList_m, 'force')
                                    endif
                                    for key_mode in keys(a:world.key_map)
                                        let a:world.key_map[key_mode] = map(a:world.key_map[key_mode], 'type(v:val) == 4 ? v:val : {"agent": v:val}')
                                    endfor
                                    Tlibtrace 'tlib', a:world.key_mode
                                    if type(a:world.key_handlers) == 3
                                        call s:ExtendKeyMap(a:world, a:world.key_mode, a:world.key_handlers)
                                    elseif type(a:world.key_handlers) == 4
                                        for [world_key_mode, world_key_handlers] in items(a:world.key_handlers)
                                            call s:ExtendKeyMap(a:world, world_key_mode, world_key_handlers)
                                        endfor
                                    else
                                        throw "tlib#input#ListW: key_handlers must be either a list or a dictionary"
                                    endif
                                    Tlibtrace 'tlib', a:world.type, a:world.key_map
                                    if !empty(a:cmd)
                                        let a:world.state .= ' '. a:cmd
                                    endif
                                endif
                                Tlibtrace 'tlib', a:world.state, a:world.sticky
                            endf
                            
                            
    1              0.000004 function! s:ExtendKeyMap(world, key_mode, key_handlers) "{{{3
                                for handler in a:key_handlers
                                    let k = get(handler, 'key', '')
                                    if !empty(k)
                                        let a:world.key_map[a:key_mode][k] = handler
                                    endif
                                endfor
                            endf
                            
                            
    1              0.000003 function! s:PopupmenuExists()
                                if !g:tlib#input#use_popup
                                            \ || exists(':popup') != 2
                                            \ || !(has('gui_win32') || has('gui_gtk') || has('gui_gtk2'))
                                            " \ || !has('gui_win32')
                                    let rv = -1
                                else
                                    try
                                        let rv = 1
                                        silent amenu ]TLibInputListPopupMenu
                                    catch
                                        let rv = 0
                                    endtry
                                endif
                                Tlibtrace 'tlib', rv
                                return rv
                            endf
                            
                            
    1              0.000003 function! s:BuildMenu(world) "{{{3
                                if g:tlib#input#use_popup && s:PopupmenuExists() == 0
                                    call s:BuildItem('Pick\ selected\ item', {'key_name': '<cr>', 'eval': 'let world.state = "pick"'})
                                    call s:BuildItem('Cancel', {'key_name': '<esc>', 'agent': 'tlib#agent#Exit'})
                                    call s:BuildItem('Select', {'key_name': '#', 'agent': 'tlib#agent#Select'})
                                    call s:BuildItem('Select\ all', {'key_name': '<c-a>', 'agent': 'tlib#agent#SelectAll'})
                                    call s:BuildItem('Reset\ list', {'key_name': '<c-r>', 'agent': 'tlib#agent#Reset'})
                                    call s:BuildItem('-StandardEntries-', {'key': ":", 'eval': 'let world.state = "redisplay"'})
                                    for [key_mode, key_handlers] in items(a:world.key_map)
                                        let keys = sort(keys(key_handlers))
                                        let mitems = {}
                                        for key in keys
                                            let handler = key_handlers[key]
                                            let k = get(handler, 'key', '')
                                            if !empty(k) && has_key(handler, 'help') && !empty(handler.help)
                                                if empty(key_mode) || key_mode == 'default'
                                                    let mname = ''
                                                else
                                                    let mname = escape(key_mode, ' .\') .'.'
                                                endif
                                                if has_key(handler, 'submenu')
                                                    let submenu = escape(handler.submenu, ' .\')
                                                else
                                                    let submenu = '~'
                                                endif
                                                for mfield in ['menu', 'help', 'key_name', 'agent']
                                                    if has_key(handler, mfield)
                                                        let mname .= escape(handler[mfield], ' .\')
                                                        break
                                                    endif
                                                endfor
                                                if !has_key(mitems, submenu)
                                                    let mitems[submenu] = {}
                                                endif
                                                let mitems[submenu][mname] = handler
                                            endif
                                        endfor
                                        for msubname in sort(keys(mitems))
                                            let msubitems = mitems[msubname]
                                            if msubname == '~'
                                                let msubmname = ''
                                            else
                                                let msubmname = msubname .'.'
                                            endif
                                            for mname in sort(keys(msubitems))
                                                let msname = msubmname . mname
                                                let handler = msubitems[mname]
                                                call s:BuildItem(msname, handler)
                                                " if has_key(handler, 'agent')
                                                "     call s:BuildItem(msname, {'agent': handler.agent})
                                                " else
                                                "     call s:BuildItem(msname, {'key': handler.key_name})
                                                " endif
                                            endfor
                                        endfor
                                    endfor
                                endif
                            endf
                            
                            
    1              0.000004 function! s:BuildItem(menu, def) "{{{3
                                if has('gui_win32')
                                    let key_mode = 'c'
                                elseif has('gui_gtk') || has('gui_gtk2')
                                    let key_mode = 'raw'
                                endif
                                for k in ['agent', 'eval', 'key_name', 'key']
                                    if has('gui_win32')
                                    elseif has('gui_gtk') || has('gui_gtk')
                                        if k == 'agent' || k == 'eval'
                                            continue
                                        endif
                                    endif
                                    try 
                                        if has_key(a:def, k)
                                            let v = a:def[k]
                                            if k == 'key'
                                                if key_mode == 'c'
                                                    " echom 'DBG amenu' (']TLibInputListPopupMenu.'. a:menu) ':let c = "'. v .'"<cr>'
                                                    exec 'amenu' (']TLibInputListPopupMenu.'. a:menu) ':let c = "'. v .'"<cr>'
                                                else
                                                    " echom 'DBG amenu' (']TLibInputListPopupMenu.'. a:menu) v
                                                    exec 'amenu' (']TLibInputListPopupMenu.'. a:menu) v
                                                endif
                                            elseif k == 'key_name'
                                                if key_mode == 'c'
                                                    " echom 'DBG amenu' (']TLibInputListPopupMenu.'. a:menu) ':let c = "\'. v .'"<cr>'
                                                    exec 'amenu' (']TLibInputListPopupMenu.'. a:menu) ':let c = "\'. v .'"<cr>'
                                                else
                                                    let key = v
                                                    " echom 'DBG amenu' (']TLibInputListPopupMenu.'. a:menu) key
                                                    exec 'amenu' (']TLibInputListPopupMenu.'. a:menu) key
                                                endif
                                            elseif k == 'agent'
                                                " echom 'DBG amenu' (']TLibInputListPopupMenu.'. a:menu) ':let world.next_agent ='. string(v) .'<cr>'
                                                exec 'amenu' (']TLibInputListPopupMenu.'. a:menu) ':let world.next_agent ='. string(v) .'<cr>'
                                            elseif k == 'eval'
                                                " echom 'DBG amenu' (']TLibInputListPopupMenu.'. a:menu) ':let world.next_eval ='. string(v) .'<cr>'
                                                exec 'amenu' (']TLibInputListPopupMenu.'. a:menu) ':let world.next_eval ='. string(v) .'<cr>'
                                            endif
                                            return
                                        endif
                                    catch
                                    endtry
                                endfor
                            endf
                            
                            
    1              0.000004 function! s:RunStateHandlers(world) "{{{3
                                " Provide the variable "world" in the environment of an "exec" 
                                " handler (ea).
                                let world = a:world
                                for handler in a:world.state_handlers
                                    let eh = get(handler, 'state', '')
                                    if !empty(eh) && a:world.state =~ eh
                                        let ea = get(handler, 'exec', '')
                                        if !empty(ea)
                                            exec ea
                                        else
                                            let agent = get(handler, 'agent', '')
                                            " let world = call(agent, [a:world, a:world.GetSelectedItems(a:world.CurrentItem())])
                                            " call s:CheckAgentReturnValue(agent, a:world)
                                            let world = s:CallAgent({'agent': agent}, world, world.GetSelectedItems(world.CurrentItem()))
                                        endif
                                    endif
                                endfor
                                return world
                            endf
                            
                            
    1              0.000003 function! s:CheckAgentReturnValue(name, value) "{{{3
                                if type(a:value) != 4 && !has_key(a:value, 'state')
                                    echoerr 'Malformed agent: '. a:name
                                endif
                                return a:value
                            endf
                            
                            
    1              0.000003 function! s:SetOffset(world) "{{{3
                                let llenw = len(a:world.base) - winheight(0) + 1
                                if a:world.offset > llenw
                                    let a:world.offset = llenw
                                endif
                                if a:world.offset < 1
                                    let a:world.offset = 1
                                endif
                            endf
                            
                            
                            " Functions related to tlib#input#EditList(type, ...) "{{{2
                            
                            " :def: function! tlib#input#EditList(query, list, ?timeout=0)
                            " Edit a list.
                            "
                            " EXAMPLES: >
                            "   echo tlib#input#EditList('Edit:', [100,200,300])
    1              0.000004 function! tlib#input#EditList(query, list, ...) "{{{3
                                let handlers = a:0 >= 1 && !empty(a:1) ? a:1 : g:tlib#input#handlers_EditList
                                let default  = a:0 >= 2 ? a:2 : []
                                let timeout  = a:0 >= 3 ? a:3 : 0
                                Tlibtrace 'tlib', handlers
                                let rv = tlib#input#List('me', a:query, copy(a:list), handlers, default, timeout)
                                Tlibtrace 'tlib', rv
                                if empty(rv)
                                    return a:list
                                else
                                    let [success, list] = rv
                                    return success ? list : a:list
                                endif
                            endf
                            
                            
    1              0.000003 function! tlib#input#Resume(name, pick, bufnr) "{{{3
                                Tlibtrace 'tlib', a:name, a:pick
                                echo
                                if bufnr('%') != a:bufnr
                                    if g:tlib#debug
                                        echohl WarningMsg
                                        echom "tlib#input#Resume: Internal error: Not in scratch buffer:" bufname('%')
                                        echohl NONE
                                    endif
                                    let br = tlib#buffer#Set(a:bufnr)
                                endif
                                if !exists('b:tlib_'. a:name)
                                    if g:tlib#debug
                                        echohl WarningMsg
                                        echom "tlib#input#Resume: Internal error: b:tlib_". a:name ." does not exist:" bufname('%')
                                        echohl NONE
                                        redir => varss
                                        silent let b:
                                        redir END
                                        let vars = split(varss, '\n')
                                        call filter(vars, 'v:val =~ "^b:tlib_"')
                                        echom "DEBUG tlib#input#Resume" string(vars)
                                    endif
                                else
                                    call tlib#autocmdgroup#Init()
                                    autocmd! TLib BufEnter <buffer>
                                    if b:tlib_{a:name}.state !~# 'display\>'
                                        let b:tlib_{a:name}.state = 'redisplay'
                                    endif
                                    " call tlib#input#List('resume '. a:name)
                                    let cmd = 'resume '. a:name
                                    if a:pick >= 1
                                        let cmd .= ' pick'
                                        if a:pick >= 2
                                            let cmd .= ' sticky'
                                        end
                                    endif
                                    call tlib#input#ListW(b:tlib_{a:name}, cmd)
                                endif
                            endf
                            
                            
                            " :def: function! tlib#input#CommandSelect(command, ?keyargs={})
                            " Take a command, view the output, and let the user select an item from 
                            " its output.
                            "
                            " EXAMPLE: >
                            "     command! TMarks exec 'norm! `'. matchstr(tlib#input#CommandSelect('marks'), '^ \+\zs.')
                            "     command! TAbbrevs exec 'norm i'. matchstr(tlib#input#CommandSelect('abbrev'), '^\S\+\s\+\zs\S\+')
    1              0.000003 function! tlib#input#CommandSelect(command, ...) "{{{3
                                TVarArg ['args', {}]
                                if has_key(args, 'retrieve')
                                    let list = call(args.retrieve)
                                elseif has_key(args, 'list')
                                    let list = args.list
                                else
                                    let list = tlib#cmd#OutputAsList(a:command)
                                endif
                                if has_key(args, 'filter')
                                    call map(list, args.filter)
                                endif
                                let type     = has_key(args, 'type') ? args.type : 's'
                                let handlers = has_key(args, 'handlers') ? args.handlers : []
                                let rv = tlib#input#List(type, 'Select', list, handlers)
                                if !empty(rv)
                                    if has_key(args, 'process')
                                        let rv = call(args.process, [rv])
                                    endif
                                endif
                                return rv
                            endf
                            
                            
                            " :def: function! tlib#input#Edit(name, value, callback, ?cb_args=[])
                            "
                            " Edit a value (asynchronously) in a scratch buffer. Use name for 
                            " identification. Call callback when done (or on cancel).
                            " In the scratch buffer:
                            " Press <c-s> or <c-w><cr> to enter the new value, <c-w>c to cancel 
                            " editing.
                            " EXAMPLES: >
                            "   fun! FooContinue(success, text)
                            "       if a:success
                            "           let b:var = a:text
                            "       endif
                            "   endf
                            "   call tlib#input#Edit('foo', b:var, 'FooContinue')
    1              0.000004 function! tlib#input#EditW(world, name, value, callback, ...) "{{{3
                                Tlibtrace 'tlib', a:value
                                TVarArg ['args', []]
                                let sargs = {'scratch': '__EDIT__'. a:name .'__', 'win_id': tlib#win#GetID()}
                                let scr = tlib#scratch#UseScratch(sargs)
                                let b:tlib_world = a:world
                            
                                " :nodoc:
                                map <buffer> <c-w>c :call tlib#input#EditCallback(0)<cr>
                                " :nodoc:
                                imap <buffer> <c-w>c <c-o>call tlib#input#EditCallback(0)<cr>
                                " :nodoc:
                                map <buffer> <c-s> :call tlib#input#EditCallback(1)<cr>
                                " :nodoc:
                                imap <buffer> <c-s> <c-o>call tlib#input#EditCallback(1)<cr>
                                " :nodoc:
                                map <buffer> <c-w><cr> :call tlib#input#EditCallback(1)<cr>
                                " :nodoc:
                                imap <buffer> <c-w><cr> <c-o>call tlib#input#EditCallback(1)<cr>
                                
                                call tlib#normal#WithRegister('gg"tdG', 't')
                                call append(1, split(a:value, "\<c-j>", 1))
                                " let hrm = 'DON''T DELETE THIS HEADER'
                                " let hr3 = repeat('"', (tlib#win#Width(0) - len(hrm)) / 2)
                                let s:horizontal_line = repeat('`', tlib#win#Width(0))
                                " hr3.hrm.hr3
                                let hd  = ['Keys: <c-s>, <c-w><cr> ... save/accept; <c-w>c ... cancel', s:horizontal_line]
                                call append(1, hd)
                                call tlib#normal#WithRegister('gg"tdd', 't')
                                syntax match TlibEditComment /^\%1l.*/
                                syntax match TlibEditComment /^```.*/
                                hi link TlibEditComment Comment
                                exec len(hd) + 1
                                if type(a:callback) == 4
                                    let b:tlib_scratch_edit_callback = get(a:callback, 'submit', '')
                                    call call(get(a:callback, 'init', ''), [])
                                else
                                    let b:tlib_scratch_edit_callback = a:callback
                                endif
                                let b:tlib_scratch_edit_args     = args
                                let b:tlib_scratch_edit_scratch  = sargs
                                " exec 'autocmd BufDelete,BufHidden,BufUnload <buffer> call tlib#input#EditCallback('. string(a:name) .')'
                                " echohl MoreMsg
                                " echom 'Press <c-s> to enter, <c-w>c to cancel editing.'
                                " echohl NONE
                                let world = getbufvar(scr, 'tlib_world', a:world)
                                let world.state .= ' norestore'
                                return world
                            endf
                            
                            
    1              0.000003 function! tlib#input#EditCallback(...) "{{{3
                                TVarArg ['ok', -1]
                                " , ['bufnr', -1]
                                " autocmd! BufDelete,BufHidden,BufUnload <buffer>
                                if ok == -1
                                    let ok = confirm('Use value')
                                endif
                                let start = getline(2) == s:horizontal_line ? 3 : 1
                                let text = ok ? join(getline(start, '$'), "\n") : ''
                                let cb   = b:tlib_scratch_edit_callback
                                let args = b:tlib_scratch_edit_args
                                let sargs = b:tlib_scratch_edit_scratch
                                let world = b:tlib_world
                                Tlibtrace 'tlib', cb, args, sargs
                                call call(cb, args + [ok, text, world])
                                call tlib#scratch#CloseScratch(b:tlib_scratch_edit_scratch)
                                call tlib#win#SetById(sargs.win_id)
                            endf
                            
                            
    1              0.000004 function! tlib#input#Dialog(text, options, default) "{{{3
                                if has('dialog_con') || has('dialog_gui')
                                    let opts = join(map(a:options, '"&". v:val'), "\n")
                                    let val = confirm(a:text, opts)
                                    if val
                                        let yn = a:options[val - 1]
                                    else
                                        let yn = a:default
                                    endif
                                else
                                    let oi = index(a:options, a:default)
                                    if oi == -1
                                        let opts = printf("(%s|%s)", join(a:options, '/'), a:default)
                                    else
                                        let options = copy(a:options)
                                        let options[oi] = toupper(options[oi])
                                        let opts = printf("(%s)", join(a:options, '/'))
                                    endif
                                    let yn = inputdialog(a:text .' '. opts)
                                endif
                                return yn
                            endf
                            

SCRIPT  /Users/brettmz-admin/dev_trees/myvim/bundle/tlib_vim/autoload/tlib/arg.vim
Sourced 1 time
Total time:   0.000462
 Self time:   0.000462

count  total (s)   self (s)
                            " @Author:      Tom Link (micathom AT gmail com?subject=[vim])
                            " @Website:     http://www.vim.org/account/profile.php?user_id=4037
                            " @License:     GPL (see http://www.gnu.org/licenses/gpl.txt)
                            " @Last Change: 2017-09-28.
                            " @Revision:    273
                            
                            
                            " :def: function! tlib#arg#Get(n, var, ?default="", ?test='')
                            " Set a positional argument from a variable argument list.
                            " See tlib#string#RemoveBackslashes() for an example.
    1              0.000006 function! tlib#arg#Get(n, var, ...) "{{{3
                                let default = a:0 >= 1 ? a:1 : ''
                                let atest   = a:0 >= 2 ? a:2 : ''
                                " TLogVAR default, atest
                                if !empty(atest)
                                    let atest = ' && (a:'. a:n .' '. atest .')'
                                endif
                                let test = printf('a:0 >= %d', a:n) . atest
                                return printf('let %s = %s ? a:%d : %s', a:var, test, a:n, string(default))
                            endf
                            
                            
                            " :def: function! tlib#arg#Let(list, ?default='')
                            " Set a positional arguments from a variable argument list.
                            " See tlib#input#List() for an example.
    1              0.000003 function! tlib#arg#Let(list, ...) "{{{3
                                let default = a:0 >= 1 ? a:1 : ''
                                let list = map(copy(a:list), 'type(v:val) == 3 ? v:val : [v:val, default]')
                                let args = map(range(1, len(list)), 'call("tlib#arg#Get", [v:val] + list[v:val - 1])')
                                return join(args, ' | ')
                            endf
                            
                            
                            " :def: function! tlib#arg#StringAsKeyArgs(string, ?keys=[], ?evaluate=0, ?sep=':', ?booleans=0)
    1              0.000003 function! tlib#arg#StringAsKeyArgs(string, ...) "{{{1
                                TVarArg ['keys', {}], ['evaluate', 0], ['sep', ':'], ['booleans', 0]
                                let keyargs = {}
                                let args = split(a:string, '\\\@<! ')
                                let key_rx = booleans ? '\([-+]\?\w\+\)' : '\(\w\+\)'
                                let arglist = map(args, 'matchlist(v:val, ''^\%('. key_rx . sep .'\(.*\)\|\(.*\)\)$'')')
                                " TLogVAR a:string, args, arglist
                                let pos = -1
                                for matchlist in arglist
                                    if !empty(matchlist[3])
                                        if booleans && matchlist[3] =~ '^[-+]'
                                            let key = substitute(matchlist[3], '^[-+]', '', '')
                                            let val = matchstr(matchlist[3], '^[-+]')
                                            let keyargs[key] = val ==# '+'
                                        else
                                            let pos += 1
                                            let keyargs[pos] = matchlist[3]
                                        endif
                                    else
                                        let [match, key, val; rest] = matchlist
                                        if empty(keys) || has_key(keys, key)
                                            let val = substitute(val, '\\\\', '\\', 'g')
                                            if evaluate
                                                let val = eval(val)
                                            endif
                                            let keyargs[key] = val
                                        else
                                            echom 'Unknown key: '. key .'='. val
                                        endif
                                    endif
                                endfor
                                if pos >= 0
                                    let keyargs['__posargs__'] = range(0, pos)
                                endif
                                return keyargs
                            endf
                            
                            
    1              0.000003 function! tlib#arg#StringAsKeyArgsEqual(string) "{{{1
                                return tlib#arg#StringAsKeyArgs(a:string, [], 0, '=', 1)
                            endf
                            
                            
                            " :display: tlib#arg#GetOpts(args, ?def={})
                            " Convert a list of strings of command-line arguments into a dictonary.
                            "
                            " The main use case is to pass [<f-args>], i.e. the command-line 
                            " arguments of a command as list, from a command definition to this 
                            " function.
                            "
                            " Example:
                            " ['-h']
                            " => If def contains a 'help' key, invoke |:help| on its value.
                            "
                            " ['-ab', '--foo', '--bar=BAR', 'bla', bla']
                            " => {'a': 1, 'b': 1, 'foo': 1, 'bar': 'BAR', '__rest__': ['bla', 'bla']}
                            "
                            " ['-ab', '--', '--foo', '--bar=BAR']
                            " => {'a': 1, 'b': 1, '__rest__': ['--foo', '--bar=BAR']}
    1              0.000003 function! tlib#arg#GetOpts(args, ...) abort "{{{3
                                if type(a:args) == 4
                                    reutrn a:args
                                else
                                    let throw = a:0 == 0
                                    TVarArg ['def', {}]
                                    " TLogVAR def
                                    let opts = {'__exit__': 0}
                                    for [key, vdef] in items(get(def, 'values', {}))
                                        if has_key(vdef, 'default')
                                            let opts[key] = vdef.default
                                        endif
                                    endfor
                                    let idx = 0
                                    for o in a:args
                                        let [break, idx] = s:SetOpt(def, opts, idx, o)
                                        if break == 1
                                            break
                                        elseif break == 2
                                            if throw
                                                throw 'tlib#arg#GetOpts: Show help'
                                            else
                                                let opts.__exit__ = 5
                                            endif
                                        endif
                                    endfor
                                    let opts.__rest__ = a:args[idx : -1]
                                    return opts
                                endif
                            endf
                            
                            
    1              0.000005 function! s:GetValueType(def) abort "{{{3
                                return get(a:def, 'type', type(get(a:def, 'default', '')))
                            endf
                            
                            
    1              0.000004 function! s:SetOpt(def, opts, idx, opt) abort "{{{3
                                " TLogVAR a:def
                                let idx = a:idx + 1
                                let break = 0
                                let long = get(a:def, 'long', 1)
                                let short = get(a:def, 'short', 1)
                                if (short && a:opt =~# '^-[?h]$') || (long && a:opt ==# '--help')
                                    if has_key(a:def, 'help')
                                        exec 'help' a:def.help
                                    else
                                        " TLogVAR a:def
                                        let values = get(a:def, 'values', {})
                                        let flags = get(a:def, 'flags', {})
                                        if empty(values) && empty(flags)
                                            echom 'No help'
                                        else
                                            if !empty(values)
                                                echom 'Options:'
                                                for [key, vdef] in sort(items(values))
                                                    let opt = key
                                                    let default = get(vdef, 'default', '')
                                                    let type = s:GetValueType(vdef)
                                                    if default =~ '^-\?\d\+\%(\.\d\+\)$'
                                                        if type == -1 || type == 6
                                                            let opt .= ' (flag)'
                                                        elseif type == 1
                                                            let opt .= '=INT'
                                                        else
                                                            let opt .= '=INT or maybe BOOL'
                                                        endif
                                                    elseif type(default) == 1
                                                        let opt .= '=STRING'
                                                    elseif type(default) == 3
                                                        let opt .= '=COMMA-LIST'
                                                    endif
                                                    echom printf('  --%20s (default: %s)', opt, string(default))
                                                endfor
                                            endif
                                            if !empty(flags)
                                                echom 'Short flags:'
                                                for [sflag, lflag] in sort(items(flags))
                                                    echom printf('  -%s -> %s', sflag, lflag)
                                                endfor
                                            endif
                                        endif
                                    endif
                                    let break = 2
                                elseif long &&  a:opt =~# '^--\%(no-\)\?debug$'
                                    if has_key(a:def, 'trace')
                                        let mod = a:opt =~# '--no-' ? '-' : '+'
                                        exec 'Tlibtraceset' mod . a:def.trace
                                    endif
                                elseif long &&  a:opt =~# '^--no-.\+'
                                    let key = matchstr(a:opt, '^--no-\zs.\+$')
                                    let a:opts[key] = s:Validate(a:def, key, 0)
                                elseif long &&  a:opt =~# '^--\w\+$'
                                    let key = matchstr(a:opt, '^--\zs.\+$')
                                    let a:opts[key] = s:Validate(a:def, key, 1)
                                elseif long &&  a:opt =~# '^--\w\+='
                                    let ml = matchlist(a:opt, '^--\(\w\+\)=\(.*\)$')
                                    if empty(ml)
                                        throw 'tlib#arg#GetOpts: Cannot parse: '. a:opt
                                    else
                                        let values = get(a:def, 'values', {})
                                        if has_key(values, ml[1])
                                            let vdef = values[ml[1]]
                                            let type = s:GetValueType(vdef)
                                            if type == -1
                                                let opt_value = !!str2nr(ml[2])
                                            elseif type == 0
                                                let opt_value = str2nr(ml[2])
                                            elseif type == 1
                                                let opt_value = ml[2]
                                            elseif type == 2
                                                let opt_value = function(ml[2])
                                            elseif type == 3
                                                let opt_value = tlib#string#SplitCommaList(ml[2])
                                            elseif type == 4
                                                throw 'tlib#arg#GetOpts: Unsupported type conversion for '. ml[1]
                                            elseif type == 5
                                                let opt_value = str2float(ml[2])
                                            endif
                                        else
                                            let opt_value = ml[2]
                                        endif
                                        let a:opts[ml[1]] = s:Validate(a:def, ml[1], opt_value)
                                        unlet opt_value
                                    endif
                                elseif short && a:opt =~# '^-\w='
                                    let flagdefs = get(a:def, 'flags', {})
                                    let flag = matchstr(a:opt, '^-\zs\w')
                                    let rest = matchstr(a:opt, '^-\w\zs.*$')
                                    call s:SetFlag(a:def, a:opts, idx, flag, rest, flagdefs)
                                elseif short && a:opt =~# '^-\w\+$'
                                    let flagdefs = get(a:def, 'flags', {})
                                    for flag in split(substitute(a:opt, '^-', '', ''), '\zs')
                                        call s:SetFlag(a:def, a:opts, idx, flag, '', flagdefs)
                                    endfor
                                else
                                    let break = 1
                                    if a:opt !=# '--'
                                        let idx -= 1
                                    endif
                                endif
                                return [break, idx]
                            endf
                            
                            
    1              0.000005 function! s:SetFlag(def, opts, idx, flag, rest, flagdefs) abort "{{{3
                                " TLogVAR a:def
                                if has_key(a:flagdefs, a:flag)
                                    call s:SetOpt(a:def, a:opts, a:idx, a:flagdefs[a:flag] . a:rest)
                                else
                                    let a:opts[a:flag] = s:Validate(a:def, a:flag, 1)
                                endif
                            endf
                            
                            
    1              0.000004 function! s:Validate(def, name, value) abort "{{{3
                                let values = get(a:def, 'values', {})
                                if has_key(values, a:name)
                                    let vdef = values[a:name]
                                    if has_key(vdef, 'validate')
                                        if !call(vdef.validate, [a:value])
                                            throw printf('tlib#arg: %s has invalid value: %s', string(a:name), string(a:value))
                                        endif
                                    endif
                                endif
                                return a:value
                            endf
                            
                            
                            ":nodoc:
    1              0.000004 function! tlib#arg#CComplete(def, ArgLead) abort "{{{3
                                let values = get(a:def, 'values', {})
                                let opt = matchstr(a:ArgLead, '^--\zs\w\+\ze=')
                                if has_key(values, opt)
                                    let words = []
                                    let vals = values[opt]
                                    let complete_customlist = get(vals, 'complete_customlist', '')
                                    if !empty(complete_customlist)
                                        let words = eval(complete_customlist)
                                    " else
                                    "     let complete = get(vals, 'complete', '')
                                    "     if !empty(complete)
                                    "     endif
                                    endif
                                    if !empty(words)
                                        let prefix = matchstr(a:ArgLead, '^--\w\+=\%([^,]\+,\s*\)*')
                                        let lead = substitute(a:ArgLead, '^--\w\+=\%([^,]\+,\s*\)*', '', '')
                                        " TLogVAR a:ArgLead, lead
                                        if !empty(lead)
                                            let nchar = len(lead)
                                            call filter(words, 'tlib#string#Strcharpart(v:val, 0, nchar) ==# lead')
                                        endif
                                        let words = map(words, 'prefix . v:val')
                                        return sort(words)
                                    endif
                                endif
                                let cs = {'-h': 1, '--help': 1}
                                for [name, vdef] in items(values)
                                    let type = s:GetValueType(vdef)
                                    if type >= 0
                                        let name .= '='
                                    else
                                        let cs['--no-'. name] = 1
                                    endif
                                    let cs['--'. name] = 1
                                endfor
                                for [name, subst] in items(get(a:def, 'flags', {}))
                                    let ldef = get(values, substitute(subst, '^--', '', ''), {})
                                    let type = s:GetValueType(ldef)
                                    if type >= 0
                                        let name .= '='
                                    endif
                                    let cs['-'. name] = 1
                                endfor
                                if has_key(a:def, 'trace')
                                    let cs['--debug'] = 1
                                endif
                                let nchar = len(a:ArgLead)
                                if nchar > 0
                                    call filter(cs, 'tlib#string#Strcharpart(v:key, 0, nchar) ==# a:ArgLead')
                                endif
                                return sort(keys(cs))
                            endf
                            
                            
                            
                            """ Command line {{{1
                            
                            " :def: function! tlib#arg#Ex(arg, ?chars='%#! ')
                            " Escape some characters in a string.
                            "
                            " Use |fnamescape()| if available.
                            "
                            " EXAMPLES: >
                            "   exec 'edit '. tlib#arg#Ex('foo%#bar.txt')
    1              0.000002 function! tlib#arg#Ex(arg, ...) "{{{3
                                if exists('*fnameescape') && a:0 == 0
                                    return fnameescape(a:arg)
                                else
                                    " let chars = '%# \'
                                    let chars = '%#! '
                                    if a:0 >= 1
                                        let chars .= a:1
                                    endif
                                    return escape(a:arg, chars)
                                endif
                            endf
                            
                            

SCRIPT  /Users/brettmz-admin/dev_trees/myvim/bundle/tlib_vim/autoload/tlib/World.vim
Sourced 1 time
Total time:   0.004776
 Self time:   0.003741

count  total (s)   self (s)
                            " @Author:      Tom Link (micathom AT gmail com?subject=[vim])
                            " @Website:     http://www.vim.org/account/profile.php?user_id=4037
                            " @License:     GPL (see http://www.gnu.org/licenses/gpl.txt)
                            " @Revision:    1481
                            
                            
                            " :filedoc:
                            " A prototype used by |tlib#input#List|.
                            " Inherits from |tlib#Object#New|.
                            
                            
                            " Size of the input list window (in percent) from the main size (of &lines).
                            " See |tlib#input#List()|.
    1              0.000050 TLet g:tlib_inputlist_pct = 50
                            
                            " Max height for a horizontal list.
    1              0.000033 TLet g:tlib_inputlist_max_lines = -1
                            
                            " Max width for a vertical list.
    1              0.000029 TLet g:tlib_inputlist_max_cols = -1
                            
                            " Size of filename columns when listing filenames.
                            " See |tlib#input#List()|.
    1              0.000035 TLet g:tlib_inputlist_width_filename = '&columns / 3'
                            " TLet g:tlib_inputlist_width_filename = 25
                            
                            " If true, |tlib#input#List()| will show some indicators about the 
                            " status of a filename (e.g. buflisted(), bufloaded() etc.).
                            " This is disabled by default because vim checks also for the file on 
                            " disk when doing this.
    1              0.000048 TLet g:tlib_inputlist_filename_indicators = 0
                            
                            " If not null, display only a short info about the filter.
    1              0.000022 TLet g:tlib_inputlist_shortmessage = 0
                            
                            
                            
                            " Known keys & values:
                            "   scratch_split ... See |tlib#scratch#UseScratch()|
    1   0.003146   0.002111 let s:prototype = tlib#Object#New({
                                        \ '_class': 'World',
                                        \ 'name': 'world',
                                        \ 'allow_suspend': 1,
                                        \ 'base': [], 
                                        \ 'bufnr': -1,
                                        \ 'buffer_local': 1,
                                        \ 'cache_var': '',
                                        \ 'display_format': '',
                                        \ 'fileencoding': &fileencoding,
                                        \ 'fmt_display': {},
                                        \ 'fmt_filter': {},
                                        \ 'fmt_options': {},
                                        \ 'filetype': '',
                                        \ 'filter': [['']],
                                        \ 'filter_format': '',
                                        \ 'filter_options': '',
                                        \ 'follow_cursor': '',
                                        \ 'has_menu': 0,
                                        \ 'help_extra': [],
                                        \ 'index_table': [],
                                        \ 'initial_filter': [['']],
                                        \ 'initial_index': 1,
                                        \ 'initial_display': 1,
                                        \ 'initialized': 0,
                                        \ 'key_handlers': [],
                                        \ 'list': [],
                                        \ 'matcher': {},
                                        \ 'next_agent': '',
                                        \ 'next_eval': '',
                                        \ 'next_state': '',
                                        \ 'numeric_chars': g:tlib#input#numeric_chars,
                                        \ 'offset': 1,
                                        \ 'offset_horizontal': 0,
                                        \ 'on_leave': [],
                                        \ 'pick_last_item': tlib#var#Get('tlib#input#pick_last_item', 'bg'),
                                        \ 'post_handlers': [],
                                        \ 'query': '',
                                        \ 'resize': 0,
                                        \ 'resize_vertical': 0,
                                        \ 'restore_from_cache': [],
                                        \ 'filtered_items': [],
                                        \ 'resume_state': '', 
                                        \ 'retrieve_eval': '',
                                        \ 'return_agent': '',
                                        \ 'rv': '',
                                        \ 'scratch': '__InputList__',
                                        \ 'scratch_filetype': 'tlibInputList',
                                        \ 'scratch_hidden': g:tlib#scratch#hidden,
                                        \ 'scratch_vertical': 0,
                                        \ 'scratch_split': 1,
                                        \ 'sel_idx': [],
                                        \ 'show_empty': 0,
                                        \ 'state': 'display', 
                                        \ 'state_handlers': [],
                                        \ 'sticky': 0,
                                        \ 'temp_lines': [],
                                        \ 'temp_prompt': [],
                                        \ 'timeout': 0,
                                        \ 'timeout_resolution': 2,
                                        \ 'tabpagenr': -1,
                                        \ 'type': '', 
                                        \ 'win_id': g:tlib#win#null_id,
                                        \ 'win_height': -1,
                                        \ 'win_width': -1,
                                        \ 'win_pct': 25,
                                        \ })
                                        " \ 'handlers': [],
                                        " \ 'filter_options': '\c',
                            
    1              0.000003 function! tlib#World#New(...) abort
                                let object = s:prototype.New(a:0 >= 1 ? a:1 : {})
                                call object.SetMatchMode(tlib#var#Get('tlib#input#filter_mode', 'g', 'cnf'))
                                return object
                            endf
                            
                            
                            " :nodoc:
    1              0.000003 function! s:prototype.Set_display_format(value) dict abort "{{{3
                                if a:value ==# 'filename'
                                    call self.Set_highlight_filename()
                                    let self.display_format = 'world.FormatFilename(%s)'
                                else
                                    let self.display_format = a:value
                                endif
                            endf
                            
                            
                            " :nodoc:
    1              0.000003 function! s:prototype.DisplayFormat(list) dict abort "{{{3
                                let display_format = self.display_format
                                if !empty(display_format)
                                    if has_key(self, 'InitFormatName')
                                        call self.InitFormatName()
                                    endif
                                    let cache = self.fmt_display
                                    Tlibtrace 'tlib', display_format
                                    return map(copy(a:list), 'self.FormatName(cache, display_format, v:val)')
                                else
                                    return a:list
                                endif
                            endf
                            
                            
                            " :nodoc:
    1              0.000002 function! s:prototype.Set_highlight_filename() dict abort "{{{3
                                let self.tlib_UseInputListScratch = 'call world.Highlight_filename()'
                            endf
                            
                            
    1              0.000004 if g:tlib#input#format_filename ==# 'r'
                            
                                " :nodoc:
                                function! s:prototype.Highlight_filename() dict abort "{{{3
                                    syntax match TLibDir /\s\+\zs.\{-}[\/]\ze[^\/]\+$/
                                    hi def link TLibDir Directory
                                    syntax match TLibFilename /[^\/]\+$/
                                    hi def link TLibFilename Normal
                                endf
                            
                                " :nodoc:
                                function! s:prototype.FormatFilename(file) dict abort "{{{3
                                    if !has_key(self.fmt_options, 'maxlen')
                                        let maxco = &columns - len(len(self.base)) - eval(g:tlib#input#filename_padding_r)
                                        let maxfi = max(map(copy(self.base), 'strwidth(v:val)'))
                                        let self.fmt_options.maxlen = min([maxco, maxfi])
                                        Tlibtrace 'tlib', maxco, maxfi, self.fmt_options.maxlen
                                    endif
                                    let max = self.fmt_options.maxlen
                                    if len(a:file) > max
                                        let filename = '...' . tlib#string#Strcharpart(a:file, len(a:file) - max + 3)
                                    else
                                        let filename = printf('% '. max .'s', a:file)
                                    endif
                                    return filename
                                endf
                            
    1              0.000002 else
                            
                                " :nodoc:
    1              0.000002     function! s:prototype.Highlight_filename() dict abort "{{{3
                                    " let self.width_filename = 1 + eval(g:tlib_inputlist_width_filename)
                                    Tlibtrace 'tlib', self.base
                                    let self.width_filename = min([
                                                \ get(self, 'width_filename', &columns),
                                                \ empty(g:tlib#input#filename_max_width) ? &columns : eval(g:tlib#input#filename_max_width),
                                                \ max(map(copy(self.base), 'strwidth(matchstr(v:val, "[^\\/]*$"))'))
                                                \ ])
                                   "  TLogVAR self.width_filename
                                     " exec 'syntax match TLibDir /\%>'. (1 + self.width_filename) .'c \(|\|\[[^]]*\]\) \zs\(\(\a:\|\.\.\|\.\.\..\{-}\)\?[\/][^&<>*|]\{-}\)\?[^\/]\+$/ contained containedin=TLibMarker contains=TLibFilename'
                                     exec 'syntax match TLibDir /\%>'. (1 + self.width_filename) .'c \(|\|\[[^]]*\]\) \zs[^&<>*|]*$/ contained containedin=TLibMarker contains=TLibFilename'
                                     exec 'syntax match TLibMarker /\%>'. (1 + self.width_filename) .'c \(|\|\[[^]]*\]\) \S.*$/ contains=TLibDir'
                                   "  exec 'syntax match TLibDir /\(|\|\[.\{-}\]\) \zs\(\(\a:\|\.\.\|\.\.\..\{-}\)\?[\/][^&<>*|]\{-}\)\?[^\/]\+$/ contained containedin=TLibMarker contains=TLibFilename'
                                   "  exec 'syntax match TLibMarker /\(|\|\[.\{-}\]\) \S.*$/ contains=TLibDir'
                                    exec 'syntax match TLibFilename /[^\/]\+$/ contained containedin=TLibDir'
                                    hi def link TLibMarker Special
                                    hi def link TLibDir Directory
                                    hi def link TLibFilename NonText
                                    " :nodoc:
                                    function! self.Highlighter(rx) dict abort
                                        let rx = '/\c\%>'. (1 + self.width_filename) .'c \(|\|\[[^]]*\]\) .\{-}\zs'. escape(a:rx, '/') .'/'
                                        exec 'match' self.matcher.highlight rx
                                    endf
                                endf
                            
                            
                                " :nodoc:
    1              0.000002     function! s:prototype.UseFilenameIndicators() dict abort "{{{3
                                    return g:tlib_inputlist_filename_indicators || has_key(self, 'filename_indicators')
                                endf
                            
                            
                                " :nodoc:
    1              0.000002     function! s:prototype.InitFormatName() dict abort "{{{3 
                                    if self.UseFilenameIndicators()
                                        let self._buffers = {}
                                        for bufnr in range(1, bufnr('$'))
                                            let filename = fnamemodify(bufname(bufnr), ':p')
                                            Tlibtrace 'tlib', filename
                                            let bufdef = {
                                                        \ 'bufnr': bufnr,
                                                        \ }
                                            " '&buflisted'
                                            for opt in ['&modified', '&bufhidden']
                                                let bufdef[opt] = getbufvar(bufnr, opt)
                                            endfor
                                            let self._buffers[filename] = bufdef
                                        endfor
                                    endif
                                endf
                            
                            
                                " :nodoc:
    1              0.000002     function! s:prototype.FormatFilename(file) dict abort "{{{3
                                    Tlibtrace 'tlib', a:file
                                    let width = self.width_filename
                                    let split = match(a:file, '[/\\]\zs[^/\\]\+$')
                                    if split == -1
                                        let fname = a:file
                                        let dname = a:file
                                    else
                                        let fname = strpart(a:file, split)
                                        " let dname = tlib#string#Strcharpart(a:file, 0, split - 1)
                                        let dname = a:file
                                    endif
                                    if strwidth(fname) > width
                                        let fname = tlib#string#Strcharpart(fname, 0, width - 3) .'...'
                                    endif
                                    let dnmax = &columns - max([width, strwidth(fname)]) - 8 - self.index_width - &foldcolumn
                                    let use_indicators = self.UseFilenameIndicators()
                                    Tlibtrace 'tlib', use_indicators
                                    let marker = []
                                    if use_indicators
                                        call insert(marker, '[')
                                        if g:tlib_inputlist_filename_indicators
                                            let bufdef = get(self._buffers, a:file, {})
                                            " let bnr = bufnr(a:file)
                                            let bnr = get(bufdef, 'bufnr', -1)
                                            Tlibtrace 'tlib', a:file, bnr, self.bufnr
                                            if bnr != -1
                                                if bnr == self.bufnr
                                                    call add(marker, '%')
                                                else
                                                    call add(marker, bnr)
                                                endif
                                                if get(bufdef, '&modified', 0)
                                                    call add(marker, '+')
                                                endif
                                                if get(bufdef, '&bufhidden', '') ==# 'hide'
                                                    call add(marker, 'h')
                                                endif
                                                " if !get(bufdef, '&buflisted', 1)
                                                "     call add(marker, 'u')
                                                " endif
                                                " echom "DBG" a:file string(get(self,'filename_indicators'))
                                            endif
                                        endif
                                        if has_key(self, 'filename_indicators') && has_key(self.filename_indicators, a:file)
                                            if len(marker) > 1
                                                call add(marker, '|')
                                            endif
                                            call add(marker, self.filename_indicators[a:file])
                                        endif
                                        if len(marker) <= 1
                                            call add(marker, ' ')
                                        endif
                                        call add(marker, ']')
                                    else
                                        call add(marker, '|')
                                    endif
                                    let markers = join(marker, '')
                                    if !empty(markers)
                                        let dnmax -= len(markers)
                                    endif
                                    if strwidth(dname) > dnmax
                                        let dname = '...'. tlib#string#Strcharpart(dname, len(dname) - dnmax)
                                    endif
                                    return printf('%-*s %s %s',
                                                \ self.width_filename + len(fname) - strwidth(fname),
                                                \ fname, markers, dname)
                                endf
                            
    1              0.000001 endif
                            
                            
                            " :nodoc:
    1              0.000002 function! s:prototype.GetSelectedItems(current) dict abort "{{{3
                                Tlibtrace 'tlib', a:current
                                if stridx(self.type, 'i') != -1
                                    let rv = copy(self.sel_idx)
                                else
                                    let rv = map(copy(self.sel_idx), 'self.GetBaseItem(v:val)')
                                endif
                                if !empty(a:current)
                                    Tlibtrace 'tlib', a:current, rv, type(a:current)
                                    if tlib#type#IsNumber(a:current) || tlib#type#IsString(a:current)
                                        call s:InsertSelectedItems(rv, a:current)
                                    elseif tlib#type#IsList(a:current)
                                        for item in a:current
                                            call s:InsertSelectedItems(rv, item)
                                        endfor
                                    elseif tlib#type#IsDictionary(a:current)
                                        for [inum, item] in items(a:current)
                                            call s:InsertSelectedItems(rv, item)
                                        endfor
                                    endif
                                endif
                                " TAssert empty(rv) || rv[0] == a:current
                                if stridx(self.type, 'i') != -1
                                    if !empty(self.index_table)
                                        Tlibtrace 'tlib', rv, self.index_table
                                        call map(rv, 'self.index_table[v:val - 1]')
                                        Tlibtrace 'tlib', rv
                                    endif
                                endif
                                return rv
                            endf
                            
                            
    1              0.000003 function! s:InsertSelectedItems(rv, current) abort "{{{3
                                let ci = index(a:rv, a:current)
                                if ci != -1
                                    call remove(a:rv, ci)
                                endif
                                call insert(a:rv, a:current)
                            endf
                            
                            
                            " :nodoc:
    1              0.000002 function! s:prototype.SelectItemsByNames(mode, items) dict abort "{{{3
                                for item in a:items
                                    let bi = index(self.base, item) + 1
                                    Tlibtrace 'tlib', item, bi
                                    if bi > 0
                                        let si = index(self.sel_idx, bi)
                                        Tlibtrace 'tlib', self.sel_idx
                                        Tlibtrace 'tlib', si
                                        if si == -1
                                            call add(self.sel_idx, bi)
                                        elseif a:mode ==# 'toggle'
                                            call remove(self.sel_idx, si)
                                        endif
                                    endif
                                endfor
                                return 1
                            endf
                            
                            
                            " :nodoc:
    1              0.000003 function! s:prototype.SelectItem(mode, index) dict abort "{{{3
                                Tlibtrace 'tlib', a:mode, a:index
                                let bi = self.GetBaseIdx(a:index)
                                " if self.RespondTo('MaySelectItem')
                                "     if !self.MaySelectItem(bi)
                                "         return 0
                                "     endif
                                " endif
                                Tlibtrace 'tlib', bi
                                let si = index(self.sel_idx, bi)
                                Tlibtrace 'tlib', self.sel_idx
                                Tlibtrace 'tlib', si
                                if si == -1
                                    call add(self.sel_idx, bi)
                                elseif a:mode ==# 'toggle'
                                    call remove(self.sel_idx, si)
                                endif
                                return 1
                            endf
                            
                            
                            " :nodoc:
    1              0.000002 function! s:prototype.FormatBaseFromData() abort dict "{{{3
                                if has_key(self, 'format_data') && has_key(self, 'data')
                                    let self.base = map(copy(self.data), 'call(self.format_data, [v:val], self)')
                                endif    
                            endf
                            
                            
                            " :nodoc:
    1              0.000002 function! s:prototype.FormatArgs(format_string, arg) dict abort "{{{3
                                let nargs = len(substitute(a:format_string, '%%\|[^%]', '', 'g'))
                                return [a:format_string] + repeat([string(a:arg)], nargs)
                            endf
                            
                            
                            " :nodoc:
    1              0.000002 function! s:prototype.GetRx(filter) dict abort "{{{3
                                return '\('. join(filter(copy(a:filter), 'v:val[0] !=# "!"'), '\|') .'\)' 
                            endf
                            
                            
                            " :nodoc:
    1              0.000002 function! s:prototype.GetRx0(...) dict abort "{{{3
                                exec tlib#arg#Let(['negative'])
                                let rx0 = []
                                for filter in self.filter
                                    Tlibtrace 'tlib', filter
                                    let rx = join(reverse(filter(copy(filter), '!empty(v:val)')), '\|')
                                    Tlibtrace 'tlib', rx
                                    if !empty(rx) && (negative ? rx[0] == g:tlib#input#not : rx[0] != g:tlib#input#not)
                                        call add(rx0, rx)
                                    endif
                                endfor
                                let rx0s = join(rx0, '\|')
                                if empty(rx0s)
                                    return ''
                                else
                                    return self.FilterRxPrefix() .'\('. rx0s .'\)'
                                endif
                            endf
                            
                            
                            " :nodoc:
    1              0.000003 function! s:prototype.FormatName(cache, format, value) dict abort "{{{3
                                Tlibtrace 'tlib', a:format, a:value
                                if has_key(a:cache, a:value)
                                    return a:cache[a:value]
                                else
                                    let world = self
                                    let ftpl = self.FormatArgs(a:format, a:value)
                                    let fn = call(function('printf'), ftpl)
                                    let fmt = eval(fn)
                                    Tlibtrace 'tlib', ftpl, fn, fmt
                                    let a:cache[a:value] = fmt
                                    return fmt
                                endif
                            endf
                            
                            
                            " :nodoc:
    1              0.000002 function! s:prototype.GetItem(idx) dict abort "{{{3
                                return self.list[a:idx - 1]
                            endf
                            
                            
                            " :nodoc:
    1              0.000002 function! s:prototype.GetListIdx(baseidx) dict abort "{{{3
                                " if empty(self.index_table)
                                    let baseidx = a:baseidx
                                " else
                                "     let baseidx = 0 + self.index_table[a:baseidx - 1]
                                "     Tlibtrace 'tlib', a:baseidx, baseidx, self.index_table 
                                " endif
                                let rv = index(self.table, baseidx)
                                Tlibtrace 'tlib', rv, self.table
                                return rv
                            endf
                            
                            
                            " :nodoc:
                            " The first index is 1.
    1              0.000001 function! s:prototype.GetBaseIdx(idx) dict abort "{{{3
                                Tlibtrace 'tlib', a:idx, self.table, self.index_table
                                if !empty(self.table) && a:idx > 0 && a:idx <= len(self.table)
                                    return self.table[a:idx - 1]
                                else
                                    return 0
                                endif
                            endf
                            
                            
                            " :nodoc:
    1              0.000002 function! s:prototype.GetBaseIdx0(idx) dict abort "{{{3
                                let idx0 = self.GetBaseIdx(a:idx) - 1
                                if idx0 < 0
                                    call tlib#notify#Echo('TLIB: Internal Error: GetBaseIdx0: idx0 < 0', 'WarningMsg')
                                endif
                                return idx0
                            endf
                            
                            
                            " :nodoc:
    1              0.000002 function! s:prototype.GetBaseItem(idx) dict abort "{{{3
                                return self.base[a:idx - 1]
                            endf
                            
                            
                            " :nodoc:
    1              0.000002 function! s:prototype.SetBaseItem(idx, item) dict abort "{{{3
                                let self.base[a:idx - 1] = a:item
                            endf
                            
                            
                            " :nodoc:
    1              0.000002 function! s:prototype.GetLineIdx(lnum) dict abort "{{{3
                                let line = getline(a:lnum)
                                let prefidx = substitute(matchstr(line, '^\d\+\ze[*:]'), '^0\+', '', '')
                                return prefidx
                            endf
                            
                            
                            " :nodoc:
    1              0.000002 function! s:prototype.SetPrefIdx() dict abort "{{{3
                                " let pref = sort(range(1, self.llen), 'self.SortPrefs')
                                " let self.prefidx = get(pref, 0, self.initial_index)
                                let pref_idx = -1
                                let pref_weight = -1
                                Tlibtrace 'tlib', self.filter_pos, self.filter_neg
                                let t0 = localtime()
                                for idx in range(1, self.llen)
                                    let item = self.GetItem(idx)
                                    let weight = self.matcher.AssessName(self, item)
                                    Tlibtrace 'tlib', item, weight
                                    if weight > pref_weight
                                        let pref_idx = idx
                                        let pref_weight = weight
                                    endif
                                endfor
                                Tlibtrace 'tlib', localtime() - t0
                                Tlibtrace 'tlib', pref_idx
                                if pref_idx == -1
                                    let self.prefidx = self.initial_index
                                else
                                    let self.prefidx = pref_idx
                                endif
                            endf
                            
                            
                            " " :nodoc:
                            " function! s:prototype.GetCurrentItem() dict abort "{{{3
                            "     let idx = self.prefidx
                            "     Tlibtrace 'tlib', idx
                            "     if stridx(self.type, 'i') != -1
                            "         return idx
                            "     elseif !empty(self.list)
                            "         if len(self.list) >= idx
                            "             let idx1 = idx - 1
                            "             let rv = self.list[idx - 1]
                            "             Tlibtrace 'tlib', idx, idx1, rv, self.list
                            "             return rv
                            "         endif
                            "     else
                            "         return ''
                            "     endif
                            " endf
                            
                            
                            " :nodoc:
    1              0.000002 function! s:prototype.CurrentItem() dict abort "{{{3
                                if stridx(self.type, 'i') != -1
                                    return self.GetBaseIdx(self.llen == 1 ? 1 : self.prefidx)
                                else
                                    if self.llen == 1
                                        Tlibtrace 'tlib', self.llen
                                        return self.list[0]
                                    elseif self.prefidx > 0
                                        Tlibtrace 'tlib', self.prefidx
                                        " return self.GetCurrentItem()
                                        if len(self.list) >= self.prefidx
                                            let rv = self.list[self.prefidx - 1]
                                            Tlibtrace 'tlib', self.prefidx, len(self.list), rv
                                            return rv
                                        endif
                                    else
                                        return ''
                                    endif
                                endif
                            endf
                            
                            
                            " :nodoc:
    1              0.000001 function! s:prototype.FilterRxPrefix() dict abort "{{{3
                                return self.matcher.FilterRxPrefix()
                            endf
                            
                            
                            " :nodoc:
    1              0.000001 function! s:prototype.SetFilter() dict abort "{{{3
                                " let mrx = '\V'. (a:0 >= 1 && a:1 ? '\C' : '')
                                let mrx = self.FilterRxPrefix() . self.filter_options
                                let self.filter_pos = []
                                let self.filter_neg = []
                                Tlibtrace 'tlib', mrx, self.filter
                                for filter in self.filter
                                    Tlibtrace 'tlib', filter
                                    let rx = join(reverse(filter(copy(filter), '!empty(v:val)')), '\|')
                                    Tlibtrace 'tlib', rx
                                    if !empty(rx)
                                        if rx =~# '\u'
                                            let mrx1 = mrx .'\C'
                                        else
                                            let mrx1 = mrx
                                        endif
                                        Tlibtrace 'tlib', rx
                                        if rx[0] == g:tlib#input#not
                                            if len(rx) > 1
                                                call add(self.filter_neg, mrx1 .'\('. rx[1:-1] .'\)')
                                            endif
                                        else
                                            call add(self.filter_pos, mrx1 .'\('. rx .'\)')
                                        endif
                                    endif
                                endfor
                                Tlibtrace 'tlib', self.filter_pos, self.filter_neg
                            endf
                            
                            
                            " :nodoc:
    1              0.000002 function! s:prototype.IsValidFilter() dict abort "{{{3
                                let last = self.FilterRxPrefix() .'\('. self.filter[0][0] .'\)'
                                Tlibtrace 'tlib', last
                                Tlibtrace 'tlib', last
                                try
                                    let a = match('', last)
                                    return 1
                                catch
                                    Tlibtrace 'tlib', v:exception
                                    return 0
                                endtry
                            endf
                            
                            
                            " :nodoc:
    1              0.000001 function! s:prototype.SetMatchMode(match_mode) dict abort "{{{3
                                Tlibtrace 'tlib', a:match_mode
                                if !empty(a:match_mode)
                                    unlet self.matcher
                                    try
                                        let self.matcher = tlib#Filter_{a:match_mode}#New()
                                        call self.matcher.Init(self)
                                    catch /^Vim\%((\a\+)\)\=:E117/
                                        throw 'tlib: Unknown mode for tlib#input#filter_mode: '. a:match_mode
                                    endtry
                                endif
                            endf
                            
                            
                            " function! s:prototype.Match(text) dict abort "{{{3
                            "     return self.matcher.Match(self, text)
                            " endf
                            
                            
                            " :nodoc:
    1              0.000002 function! s:prototype.MatchBaseIdx(idx) dict abort "{{{3
                                let text = self.GetBaseItem(a:idx)
                                if !empty(self.filter_format)
                                    let text = self.FormatName(self.fmt_filter, self.filter_format, text)
                                endif
                                Tlibtrace 'tlib', text
                                " return self.Match(text)
                                return self.matcher.Match(self, text)
                            endf
                            
                            
                            " :nodoc:
    1              0.000001 function! s:prototype.BuildTableList() dict abort "{{{3
                                let time0 = str2float(reltimestr(reltime()))
                                Tlibtrace 'tlib', time0
                                call self.SetFilter()
                                Tlibtrace 'tlib', self.filter_neg, self.filter_pos
                                let self.table = range(1, len(self.base))
                                Tlibtrace 'tlib', self.filtered_items
                                let copy_base = 1
                                if !empty(self.filtered_items)
                                    let self.table = filter(self.table, 'index(self.filtered_items, v:val) != -1')
                                    let copy_base = 0
                                endif
                                if !empty(self.filter_pos) || !empty(self.filter_neg)
                                    let self.table = filter(self.table, 'self.MatchBaseIdx(v:val)')
                                    let copy_base = 0
                                endif
                                if copy_base
                                    let self.list = copy(self.base)
                                else
                                    let self.list  = map(copy(self.table), 'self.GetBaseItem(v:val)')
                                endif
                            endf
                            
                            
                            " :nodoc:
    1              0.000001 function! s:prototype.ReduceFilter() dict abort "{{{3
                                Tlibtrace 'tlib', self.filter
                                let reduced = 0
                                while !reduced
                                    if self.filter[0] == [''] && len(self.filter) > 1
                                        call remove(self.filter, 0)
                                    elseif empty(self.filter[0][0]) && len(self.filter[0]) > 1
                                        call remove(self.filter[0], 0)
                                    else
                                        call self.matcher.ReduceFrontFilter(self)
                                    endif
                                    if self.IsValidFilter()
                                        let reduced = 1
                                    endif
                                endwh
                            endf
                            
                            
                            " :nodoc:
                            " filter is either a string or a list of list of strings.
    1              0.000002 function! s:prototype.SetInitialFilter(filter) dict abort "{{{3
                                " let self.initial_filter = [[''], [a:filter]]
                                Tlibtrace 'tlib', a:filter
                                if type(a:filter) == 3
                                    let self.initial_filter = deepcopy(a:filter)
                                else
                                    let self.initial_filter = [[a:filter]]
                                endif
                            endf
                            
                            
                            " :nodoc:
    1              0.000001 function! s:prototype.PopFilter() dict abort "{{{3
                                Tlibtrace 'tlib', self.filter
                                if len(self.filter[0]) > 1
                                    call remove(self.filter[0], 0)
                                elseif len(self.filter) > 1
                                    call remove(self.filter, 0)
                                else
                                    let self.filter[0] = ['']
                                endif
                            endf
                            
                            
                            " :nodoc:
    1              0.000002 function! s:prototype.FilterIsEmpty() dict abort "{{{3
                                Tlibtrace 'tlib', self.filter
                                return self.filter == copy(self.initial_filter)
                            endf
                            
                            
                            " :nodoc:
    1              0.000002 function! s:prototype.DisplayFilter() dict abort "{{{3
                                let filter1 = copy(self.filter)
                                call filter(filter1, 'v:val != [""]')
                                Tlibtrace 'tlib', self.matcher['_class']
                                let rv = self.matcher.DisplayFilter(filter1)
                                let rv = self.CleanFilter(rv)
                                return rv
                            endf
                            
                            
                            " :nodoc:
    1              0.000002 function! s:prototype.SetFrontFilter(pattern) dict abort "{{{3
                                call self.matcher.SetFrontFilter(self, a:pattern)
                            endf
                            
                            
                            " :nodoc:
    1              0.000002 function! s:prototype.PushFrontFilter(char) dict abort "{{{3
                                call self.matcher.PushFrontFilter(self, a:char)
                            endf
                            
                            
                            " :nodoc:
    1              0.000002 function! s:prototype.CleanFilter(filter) dict abort "{{{3
                                return self.matcher.CleanFilter(a:filter)
                            endf
                            
                            
                            " :nodoc:
    1              0.000001 function! s:prototype.UseScratch() dict abort "{{{3
                                " if type(self.scratch) != 0 && get(self, 'buffer_local', 1)
                                "     if self.scratch != fnamemodify(self.scratch, ':p')
                                "         let self.scratch = tlib#file#Join([expand('%:p:h'), self.scratch])
                                "         Tlibtrace 'tlib', self.scratch
                                "     endif
                                "     " let self.scratch_hidden = 'wipe'
                                " endif
                                keepjumps keepalt let rv = tlib#scratch#UseScratch(self)
                                " if expand('%:t') == self.scratch
                                    let b:tlib_world = self
                                " endif
                                return rv
                            endf
                            
                            
                            " :nodoc:
    1              0.000002 function! s:prototype.CloseScratch(...) dict abort "{{{3
                                TVarArg ['reset_scratch', 0]
                                " TVarArg ['reset_scratch', 1]
                                Tlibtrace 'tlib', reset_scratch
                                if self.sticky
                                    return 0
                                else
                                    let rv = tlib#scratch#CloseScratch(self, reset_scratch)
                                    Tlibtrace 'tlib', rv
                                    if rv
                                        call self.SwitchWindow('win')
                                    endif
                                    return rv
                                endif
                            endf
                            
                            
                            " :nodoc:
    1              0.000001 function! s:prototype.Initialize() dict abort "{{{3
                                let self.initialized = 1
                                call self.SetOrigin(1)
                                call self.Reset(1)
                                if !empty(self.cache_var) && exists(self.cache_var)
                                    for prop in self.restore_from_cache
                                        exec 'let self[prop] = get('. self.cache_var .', prop, self[prop])'
                                    endfor
                                    exec 'unlet '. self.cache_var
                                endif
                            endf
                            
                            
                            " :nodoc:
    1              0.000001 function! s:prototype.Leave() dict abort "{{{3
                                if !empty(self.cache_var)
                                    exec 'let '. self.cache_var .' = self'
                                endif
                                for handler in self.on_leave
                                    call call(handler, [self])
                                endfor
                            endf
                            
                            
                            " :nodoc:
    1              0.000001 function! s:prototype.UseInputListScratch() dict abort "{{{3
                                let scratch = self.UseScratch()
                                if !exists('b:tlib_list_init')
                                    call tlib#autocmdgroup#Init()
                                    autocmd TLib VimResized <buffer> call feedkeys("\<c-j>", 't')
                                    " autocmd TLib WinLeave <buffer> let b:tlib_world_event = 'WinLeave' | call feedkeys("\<c-j>", 't')
                                    let b:tlib_list_init = 1
                                endif
                                if !exists('w:tlib_list_init')
                                    Tlibtrace 'tlib', scratch
                                    if has_key(self, 'index_next_syntax')
                                        if type(self.index_next_syntax) == 1
                                            exec 'syntax match InputlListIndex /^\d\+:\s/ nextgroup='. self.index_next_syntax
                                        elseif type(self.index_next_syntax) == 4
                                            for [n, nsyn] in items(self.index_next_syntax)
                                                let fn = printf('%0'. world.index_width .'d', n)
                                                exec 'syntax match InputlListIndex /^'. fn .':\s/ nextgroup='. nsyn
                                            endfor
                                        endif
                                    else
                                        syntax match InputlListIndex /^\d\+:\s/
                                    endif
                                    call tlib#hook#Run('tlib_UseInputListScratch', self)
                                    syntax match InputlListCursor /^\d\+\* .*$/ contains=InputlListIndex
                                    syntax match InputlListSelected /^\d\+# .*$/ contains=InputlListIndex
                                    hi def link InputlListIndex Constant
                                    hi def link InputlListCursor Search
                                    hi def link InputlListSelected IncSearch
                                    setlocal nowrap
                                    " hi def link InputlListIndex Special
                                    " let b:tlibDisplayListMarks = {}
                                    let b:tlibDisplayListMarks = []
                                    let b:tlibDisplayListWorld = self
                                    let w:tlib_list_init = 1
                                endif
                                return scratch
                            endf
                            
                            
                            " s:prototype.Reset(?initial=0)
                            " :nodoc:
    1              0.000002 function! s:prototype.Reset(...) dict abort "{{{3
                                TVarArg ['initial', 0]
                                Tlibtrace 'tlib', initial
                                Tlibtrace 'tlib', initial, self.initial_filter
                                let self.state     = 'display'
                                let self.offset    = 1
                                let self.filter    = deepcopy(self.initial_filter)
                                let self.idx       = ''
                                let self.prefidx   = 0
                                let self.initial_display = 1
                                let self.fmt_display = {}
                                let self.fmt_filter = {}
                                call self.UseInputListScratch()
                                call self.ResetSelected()
                                call self.Retrieve(!initial)
                                call self.FormatBaseFromData()
                                return self
                            endf
                            
                            
                            " :nodoc:
    1              0.000001 function! s:prototype.ResetSelected() dict abort "{{{3
                                let self.sel_idx   = []
                            endf
                            
                            
                            " :nodoc:
    1              0.000002 function! s:prototype.Retrieve(anyway) dict abort "{{{3
                                Tlibtrace 'tlib', a:anyway, self.base
                                if (a:anyway || empty(self.base))
                                    let ra = self.retrieve_eval
                                    Tlibtrace 'tlib', ra
                                    if !empty(ra)
                                        let back  = self.SwitchWindow('win')
                                        let world = self
                                        let self.base = eval(ra)
                                        Tlibtrace 'tlib', self.base
                                        exec back
                                        return 1
                                    endif
                                endif
                                return 0
                            endf
                            
                            
    1              0.000002 function! s:FormatHelp(help) abort "{{{3
                                Tlibtrace 'tlib', a:help
                                let max = [0, 0]
                                for item in a:help
                                    Tlibtrace 'tlib', item
                                    if type(item) == 3
                                        let itemlen = map(copy(item), 'strwidth(v:val)')
                                        Tlibtrace 'tlib', itemlen
                                        let max = map(range(2), 'max[v:val] >= itemlen[v:val] ? max[v:val] : itemlen[v:val]')
                                    endif
                                    unlet item
                                endfor
                                Tlibtrace 'tlib', max
                                let cols = float2nr((winwidth(0) - &foldcolumn - 1) / (max[0] + max[1] + 2))
                                if cols < 1
                                    let cols = 1
                                endif
                                let fmt = printf('%%%ds: %%-%ds', max[0], max[1])
                                Tlibtrace 'tlib', cols, fmt
                                let help = []
                                let idx = -1
                                let maxidx = len(a:help)
                                while idx < maxidx
                                    let push_item = 0
                                    let accum = []
                                    for i in range(cols)
                                        let idx += 1
                                        if idx >= maxidx
                                            break
                                        endif
                                        let item = a:help[idx]
                                        if type(item) == 3
                                            call add(accum, item)
                                        else
                                            let push_item = 1
                                            break
                                        endif
                                        unlet item
                                    endfor
                                    if !empty(accum)
                                        call add(help, s:FormatHelpItem(accum, fmt))
                                    endif
                                    if push_item
                                        call add(help, a:help[idx])
                                    endif
                                endwh
                                Tlibtrace 'tlib', help
                                return help
                            endf
                            
                            
    1              0.000003 function! s:FormatHelpItem(item, fmt) abort "{{{3
                                let args = [join(repeat([a:fmt], len(a:item)), '  ')]
                                for item in a:item
                                    Tlibtrace 'tlib', item
                                    let args += item
                                endfor
                                Tlibtrace 'tlib', args
                                return call('printf', args)
                            endf
                            
                            
                            " :nodoc:
    1              0.000002 function! s:prototype.InitHelp() dict abort "{{{3
                                return []
                            endf
                            
                            
                            " :nodoc:
    1              0.000002 function! s:prototype.PushHelp(...) dict abort "{{{3
                                Tlibtrace 'tlib', a:000
                                if a:0 == 1
                                    if type(a:1) == 3
                                        let self.temp_lines += a:1
                                    else
                                        call add(self.temp_lines, a:1)
                                    endif
                                elseif a:0 == 2
                                    call add(self.temp_lines, a:000)
                                else
                                    throw 'TLIB: PushHelp: Wrong number of arguments: '. string(a:000)
                                endif
                                Tlibtrace 'tlib', helpstring
                            endf
                            
                            
                            " :nodoc:
    1              0.000002 function! s:prototype.DisplayHelp() dict abort "{{{3
                                let self.temp_lines = self.InitHelp()
                                call self.PushHelp('<Esc>', self.key_mode == 'default' ? 'Abort' : 'Reset keymap')
                                call self.PushHelp('Enter, <cr>', 'Pick the current item')
                                call self.PushHelp('Mouse', 'L: Pick item, R: Show menu')
                                call self.PushHelp('<M-Number>',  'Select an item')
                                call self.PushHelp('<BS>, <C-BS>', 'Reduce filter')
                                call self.PushHelp('<Tab>', 'Complete word')
                                call self.PushHelp('<S-Esc>, <F10>', 'Enter command')
                            
                                if self.key_mode == 'default'
                                    call self.PushHelp('<C|M-r>',      'Reset the display')
                                    call self.PushHelp('Up/Down',      'Next/previous item')
                                    call self.PushHelp('<C|M-q>',      'Edit top filter string')
                                    call self.PushHelp('Page Up/Down', 'Scroll')
                                    call self.PushHelp('<S-Space>',    'Enter * Wildcard')
                                    if self.allow_suspend
                                        call self.PushHelp('<C|M-z>', 'Suspend/Resume')
                                        call self.PushHelp('<C-o>', 'Switch to origin')
                                    endif
                                    if stridx(self.type, 'm') != -1
                                        call self.PushHelp('<S-Up/Down>', '(Un)Select items')
                                        call self.PushHelp('#', '(Un)Select the current item')
                                        call self.PushHelp('<C|M-a>', '(Un)Select all items')
                                        call self.PushHelp('<F9>', '(Un)Restrict view to selection')
                                        " \ '<c-\>        ... Show only selected',
                                    endif
                                endif
                            
                                Tlibtrace 'tlib', len(self.temp_lines)
                                call self.matcher.Help(self)
                            
                                Tlibtrace 'tlib', self.key_mode
                                for handler in values(self.key_map[self.key_mode])
                                    Tlibtrace 'tlib', handler
                                    let key = get(handler, 'key_name', '')
                                    Tlibtrace 'tlib', key
                                    if !empty(key)
                                        let desc = get(handler, 'help', '')
                                        if empty(desc)
                                            let desc = get(handler, 'agent', '')
                                        endif
                                        call self.PushHelp(key, desc)
                                    endif
                                endfor
                            
                                if !has_key(self.key_map[self.key_mode], 'unknown_key')
                                    call self.PushHelp('Letter', 'Filter the list')
                                endif
                            
                                if self.key_mode == 'default' && !empty(self.help_extra)
                                    call self.PushHelp(self.help_extra)
                                endif
                            
                                Tlibtrace 'tlib', len(self.temp_lines)
                                call self.PushHelp([
                                            \ '',
                                            \ 'Matches at word boundaries are prioritized.',
                                            \ ])
                                let self.temp_lines = s:FormatHelp(self.temp_lines)
                                call self.PrintLines()
                            endf
                            
                            
    1              0.000004 function! s:prototype.PrintLines() dict abort "{{{3
                                let self.temp_prompt = ['Press any key to continue.', 'Question']
                                call tlib#buffer#DeleteRange('1', '$')
                                call append(0, self.temp_lines)
                                call tlib#buffer#DeleteRange('$', '$')
                                1
                                call self.Resize(len(self.temp_lines), 0)
                                let self.temp_lines = []
                            endf
                            
                            
                            " :nodoc:
    1              0.000003 function! s:prototype.Resize(hsize, vsize) dict abort "{{{3
                                Tlibtrace 'tlib', self.scratch_vertical, a:hsize, a:vsize
                                let world_resize = ''
                                let winpos = ''
                                let scratch_split = get(self, 'scratch_split', 1)
                                Tlibtrace 'tlib', scratch_split
                                if scratch_split > 0
                                    if self.scratch_vertical
                                        if a:vsize
                                            let world_resize = 'vert resize '. a:vsize
                                            let winpos = tlib#fixes#Winpos()
                                            " let w:winresize = {'v': a:vsize}
                                            " setlocal winfixwidth
                                        endif
                                    else
                                        if a:hsize
                                            let world_resize = 'resize '. a:hsize
                                            " let w:winresize = {'h': a:hsize}
                                            " setlocal winfixheight
                                        endif
                                    endif
                                endif
                                if !empty(world_resize)
                                    Tlibtrace 'tlib', world_resize, winpos
                                    setlocal nowinfixheight
                                    setlocal nowinfixwidth
                                    exec world_resize
                                    setlocal winfixheight
                                    setlocal winfixwidth
                                    if !empty(winpos)
                                        exec winpos
                                    endif
                                    " redraw!
                                endif
                            endf
                            
                            
                            " :nodoc:
    1              0.000002 function! s:prototype.GetResize(size) dict abort "{{{3
                                let resize0 = get(self, 'resize', 0)
                                let resize = empty(resize0) ? 0 : eval(resize0)
                                Tlibtrace 'tlib', resize0, resize
                                let resize = resize == 0 ? a:size : min([a:size, resize])
                                " let min = self.scratch_vertical ? &cols : &lines
                                let min1 = (self.scratch_vertical ? self.win_width : self.win_height) * g:tlib_inputlist_pct
                                let min2 = (self.scratch_vertical ? &columns : &lines) * self.win_pct
                                let min3 = &previewheight
                                let min = max([min1, min2])
                                let ns = [resize, (min / 100)]
                                let maxn = self.scratch_vertical ? g:tlib_inputlist_max_cols : g:tlib_inputlist_max_lines
                                if maxn > 0
                                    call add(ns, maxn)
                                endif
                                let resize = min(ns)
                                Tlibtrace 'tlib', resize, a:size, min, min1, min2
                                return resize
                            endf
                            
                            
                            " function! s:prototype.DisplayList(?query=self.Query(), ?list=[])
                            " :nodoc:
    1              0.000002 function! s:prototype.DisplayList(...) dict abort "{{{3
                                Tlibtrace 'tlib', self.state
                                let query = a:0 >= 1 ? a:1 : self.Query()
                                let list = a:0 >= 2 ? a:2 : []
                                Tlibtrace 'tlib', query, len(list)
                                call self.UseScratch()
                                Tlibtrace 'tlib', self.scratch
                                " TAssert IsNotEmpty(self.scratch)
                                if self.state == 'scroll'
                                    call self.ScrollToOffset()
                                elseif self.state == 'help'
                                    call self.DisplayHelp()
                                    call self.SetStatusline(query)
                                elseif self.state == 'printlines'
                                    call self.PrintLines()
                                    call self.SetStatusline(query)
                                else
                                    Tlibtrace 'tlib', query
                                    " let ll = len(list)
                                    let ll = self.llen
                                    " let x  = len(ll) + 1
                                    let x  = self.index_width + 1
                                    Tlibtrace 'tlib', ll
                                    if self.state =~ '\<display\>'
                                        call self.Resize(self.GetResize(ll), eval(get(self, 'resize_vertical', 0)))
                                        call tlib#normal#WithRegister('gg"tdG', 't')
                                        let lines = copy(list)
                                        let lines = map(lines, 'substitute(v:val, ''[[:cntrl:][:space:]]'', " ", "g")')
                                        let w = winwidth(0) - &fdc
                                        " let w = winwidth(0) - &fdc - 1
                                        let lines = map(lines, 'printf("%-'. w .'.'. w .'S", v:val)')
                                        Tlibtrace 'tlib', lines
                                        call append(0, lines)
                                        call tlib#normal#WithRegister('G"tddgg', 't')
                                    endif
                                    Tlibtrace 'tlib', self.prefidx
                                    let base_pref = self.GetBaseIdx(self.prefidx)
                                    Tlibtrace 'tlib', base_pref
                                    if self.state =~ '\<redisplay\>'
                                        call filter(b:tlibDisplayListMarks, 'index(self.sel_idx, v:val) == -1 && v:val != base_pref')
                                        Tlibtrace 'tlib', b:tlibDisplayListMarks
                                        call map(b:tlibDisplayListMarks, 'self.DisplayListMark(x, v:val, ":")')
                                        " let b:tlibDisplayListMarks = map(copy(self.sel_idx), 'self.DisplayListMark(x, v:val, "#")')
                                        " call add(b:tlibDisplayListMarks, self.prefidx)
                                        " call self.DisplayListMark(x, self.GetBaseIdx(self.prefidx), '*')
                                    endif
                                    let b:tlibDisplayListMarks = map(copy(self.sel_idx), 'self.DisplayListMark(x, v:val, "#")')
                                    call add(b:tlibDisplayListMarks, base_pref)
                                    call self.DisplayListMark(x, base_pref, '*')
                                    call self.SetOffset()
                                    call self.SetStatusline(query)
                                    Tlibtrace 'tlib', self.offset
                                    call self.ScrollToOffset()
                                    let rx0 = self.GetRx0()
                                    Tlibtrace 'tlib', rx0
                                    if !empty(self.matcher.highlight)
                                        if empty(rx0)
                                            match none
                                        elseif self.IsValidFilter()
                                            if has_key(self, 'Highlighter')
                                                call self.Highlighter(rx0)
                                            else
                                                exec 'match '. self.matcher.highlight .' /\c'. escape(rx0, '/') .'/'
                                            endif
                                        endif
                                    endif
                                endif
                                redraw
                            endf
                            
                            
                            " :nodoc:
    1              0.000002 function! s:prototype.SetStatusline(query) dict abort "{{{3
                                Tlibtrace 'tlib', a:query
                                if !empty(self.temp_prompt)
                                    let echo = get(self.temp_prompt, 0, '')
                                    let hl = get(self.temp_prompt, 1, 'Normal')
                                    let self.temp_prompt = []
                                else
                                    let hl = 'Normal'
                                    let query   = a:query
                                    let options = [self.matcher.name]
                                    if self.sticky
                                        call add(options, '#')
                                    endif
                                    if self.key_mode != 'default'
                                        call add(options, 'map:'. self.key_mode)
                                    endif
                                    if !empty(self.filtered_items)
                                        if g:tlib_inputlist_shortmessage
                                            call add(options, 'R')
                                        else
                                            call add(options, 'restricted')
                                        endif
                                    endif
                                    if !empty(options)
                                        let sopts = printf('[%s]', join(options, ', '))
                                        " let echo  = query . repeat(' ', &columns - len(sopts) - len(query) - 20) . sopts
                                        let echo  = query . '  ' . sopts
                                        " let query .= '%%='. sopts .' '
                                    endif
                                    Tlibtrace 'tlib', &l:statusline, query
                                    " let &l:statusline = query
                                endif
                                echo
                                if hl != 'Normal'
                                    exec 'echohl' hl
                                    echo echo
                                    echohl None
                                else
                                    echo echo
                                endif
                            endf
                            
                            
                            " :nodoc:
    1              0.000002 function! s:prototype.Query() dict abort "{{{3
                                let flt = self.DisplayFilter()
                                if g:tlib_inputlist_shortmessage
                                    let query = 'Filter: '. flt
                                else
                                    let query = self.query .' (filter: '. flt .'; press <F1> for help)'
                                endif
                                return query
                            endf
                            
                            
                            " :nodoc:
    1              0.000002 function! s:prototype.ScrollToOffset() dict abort "{{{3
                                Tlibtrace 'tlib', self.scratch_vertical, self.llen, winheight(0)
                                exec 'norm! '. self.offset .'zt'
                            endf
                            
                            
                            " :nodoc:
    1              0.000001 function! s:prototype.SetOffset() dict abort "{{{3
                                Tlibtrace 'tlib', self.prefidx, self.offset
                                let listtop = len(self.list) - winheight(0) + 1
                                if listtop < 1
                                    let listtop = 1
                                endif
                                if self.prefidx > listtop
                                    let self.offset = listtop
                                elseif self.prefidx > self.offset + winheight(0) - 1
                                    let listoff = self.prefidx - winheight(0) + 1
                                    let self.offset = min([listtop, listoff])
                                "     TLogVAR self.prefidx
                                "     TLogVAR listtop, listoff, self.offset
                                elseif self.prefidx < self.offset
                                    let self.offset = self.prefidx
                                endif
                                Tlibtrace 'tlib', self.offset
                            endf
                            
                            
                            " :nodoc:
    1              0.000002 function! s:prototype.ClearAllMarks() dict abort "{{{3
                                let x = self.index_width + 1
                                call map(range(1, line('$')), 'self.DisplayListMark(x, v:val, ":")')
                            endf
                            
                            
                            " :nodoc:
    1              0.000002 function! s:prototype.MarkCurrent(y) dict abort "{{{3
                                let x = self.index_width + 1
                                call self.DisplayListMark(x, a:y, '*')
                            endf
                            
                            
                            " :nodoc:
    1              0.000002 function! s:prototype.DisplayListMark(x, y, mark) dict abort "{{{3
                                Tlibtrace 'tlib', a:y, a:mark
                                if a:x > 0 && a:y >= 0
                                    let sy = self.GetListIdx(a:y) + 1
                                    Tlibtrace 'tlib', sy
                                    if sy >= 1
                                        call setpos('.', [0, sy, a:x, 0])
                                        exec 'norm! r'. a:mark
                                        " exec 'norm! '. a:y .'gg'. a:x .'|r'. a:mark
                                    endif
                                endif
                                return a:y
                            endf
                            
                            
                            " :nodoc:
    1              0.000002 function! s:prototype.SwitchWindow(where) dict abort "{{{3
                                " if self.tabpagenr != tabpagenr()
                                "     call tlib#tab#Set(self.tabpagenr)
                                " endif
                                " let wnr = get(self, a:where.'_wnr')
                                " Tlibtrace 'tlib', self, wnr
                                " return tlib#win#Set(wnr)
                                return tlib#win#SetById(self[a:where .'_id'])
                            endf
                            
                            
                            " :nodoc:
    1              0.000002 function! s:prototype.FollowCursor() dict abort "{{{3
                                if !empty(self.follow_cursor)
                                    let back = self.SwitchWindow('win')
                                    Tlibtrace 'tlib', back
                                    try
                                        call call(self.follow_cursor, [self, [self.CurrentItem()]])
                                    finally
                                        exec back
                                    endtry
                                endif
                            endf
                            
                            
                            " :nodoc:
    1              0.000002 function! s:prototype.SetOrigin(...) dict abort "{{{3
                                TVarArg ['winview', 0]
                                Tlibtrace 'tlib', 'SetOrigin', self.win_id, self.bufnr, bufnr('%'), winnr()
                                let self.win_wnr = winnr()
                                let self.win_id = tlib#win#GetID()
                                let self.win_height = winheight(self.win_wnr)
                                let self.win_width = winwidth(self.win_wnr)
                                Tlibtrace 'tlib', 'SetOrigin', self.win_id, self.win_height, self.win_width, bufnr('%'), winnr()
                                let self.bufnr   = bufnr('%')
                                let self.tabpagenr = tabpagenr()
                                let self.cursor  = getpos('.')
                                if winview
                                    let self.winview = tlib#win#GetLayout()
                                endif
                                Tlibtrace 'tlib', 'SetOrigin', self.win_id, self.bufnr, self.winview
                                return self
                            endf
                            
                            
                            " :nodoc:
    1              0.000002 function! s:prototype.RestoreWindow(...) dict abort "{{{3
                                TVarArg ['winview', 0]
                                if winview
                                    Tlibtrace 'tlib', winview
                                    call tlib#win#SetLayout(self.winview)
                                endif
                                call tlib#win#GotoID(self.win_id)
                            endf
                            
                            
                            " :nodoc:
    1              0.000001 function! s:prototype.RestoreOrigin(...) dict abort "{{{3
                                call call(self.RestoreWindow, a:000)
                                if bufnr('%') != self.bufnr
                                    exec 'buffer! '. self.bufnr
                                    call setpos('.', self.cursor)
                                endif
                            endf
                            
                            
    1              0.000002 function! s:prototype.Suspend() dict abort "{{{3
                                call tlib#agent#Suspend(self, self.rv)
                            endf
                            

SCRIPT  /Users/brettmz-admin/dev_trees/myvim/bundle/tlib_vim/autoload/tlib/Object.vim
Sourced 1 time
Total time:   0.000179
 Self time:   0.000179

count  total (s)   self (s)
                            " @Author:      Tom Link (micathom AT gmail com?subject=[vim])
                            " @Website:     http://www.vim.org/account/profile.php?user_id=4037
                            " @License:     GPL (see http://www.gnu.org/licenses/gpl.txt)
                            " @Revision:    127
                            
                            " :filedoc:
                            " Provides a prototype plus some OO-like methods.
                            
    1              0.000005 let s:id_counter = 0
    1              0.000007 let s:prototype  = {'_class': ['object'], '_super': [], '_id': 0} "{{{2
                            
                            " :def: function! tlib#Object#New(?fields={})
                            " This function creates a prototype that provides some kind of 
                            " inheritance mechanism and a way to call parent/super methods.
                            "
                            " The usage demonstrated in the following example works best when every 
                            " class/prototype is defined in a file of its own.
                            "
                            " The reason for why there is a dedicated constructor function is that 
                            " this layout facilitates the use of templates and that methods are 
                            " hidden from the user. Other solutions are possible.
                            "
                            " EXAMPLES: >
                            "     let s:prototype = tlib#Object#New({
                            "                 \ '_class': ['FooBar'],
                            "                 \ 'foo': 1, 
                            "                 \ 'bar': 2, 
                            "                 \ })
                            "     " Constructor
                            "     function! FooBar(...)
                            "         let object = s:prototype.New(a:0 >= 1 ? a:1 : {})
                            "         return object
                            "     endf
                            "     function! s:prototype.babble() {
                            "       echo "I think, therefore I am ". (self.foo * self.bar) ." months old."
                            "     }
                            "
                            " < This could now be used like this: >
                            "     let myfoo = FooBar({'foo': 3})
                            "     call myfoo.babble()
                            "     => I think, therefore I am 6 months old.
                            "     echo myfoo.IsA('FooBar')
                            "     => 1
                            "     echo myfoo.IsA('object')
                            "     => 1
                            "     echo myfoo.IsA('Foo')
                            "     => 0
                            "     echo myfoo.RespondTo('babble')
                            "     => 1
                            "     echo myfoo.RespondTo('speak')
                            "     => 0
    1              0.000003 function! tlib#Object#New(...) "{{{3
                                return s:prototype.New(a:0 >= 1 ? a:1 : {})
                            endf
                            
                            
    1              0.000003 function! s:prototype.New(...) dict "{{{3
                                let object = deepcopy(self)
                                let s:id_counter += 1
                                let object._id = s:id_counter
                                if a:0 >= 1 && !empty(a:1)
                                    " call object.Extend(deepcopy(a:1))
                                    call object.Extend(a:1)
                                endif
                                return object
                            endf
                            
                            
    1              0.000003 function! s:prototype.Inherit(object) dict "{{{3
                                let class = copy(self._class)
                                " TLogVAR class
                                let objid = self._id
                                for c in get(a:object, '_class', [])
                                    " TLogVAR c
                                    if index(class, c) == -1
                                        call add(class, c)
                                    endif
                                endfor
                                call extend(self, a:object, 'keep')
                                let self._class = class
                                " TLogVAR self._class
                                let self._id    = objid
                                " let self._super = [super] + self._super
                                call insert(self._super, a:object)
                                return self
                            endf
                            
                            
    1              0.000002 function! s:prototype.Extend(dictionary) dict "{{{3
                                let super = copy(self)
                                let class = copy(self._class)
                                " TLogVAR class
                                let objid = self._id
                                let thisclass = get(a:dictionary, '_class', [])
                                for c in type(thisclass) == 3 ? thisclass : [thisclass]
                                    " TLogVAR c
                                    if index(class, c) == -1
                                        call add(class, c)
                                    endif
                                endfor
                                call extend(self, a:dictionary)
                                let self._class = class
                                " TLogVAR self._class
                                let self._id    = objid
                                " let self._super = [super] + self._super
                                call insert(self._super, super)
                                return self
                            endf
                            
                            
    1              0.000002 function! s:prototype.IsA(class) dict "{{{3
                                return index(self._class, a:class) != -1
                            endf
                            
                            
    1              0.000002 function! s:prototype.IsRelated(object) dict "{{{3
                                return len(filter(a:object._class, 'self.IsA(v:val)')) > 1
                            endf
                            
                            
    1              0.000002 function! s:prototype.RespondTo(name) dict "{{{3
                                " return has_key(self, a:name) && type(self[a:name]) == 2
                                return has_key(self, a:name)
                            endf
                            
                            
    1              0.000002 function! s:prototype.Super(method, arglist) dict "{{{3
                                for o in self._super
                                    " TLogVAR o
                                    if o.RespondTo(a:method)
                                        " let self._tmp_method = o[a:method]
                                        " TLogVAR self._tmp_method
                                        " return call(self._tmp_method, a:arglist, self)
                                        return call(o[a:method], a:arglist, self)
                                    endif
                                endfor
                                echoerr 'tlib#Object: Does not respond to '. a:method .': '. string(self)
                            endf
                            
                            
    1              0.000003 function! tlib#Object#Methods(object, ...) "{{{3
                                TVarArg ['pattern', '\d\+']
                                let o = items(a:object)
                                call filter(o, 'type(v:val[1]) == 2 && string(v:val[1]) =~ "^function(''\\d\\+'')"')
                                let acc = {}
                                for e in o
                                    let id = matchstr(string(e[1]), pattern)
                                    if !empty(id)
                                        let acc[id] = e[0]
                                    endif
                                endfor
                                return acc
                            endf
                            

SCRIPT  /Users/brettmz-admin/dev_trees/myvim/bundle/tlib_vim/autoload/tlib/var.vim
Sourced 1 time
Total time:   0.000099
 Self time:   0.000099

count  total (s)   self (s)
                            " @Author:      Tom Link (micathom AT gmail com?subject=[vim])
                            " @Website:     http://www.vim.org/account/profile.php?user_id=4037
                            " @License:     GPL (see http://www.gnu.org/licenses/gpl.txt)
                            " @Revision:    34
                            
                            
                            " Define a variable called NAME if yet undefined.
                            " You can also use the :TLLet command.
                            "
                            " EXAMPLES: >
                            "   exec tlib#var#Let('g:foo', 1)
                            "   TLet g:foo = 1
    1              0.000005 function! tlib#var#Let(name, val) "{{{3
                                return printf('if !exists(%s) | let %s = %s | endif', string(a:name), a:name, string(a:val))
                                " return printf('if !exists(%s) | let %s = %s | endif', string(a:name), a:name, a:val)
                            endf
                            
                            
                            " :def: function! tlib#var#EGet(var, namespace, ?default='')
                            " Retrieve a variable by searching several namespaces.
                            "
                            " EXAMPLES: >
                            "   let g:foo = 1
                            "   let b:foo = 2
                            "   let w:foo = 3
                            "   echo eval(tlib#var#EGet('foo', 'vg'))  => 1
                            "   echo eval(tlib#var#EGet('foo', 'bg'))  => 2
                            "   echo eval(tlib#var#EGet('foo', 'wbg')) => 3
    1              0.000003 function! tlib#var#EGet(var, namespace, ...) "{{{3
                                let pre  = []
                                let post = []
                                for namespace in split(a:namespace, '\zs')
                                    let var = namespace .':'. a:var
                                    call add(pre,  printf('exists("%s") ? %s : (', var, var))
                                    call add(post, ')')
                                endfor
                                let default = a:0 >= 1 ? a:1 : ''
                                return join(pre) . string(default) . join(post)
                            endf
                            
                            
                            " :def: function! tlib#var#Get(var, namespace, ?default='')
                            " Retrieve a variable by searching several namespaces.
                            "
                            " EXAMPLES: >
                            "   let g:foo = 1
                            "   let b:foo = 2
                            "   let w:foo = 3
                            "   echo tlib#var#Get('foo', 'bg')  => 1
                            "   echo tlib#var#Get('foo', 'bg')  => 2
                            "   echo tlib#var#Get('foo', 'wbg') => 3
    1              0.000002 function! tlib#var#Get(var, namespace, ...) "{{{3
                                let var_ = substitute(a:var, '#', '_', 'g')
                                for namespace in split(a:namespace, '\zs')
                                    let vname = namespace ==# 'g' ? a:var : var_
                                    let var = namespace .':'. vname
                                    if exists(var)
                                        return {var}
                                    elseif namespace ==# 'g'
                                        try
                                            let val = {var}
                                        catch /^Vim\%((\a\+)\)\=:E\(121\|15\)/
                                            continue
                                        endtry
                                        return val
                                    endif
                                endfor
                                return a:0 >= 1 ? a:1 : ''
                            endf
                            
                            
                            " :def: function! tlib#var#List(rx, ?prefix='')
                            " Get a list of variables matching rx.
                            " EXAMPLE:
                            "   echo tlib#var#List('tlib_', 'g:')
    1              0.000002 function! tlib#var#List(rx, ...) "{{{3
                                TVarArg ['prefix', 'g:']
                                if v:version >= 704
                                    exec 'let varlist = keys('. prefix .')'
                                else
                                    redir => vars
                                    silent! exec 'let '. prefix
                                    redir END
                                    let varlist = split(vars, '\n')
                                    call map(varlist, 'matchstr(v:val, ''^\S\+'')')
                                endif
                                call filter(varlist, 'v:val =~ a:rx')
                                return varlist
                            endf
                            

SCRIPT  /Users/brettmz-admin/dev_trees/myvim/bundle/tlib_vim/autoload/tlib/scratch.vim
Sourced 1 time
Total time:   0.000205
 Self time:   0.000205

count  total (s)   self (s)
                            " @Author:      Tom Link (micathom AT gmail com?subject=[vim])
                            " @Website:     http://www.vim.org/account/profile.php?user_id=4037
                            " @License:     GPL (see http://www.gnu.org/licenses/gpl.txt)
                            " @Revision:    255
                            
                            
                            " Scratch window position. By default the list window is opened on the 
                            " bottom. Set this variable to 'topleft' or '' to change this behaviour.
                            " See |tlib#input#List()|.
    1              0.000036 TLet g:tlib_scratch_pos = 'botright'
                            
                            " If you want the scratch buffer to be fully removed, you might want to 
                            " set this variable to 'wipe'.
                            " See also https://github.com/tomtom/tlib_vim/pull/16
    1              0.000023 TLet g:tlib#scratch#hidden = 'hide'
                            
                            
                            " :def: function! tlib#scratch#UseScratch(?keyargs={})
                            " Display a scratch buffer (a buffer with no file). See :TScratch for an 
                            " example.
                            " Return the scratch buffer's number.
                            " Values for keyargs:
                            "   scratch_split ... 1: split, 0: window, -1: tab
    1              0.000004 function! tlib#scratch#UseScratch(...) "{{{3
                                exec tlib#arg#Let([['keyargs', {}]])
                                " TLogDBG string(keys(keyargs))
                                let id = get(keyargs, 'scratch', '__Scratch__')
                                " TLogVAR id, bufwinnr(id)
                                " TLogVAR bufnr(id), bufname(id)
                                " TLogVAR 1, winnr(), bufnr('%'), bufname("%")
                                if bufwinnr(id) != -1
                                    " echom 'DBG noautocmd keepalt keepj' bufwinnr(id) 'wincmd w'
                                    exec 'noautocmd keepalt keepj' bufwinnr(id) 'wincmd w'
                                    " TLogVAR "reuse", bufnr("%"), bufname("%")
                                else
                                    let winpos = ''
                                    let bn = bufnr(id)
                                    let wpos = get(keyargs, 'scratch_pos', g:tlib_scratch_pos)
                                    " TLogVAR keyargs.scratch_vertical
                                    if get(keyargs, 'scratch_vertical')
                                        let wpos .= ' vertical'
                                        let winpos = tlib#fixes#Winpos()
                                    endif
                                    " TLogVAR wpos
                                    let scratch_split = get(keyargs, 'scratch_split', 1)
                                    if bn != -1
                                        " TLogVAR bn
                                        let wn = bufwinnr(bn)
                                        if wn != -1
                                            " TLogVAR wn
                                            exec 'noautocmd keepalt keepj' (wn .'wincmd w')
                                        else
                                            if scratch_split == 1
                                                let cmd = wpos.' sbuffer!'
                                            elseif scratch_split == -1
                                                let cmd = wpos.' tab sbuffer!'
                                            else
                                                let cmd = 'buffer!'
                                            endif
                                            " TLogVAR cmd, bn
                                            silent exec 'noautocmd keepalt keepj' cmd bn
                                        endif
                                    else
                                        " TLogVAR id
                                        if scratch_split == 1
                                            let cmd = wpos.' split'
                                        elseif scratch_split == -1
                                            let cmd = wpos.' tab split'
                                        else
                                            let cmd = 'edit'
                                        endif
                                        " TLogVAR cmd, id
                                        silent exec 'noautocmd keepalt keepj' cmd escape(id, '%#\ ')
                                        " silent exec 'split '. id
                                    endif
                                    let ft = get(keyargs, 'scratch_filetype', '')
                                    " TLogVAR ft, winpos
                                    if !empty(winpos)
                                        exec winpos
                                    endif
                                    setlocal buftype=nofile
                                    let &l:bufhidden = get(keyargs, 'scratch_hidden', g:tlib#scratch#hidden)
                                    setlocal noswapfile
                                    setlocal nobuflisted
                                    setlocal foldmethod=manual
                                    setlocal foldcolumn=0
                                    setlocal nospell
                                    setlocal modifiable
                                    setlocal noreadonly
                                    " TLogVAR &ft, ft
                                    if !empty(ft)
                                        let &l:ft = ft
                                    endif
                                endif
                                let keyargs.scratch = bufnr('%')
                                let keyargs.scratch_tabpagenr = tabpagenr()
                                let keyargs.scratch_winnr = winnr()
                                " TLogVAR 2, winnr(), bufnr('%'), bufname("%"), keyargs.scratch
                                return keyargs.scratch
                            endf
                            
                            
                            " Close a scratch buffer as defined in keyargs (usually a World).
                            " Return 1 if the scratch buffer is closed (or if it already was 
                            " closed).
    1              0.000002 function! tlib#scratch#CloseScratch(keyargs, ...) "{{{3
                                TVarArg ['reset_scratch', 1]
                                let scratch = get(a:keyargs, 'scratch', '')
                                " TLogVAR scratch, reset_scratch
                                " TLogDBG string(tlib#win#List())
                                if !empty(scratch) && winnr('$') > 1
                                    let wn = bufwinnr(scratch)
                                    " TLogVAR wn
                                    try
                                        if wn != -1
                                            " TLogDBG winnr()
                                            let wb = tlib#win#Set(wn)
                                            let winpos = tlib#fixes#Winpos()
                                            wincmd c
                                            if get(a:keyargs, 'scratch_vertical') && !empty(winpos)
                                                exec winpos
                                            endif
                                            " exec wb 
                                            " redraw
                                            " TLogVAR winnr()
                                        endif
                                        return 1
                                    finally
                                        if reset_scratch
                                            let a:keyargs.scratch = ''
                                        endif
                                    endtry
                                endif
                                return 0
                            endf
                            

SCRIPT  /Users/brettmz-admin/dev_trees/myvim/bundle/tlib_vim/autoload/tlib/win.vim
Sourced 1 time
Total time:   0.000244
 Self time:   0.000244

count  total (s)   self (s)
                            " @Author:      Tom Link (micathom AT gmail com?subject=[vim])
                            " @Website:     http://www.vim.org/account/profile.php?user_id=4037
                            " @License:     GPL (see http://www.gnu.org/licenses/gpl.txt)
                            " @Revision:    84
                            
                            
    1              0.000007 if !exists('g:tlib#win#use_winid')
    1              0.000010     let g:tlib#win#use_winid = exists('*win_gotoid') && exists('*win_getid')   "{{{2
    1              0.000001 endif
                            
                            
                            " Return vim code to jump back to the original window.
    1              0.000003 function! tlib#win#Set(winnr) "{{{3
                                if a:winnr > 0
                                    " TLogVAR a:winnr
                                    " TLogDBG winnr()
                                    " TLogDBG string(tlib#win#List())
                                    if winnr() != a:winnr && winbufnr(a:winnr) != -1
                                        let rv = winnr().'wincmd w'
                                        exec a:winnr .'wincmd w'
                                        " TLogVAR rv
                                        " TLogDBG string(tlib#win#List())
                                        return rv
                                    endif
                                endif
                                return ''
                            endf
                            
                            
    1              0.000002 if g:tlib#win#use_winid
    1              0.000002     let g:tlib#win#null_id = -1
    1              0.000002     function! tlib#win#GetID() abort "{{{3
                                    return win_getid()
                                endf
    1              0.000002     function! tlib#win#GotoID(win_id) abort "{{{3
                                    call win_gotoid(a:win_id)
                                endf
                            else
                                let s:win_id = 0
                                let g:tlib#win#null_id = {}
                                function! tlib#win#GetID() abort "{{{3
                                    if !exists('w:tlib_win_id')
                                        let s:win_id += 1
                                        let w:tlib_win_id = s:win_id
                                    endif
                                    return {'tabpagenr': tabpagenr(), 'bufnr': bufnr('%'), 'winnr': winnr(), 'win_id': w:tlib_win_id}
                                endf
                                function! tlib#win#GotoID(win_id) abort "{{{3
                                    Tlibtrace 'tlib', a:win_id
                                    if tabpagenr() != a:win_id.tabpagenr
                                        exec 'tabnext' a:win_id.tabpagenr
                                    endif
                                    for wnr in range(1, winnr('$'))
                                        let win_id = getwinvar(wnr, 'tlib_win_id', -1)
                                        Tlibtrace 'tlib', wnr, win_id
                                        if win_id == a:win_id.win_id
                                            Tlibtrace 'tlib', wnr
                                            exec wnr 'wincmd w'
                                            return
                                        endif
                                    endfor
                                    " Was the window closed? What should we do now?
                                    if winnr() != a:win_id.winnr
                                        exec a:win_id.winnr 'wincmd w'
                                    endif
                                    if bufnr('%') != a:win_id.bufnr
                                        exec 'hide buffer' a:win_id.bufnr
                                    endif
                                endf
    1              0.000002 endif
                            
                            
                            " Return vim code to jump back to the original window.
    1              0.000002 function! tlib#win#SetById(win_id) "{{{3
                                if a:win_id != g:tlib#win#null_id
                                    let win_id = tlib#win#GetID()
                                    call tlib#win#GotoID(a:win_id)
                                    return printf('call tlib#win#GotoID(%s)', win_id)
                                    " " TLogVAR a:winnr
                                    " " TLogDBG winnr()
                                    " " TLogDBG string(tlib#win#List())
                                    " if winnr() != a:winnr && winbufnr(a:winnr) != -1
                                    "     let rv = winnr().'wincmd w'
                                    "     exec a:winnr .'wincmd w'
                                    "     " TLogVAR rv
                                    "     " TLogDBG string(tlib#win#List())
                                    "     return rv
                                    " endif
                                endif
                                return ''
                            endf
                             
                            
                            " :def: function! tlib#win#GetLayout(?save_view=0)
    1              0.000002 function! tlib#win#GetLayout(...) "{{{3
                                TVarArg ['save_view', 0]
                                let views = {}
                                if save_view
                                    let winnr = winnr()
                                    windo let views[winnr()] = winsaveview()
                                    " for w in range(1, winnr('$'))
                                    "     call tlib#win#Set(w)
                                    "     let views[w] = winsaveview()
                                    " endfor
                                    call tlib#win#Set(winnr)
                                endif
                                return {'winnr': winnr('$'), 'winrestcmd': winrestcmd(), 'views': views, 'cmdheight': &cmdheight, 'guioptions': &guioptions, 'tabpagenr': tabpagenr()}
                            endf
                            
                            
    1              0.000002 function! tlib#win#SetLayout(layout) "{{{3
                                if a:layout.tabpagenr == tabpagenr() && a:layout.winnr == winnr('$')
                                    " TLogVAR a:layout.winrestcmd
                                    " TLogDBG string(tlib#win#List())
                                    exec a:layout.winrestcmd
                                    if !empty(a:layout.views)
                                        let winnr = winnr()
                                        " TLogVAR winnr
                                        for [w, v] in items(a:layout.views)
                                            " TLogVAR w, v
                                            call tlib#win#Set(w)
                                            call winrestview(v)
                                        endfor
                                        call tlib#win#Set(winnr)
                                    endif
                                    if a:layout.cmdheight != &cmdheight
                                        let &cmdheight = a:layout.cmdheight
                                    endif
                                    " TLogDBG string(tlib#win#List())
                                    return 1
                                endif
                                return 0
                            endf
                            
                            
    1              0.000002 function! tlib#win#List() "{{{3
                                let wl = {}
                                for wn in range(1, winnr('$'))
                                    let wl[wn] = bufname(winbufnr(wn))
                                endfor
                                return wl
                            endf
                            
                            
                            " " :def: function! tlib#win#GetLayout1(?save_view=0)
                            " " Contrary to |tlib#win#GetLayout|, this version doesn't use 
                            " " |winrestcmd()|. It can also save windows views.
                            " function! tlib#win#GetLayout1(...) "{{{3
                            "     TVarArg ['save_view', 0]
                            "     let winnr = winnr()
                            "     let acc = {}
                            "     for w in range(1, winnr('$'))
                            "         let def = {'h': winheight(w), 'w': winwidth(w)}
                            "         if save_view
                            "             call tlib#win#Set(w)
                            "             let def.view = winsaveview()
                            "         endif
                            "         let acc[w] = def
                            "     endfor
                            "     call tlib#win#Set(winnr)
                            "     return acc
                            " endf
                            " 
                            " 
                            " " Reset layout from the value of |tlib#win#GetLayout1|.
                            " function! tlib#win#SetLayout1(layout) "{{{3
                            "     if len(a:layout) != winnr('$')
                            "         return 0
                            "     endif
                            "     let winnr = winnr()
                            "     for [w, def] in items(a:layout)
                            "         if tlib#win#Set(w)
                            "             exec 'resize '. def.h
                            "             exec 'vertical resize '. def.w
                            "             if has_key(def, 'view')
                            "                 call winrestview(def.view)
                            "             endif
                            "         else
                            "             break
                            "         endif
                            "     endfor
                            "     call tlib#win#Set(winnr)
                            "     return 1
                            " endf
                            
                            
    1              0.000002 function! tlib#win#Width(wnr) "{{{3
                                return winwidth(a:wnr) - &fdc
                            endf
                            
                            
    1              0.000002 function! tlib#win#WinDo(ex) "{{{3
                                let w = winnr()
                                exec 'windo '. a:ex
                                exec w .'wincmd w'
                            endf
                            

SCRIPT  /Users/brettmz-admin/dev_trees/myvim/bundle/tlib_vim/autoload/tlib/Filter_glob.vim
Sourced 1 time
Total time:   0.000978
 Self time:   0.000582

count  total (s)   self (s)
                            " @Author:      Tom Link (mailto:micathom AT gmail com?subject=[vim])
                            " @Website:     http://www.vim.org/account/profile.php?user_id=4037
                            " @License:     GPL (see http://www.gnu.org/licenses/gpl.txt)
                            " @Created:     2008-11-25.
                            " @Last Change: 2014-11-18.
                            " @Revision:    0.0.82
                            
    1   0.000846   0.000450 let s:prototype = tlib#Filter_cnf#New({'_class': ['Filter_glob'], 'name': 'glob'}) "{{{2
    1              0.000003 let s:prototype.highlight = g:tlib#input#higroup
                            
                            
                            " A character that should be expanded to '\.\{-}'.
    1              0.000029 TLet g:tlib#Filter_glob#seq = '*'
                            
                            
                            " A character that should be expanded to '\.\?'.
    1              0.000021 TLet g:tlib#Filter_glob#char = '?'
                            
                            
                            " The same as |tlib#Filter_cnf#New()| but a a customizable character 
                            " |see tlib#Filter_glob#seq| is expanded to '\.\{-}' and 
                            " |g:tlib#Filter_glob#char| is expanded to '\.'.
                            " The pattern is a '/\V' very no-'/magic' regexp pattern.
    1              0.000003 function! tlib#Filter_glob#New(...) "{{{3
                                let object = s:prototype.New(a:0 >= 1 ? a:1 : {})
                                return object
                            endf
                            
                            
    1              0.000006 let s:Help = s:prototype.Help
                            
                            " :nodoc:
    1              0.000002 function! s:prototype.Help(world) dict "{{{3
                                call call(s:Help, [a:world], self)
                                call a:world.PushHelp(g:tlib#Filter_glob#seq, 'Any characters')
                                call a:world.PushHelp(g:tlib#Filter_glob#char, 'Single characters')
                            endf
                            
                            
                            " :nodoc:
    1              0.000002 function! s:prototype.SetFrontFilter(world, pattern) dict "{{{3
                                let pattern = substitute(a:pattern, tlib#rx#Escape(g:tlib#Filter_glob#seq, 'V'), '\\.\\{-}', 'g')
                                let pattern = substitute(a:pattern, tlib#rx#Escape(g:tlib#Filter_glob#char, 'V'), '\\.', 'g')
                                let a:world.filter[0] = reverse(split(pattern, '\s*|\s*')) + a:world.filter[0][1 : -1]
                            endf
                            
                            
                            " :nodoc:
    1              0.000002 function! s:prototype.PushFrontFilter(world, char) dict "{{{3
                                " TLogVAR a:char, nr2char(a:char)
                                if a:char == char2nr(g:tlib#Filter_glob#seq)
                                    let char = '\.\{-}'
                                elseif a:char == char2nr(g:tlib#Filter_glob#char)
                                    let char = '\.'
                                else
                                    let char = nr2char(a:char)
                                endif
                                let a:world.filter[0][0] .= char
                            endf
                            
                            
                            " :nodoc:
    1              0.000002 function! s:prototype.CleanFilter(filter) dict "{{{3
                                let filter = substitute(a:filter, '\\\.\\{-}', g:tlib#Filter_glob#seq, 'g')
                                let filter = substitute(filter, '\\\.', g:tlib#Filter_glob#char, 'g')
                                return filter
                            endf
                            

SCRIPT  /Users/brettmz-admin/dev_trees/myvim/bundle/tlib_vim/autoload/tlib/Filter_cnf.vim
Sourced 1 time
Total time:   0.000273
 Self time:   0.000182

count  total (s)   self (s)
                            " Filter_cnf.vim
                            " @Author:      Tom Link (mailto:micathom AT gmail com?subject=[vim])
                            " @Website:     http://www.vim.org/account/profile.php?user_id=4037
                            " @License:     GPL (see http://www.gnu.org/licenses/gpl.txt)
                            " @Created:     2008-11-25.
                            " @Last Change: 2017-09-28.
                            " @Revision:    11.0.114
                            
    1   0.000112   0.000021 let s:prototype = tlib#Object#New({'_class': ['Filter_cnf'], 'name': 'cnf'}) "{{{2
    1              0.000004 let s:prototype.highlight = g:tlib#input#higroup
                            
                            " The search pattern for |tlib#input#List()| is in conjunctive normal 
                            " form: (P1 OR P2 ...) AND (P3 OR P4 ...) ...
                            " The pattern is a '/\V' very no-'/magic' regexp pattern.
                            "
                            " Pressing <space> joins two patterns with AND.
                            " Pressing | joins two patterns with OR.
                            " I.e. In order to get "lala AND (foo OR bar)", you type 
                            " "lala foo|bar".
                            "
                            " This is also the base class for other filters.
    1              0.000003 function! tlib#Filter_cnf#New(...) "{{{3
                                let object = s:prototype.New(a:0 >= 1 ? a:1 : {})
                                return object
                            endf
                            
                            
                            " :nodoc:
    1              0.000002 function! s:prototype.Init(world) dict "{{{3
                            endf
                            
                            
                            " :nodoc:
    1              0.000002 function! s:prototype.Help(world) dict "{{{3
                                call a:world.PushHelp(
                                            \ printf('"%s", "%s", "%sWORD"', g:tlib#input#and, g:tlib#input#or, g:tlib#input#not),
                                            \ 'AND, OR, NOT')
                            endf
                            
                            
                            " :nodoc:
    1              0.000002 function! s:prototype.AssessName(world, name) dict "{{{3
                                let xa  = 0
                                let prefix = self.FilterRxPrefix()
                                for flt in a:world.filter_pos
                                    " let flt = prefix . a:world.GetRx(fltl)
                                    " if flt =~# '\u' && a:name =~# flt
                                    "     let xa += 5
                                    " endif
                                    let rel = 1.0 + 5.0 * len(flt) / len(a:name)
                                    let xa += float2nr(rel)
                                    if a:name =~ '\^'. flt
                                        let xa += 4
                                    elseif a:name =~ '\<'. flt
                                        let xa += 3
                                    " elseif a:name =~ '[[:punct:][:space:][:digit:]]'. flt
                                    "     let xa += 2
                                    elseif a:name =~ '\A'. flt .'\|'. flt .'\A'
                                        let xa += 1
                                    endif
                                endfor
                                " TLogVAR a:name, xa
                                return xa
                            endf
                            
                            
                            " :nodoc:
    1              0.000002 function! s:prototype.Match(world, text) dict "{{{3
                                " TLogVAR a:text
                                " let sc = &smartcase
                                " let ic = &ignorecase
                                " if &ignorecase
                                "     set smartcase
                                " endif
                                " try
                                if !empty(a:world.filter_neg)
                                    for rx in a:world.filter_neg
                                        " TLogVAR rx
                                        if a:text =~ rx
                                            return 0
                                        endif
                                    endfor
                                endif
                                if !empty(a:world.filter_pos)
                                    for rx in a:world.filter_pos
                                        " TLogVAR rx
                                        if a:text !~ rx
                                            return 0
                                        endif
                                    endfor
                                endif
                                " finally
                                "     let &smartcase = sc
                                "     let &ignorecase = ic
                                " endtry
                                return 1
                            endf
                            
                            
                            " :nodoc:
    1              0.000002 function! s:prototype.DisplayFilter(filter) dict "{{{3
                                let filter1 = deepcopy(a:filter)
                                call map(filter1, '"(". join(reverse(self.Pretty(v:val)), " OR ") .")"')
                                return join(reverse(filter1), ' AND ')
                            endf
                            
                            
    1              0.000001 function! s:prototype.Pretty(filter) dict "{{{3
                                " call map(a:filter, 'substitute(v:val, ''\\\.\\{-}'', ''=>'', ''g'')')
                                call map(a:filter, 'self.CleanFilter(v:val)')
                                return a:filter
                            endf
                            
                            
                            " :nodoc:
    1              0.000002 function! s:prototype.SetFrontFilter(world, pattern) dict "{{{3
                                let a:world.filter[0] = reverse(split(a:pattern, '\s*|\s*')) + a:world.filter[0][1 : -1]
                            endf
                            
                            
                            " :nodoc:
    1              0.000002 function! s:prototype.PushFrontFilter(world, char) dict "{{{3
                                let a:world.filter[0][0] .= nr2char(a:char)
                            endf
                            
                            
                            " :nodoc:
    1              0.000002 function! s:prototype.ReduceFrontFilter(world) dict "{{{3
                                let filter = a:world.filter[0][0]
                                " TLogVAR filter
                                let str = matchstr(filter, '\(\\\(\.\\{-}\|[.?*+$^]\)\|\)$')
                                if empty(str)
                                    let filter = filter[0 : -2]
                                else
                                    let filter = tlib#string#Strcharpart(filter, 0, len(filter) - len(str))
                                endif
                                " TLogVAR str, filter
                                let a:world.filter[0][0] = filter
                            endf
                            
                            
                            " :nodoc:
    1              0.000002 function! s:prototype.FilterRxPrefix() dict "{{{3
                                return '\V'
                            endf
                            
                            
                            " :nodoc:
    1              0.000002 function! s:prototype.CleanFilter(filter) dict "{{{3
                                return a:filter
                            endf
                            

SCRIPT  /Users/brettmz-admin/dev_trees/myvim/bundle/tlib_vim/autoload/tlib/list.vim
Sourced 1 time
Total time:   0.000198
 Self time:   0.000198

count  total (s)   self (s)
                            " list.vim
                            " @Author:      Tom Link (micathom AT gmail com?subject=[vim])
                            " @Website:     http://www.vim.org/account/profile.php?user_id=4037
                            " @License:     GPL (see http://www.gnu.org/licenses/gpl.txt)
                            " @Created:     2007-06-30.
                            " @Last Change: 2017-03-26.
                            " @Revision:    71
                            
                            
                            """ List related functions {{{1
                            " For the following functions please see ../../test/tlib.vim for examples.
                            
                            " :def: function! tlib#list#Inject(list, initial_value, funcref) abort
                            " EXAMPLES: >
                            "   echo tlib#list#Inject([1,2,3], 0, function('Add')
                            "   => 6
    1              0.000005 function! tlib#list#Inject(list, value, Function) abort "{{{3
                                if empty(a:list)
                                    return a:value
                                else
                                    let item  = a:list[0]
                                    let rest  = a:list[1:-1]
                                    let value = call(a:Function, [a:value, item])
                                    return tlib#list#Inject(rest, value, a:Function)
                                endif
                            endf
                            
                            
                            " EXAMPLES: >
                            "   tlib#list#Compact([0,1,2,3,[], {}, ""])
                            "   => [1,2,3]
    1              0.000002 function! tlib#list#Compact(list) abort "{{{3
                                return filter(copy(a:list), '!empty(v:val)')
                            endf
                            
                            
                            " EXAMPLES: >
                            "   tlib#list#Flatten([0,[1,2,[3,""]]])
                            "   => [0,1,2,3,""]
    1              0.000002 function! tlib#list#Flatten(list) abort "{{{3
                                let acc = []
                                for e in a:list
                                    if type(e) == 3
                                        let acc += tlib#list#Flatten(e)
                                    else
                                        call add(acc, e)
                                    endif
                                    unlet e
                                endfor
                                return acc
                            endf
                            
                            
                            " :def: function! tlib#list#FindAll(list, filter, ?process_expr="") abort
                            " Basically the same as filter()
                            "
                            " EXAMPLES: >
                            "   tlib#list#FindAll([1,2,3], 'v:val >= 2')
                            "   => [2, 3]
    1              0.000002 function! tlib#list#FindAll(list, filter, ...) abort "{{{3
                                let rv   = filter(copy(a:list), a:filter)
                                if a:0 >= 1 && !empty(a:1)
                                    let rv = map(rv, a:1)
                                endif
                                return rv
                            endf
                            
                            
                            " :def: function! tlib#list#Find(list, filter, ?default="", ?process_expr="") abort
                            "
                            " EXAMPLES: >
                            "   tlib#list#Find([1,2,3], 'v:val >= 2')
                            "   => 2
    1              0.000002 function! tlib#list#Find(list, filter, ...) abort "{{{3
                                let default = a:0 >= 1 ? a:1 : ''
                                let expr    = a:0 >= 2 ? a:2 : ''
                                return get(tlib#list#FindAll(a:list, a:filter, expr), 0, default)
                            endf
                            
                            
                            " EXAMPLES: >
                            "   tlib#list#Any([1,2,3], 'v:val >= 2')
                            "   => 1
    1              0.000002 function! tlib#list#Any(list, expr) abort "{{{3
                                return !empty(tlib#list#FindAll(a:list, a:expr))
                            endf
                            
                            
                            " EXAMPLES: >
                            "   tlib#list#All([1,2,3], 'v:val >= 2')
                            "   => 0
    1              0.000002 function! tlib#list#All(list, expr) abort "{{{3
                                return len(tlib#list#FindAll(a:list, a:expr)) == len(a:list)
                            endf
                            
                            
                            " EXAMPLES: >
                            "   tlib#list#Remove([1,2,1,2], 2)
                            "   => [1,1,2]
    1              0.000002 function! tlib#list#Remove(list, element) abort "{{{3
                                let idx = index(a:list, a:element)
                                if idx != -1
                                    call remove(a:list, idx)
                                endif
                                return a:list
                            endf
                            
                            
                            " EXAMPLES: >
                            "   tlib#list#RemoveAll([1,2,1,2], 2)
                            "   => [1,1]
    1              0.000002 function! tlib#list#RemoveAll(list, element) abort "{{{3
                                call filter(a:list, 'v:val != a:element')
                                return a:list
                            endf
                            
                            
                            " :def: function! tlib#list#Zip(lists, ?default='') abort
                            " EXAMPLES: >
                            "   tlib#list#Zip([[1,2,3], [4,5,6]])
                            "   => [[1,4], [2,5], [3,6]]
    1              0.000001 function! tlib#list#Zip(lists, ...) abort "{{{3
                                TVarArg 'default'
                                let lists = copy(a:lists)
                                let max   = 0
                                for l in lists
                                    let ll = len(l)
                                    if ll > max
                                        let max = ll
                                    endif
                                endfor
                                " TLogVAR default, max
                                return map(range(0, max - 1), 's:GetNthElement(v:val, lists, default)')
                            endf
                            
    1              0.000004 function! s:GetNthElement(n, lists, default) abort "{{{3
                                " TLogVAR a:n, a:lists, a:default
                                return map(copy(a:lists), 'get(v:val, a:n, a:default)')
                            endf
                            
                            
    1              0.000002 function! tlib#list#Uniq(list, ...) abort "{{{3
                                " TLogVAR a:list
                                TVarArg ['get_value', ''], ['remove_empty', 0]
                                if remove_empty
                                    call filter(a:list, 'type(v:val) == 0 || !empty(v:val)')
                                endif
                                " CREDITS: Based on syntastic#util#unique(list) by scrooloose
                                let emptystring = 0
                                let seen = {}
                                let uniques = []
                                if empty(get_value)
                                    for e in a:list
                                        if empty(e)
                                            if !emptystring
                                                let emptystring = 1
                                                call add(uniques, e)
                                            endif
                                        elseif !has_key(seen, e)
                                            let seen[e] = 1
                                            call add(uniques, e)
                                        endif
                                        unlet e
                                    endfor
                                else
                                    for e in a:list
                                        let v = eval(printf(get_value, string(e)))
                                        if empty(v)
                                            if !emptystring
                                                let emptystring = 1
                                                call add(uniques, v)
                                            endif
                                        elseif !has_key(seen, v)
                                            let seen[v] = 1
                                            call add(uniques, v)
                                        endif
                                        unlet e v
                                    endfor
                                endif
                                return uniques
                            endf
                            
                            
    1              0.000002 function! tlib#list#ToDictionary(list, default, ...) abort "{{{3
                                TVarArg ['generator', '']
                                let dict = {}
                                for item in a:list
                                    if !empty(item)
                                        let dict[item] = empty(generator) ? a:default : call(generator, [item, a:default])
                                    endif
                                endfor
                                return dict
                            endf
                            

SCRIPT  /Users/brettmz-admin/dev_trees/myvim/bundle/vim-snipmate/autoload/snipmate/jumping.vim
Sourced 1 time
Total time:   0.000964
 Self time:   0.000755

count  total (s)   self (s)
    1              0.000005 function! s:sfile() abort
                            	return expand('<sfile>')
                            endfunction
                            
    1              0.000003 let s:state_proto = {}
                            
    1              0.000002 function! snipmate#jumping#state() abort
                            	return copy(s:state_proto)
                            endfunction
                            
    1              0.000003 function! s:listize_mirror(mirrors) abort
                            	return map(copy(a:mirrors), '[v:val.line, v:val.col]')
                            endfunction
                            
                            " Removes snippet state info
    1              0.000002 function! s:state_remove() dict abort
                            	" Remove all autocmds in group snipmate_changes in the current buffer
                            	unlet! b:snip_state
                            	silent! au! snipmate_changes * <buffer>
                            endfunction
                            
    1              0.000002 function! s:state_find_next_stop(backwards) dict abort
                            	let self.stop_no += a:backwards? -1 : 1
                            	while !has_key(self.stops, self.stop_no)
                            		if self.stop_no == self.stop_count
                            			let self.stop_no = 0
                            		endif
                            		if self.stop_no <= 0 && a:backwards
                            			let self.stop_no = self.stop_count - 1
                            		endif
                            		let self.stop_no += a:backwards? -1 : 1
                            	endwhile
                            endfunction
                            
                            " Update state information to correspond to the given tab stop
    1              0.000002 function! s:state_set_stop(backwards) dict abort
                            	call self.find_next_stop(a:backwards)
                            	let self.cur_stop    = self.stops[self.stop_no]
                            	let self.stop_len = (type(self.cur_stop.placeholder) == type(0))
                            				\ ? self.cur_stop.placeholder
                            				\ : len(snipMate#placeholder_str(self.stop_no, self.stops))
                            	let self.start_col   = self.cur_stop.col
                            	let self.end_col     = self.start_col + self.stop_len
                            	let self.mirrors     = get(self.cur_stop, 'mirrors', [])
                            	let self.old_mirrors = deepcopy(self.mirrors)
                            	call cursor(self.cur_stop.line, self.cur_stop.col)
                            	let self.prev_len    = col('$')
                            	let self.changed = 0
                            	let ret = self.select_word()
                            	if (self.stop_no == 0 || self.stop_no == self.stop_count - 1) && !a:backwards
                            		call self.remove()
                            	endif
                            	return ret
                            endfunction
                            
                            " Jump to the next/previous tab stop
    1              0.000002 function! s:state_jump_stop(backwards) dict abort
                            	" Update changes just in case
                            	" This seems to be only needed because insert completion does not trigger
                            	" the CursorMovedI event
                            	call self.update_changes()
                            
                            	" Store placeholder/location changes
                            	let self.cur_stop.col = self.start_col
                            	if self.changed
                            		call self.remove_nested()
                            		unlet! self.cur_stop.placeholder " avoid type error for old parsing version
                            		let self.cur_stop.placeholder = [strpart(getline('.'),
                            					\ self.start_col - 1, self.end_col - self.start_col)]
                            	endif
                            
                            	return self.set_stop(a:backwards)
                            endfunction
                            
    1              0.000002 function! s:state_remove_nested(...) dict abort
                            	let id = a:0 ? a:1 : self.stop_no
                            	if type(self.stops[id].placeholder) == type([])
                            		for i in self.stops[id].placeholder
                            			if type(i) == type([])
                            				if type(i[1]) != type({})
                            					call self.remove_nested(i[0])
                            					call remove(self.stops, i[0])
                            				else
                            					call filter(self.stops[i[0]].mirrors, 'v:val isnot i[1]')
                            				endif
                            			endif
                            			unlet i " Avoid E706
                            		endfor
                            	endif
                            endfunction
                            
                            " Select the placeholder for the current tab stop
    1              0.000001 function! s:state_select_word() dict abort
                            	let len = self.stop_len
                            	if !len | return '' | endif
                            	let l = col('.') != 1 ? 'l' : ''
                            	if &sel == 'exclusive'
                            		return "\<esc>".l.'v'.len."l\<c-g>"
                            	endif
                            	return len == 1 ? "\<esc>".l.'gh' : "\<esc>".l.'v'.(len - 1)."l\<c-g>"
                            endfunction
                            
                            " Update the snippet as text is typed. The self.update_mirrors() function does
                            " the actual work.
                            " If the cursor moves outside of a placeholder, call self.remove()
    1              0.000002 function! s:state_update_changes() dict abort
                            	let change_len = col('$') - self.prev_len
                            	let self.changed = self.changed || change_len != 0
                            	let self.end_col += change_len
                            	let col = col('.')
                            
                            	if line('.') != self.cur_stop.line || col < self.start_col || col > self.end_col
                            		return self.remove()
                            	endif
                            
                            	call self.update(self.cur_stop, change_len, change_len)
                            	if !empty(self.mirrors)
                            		call self.update_mirrors(change_len)
                            	endif
                            
                            	let self.prev_len = col('$')
                            endfunction
                            
                            " Actually update the mirrors for any changed text
    1              0.000002 function! s:state_update_mirrors(change) dict abort
                            	let newWordLen = self.end_col - self.start_col
                            	let newWord = strpart(getline('.'), self.start_col - 1, newWordLen)
                            	let changeLen = a:change
                            	let curLine = line('.')
                            	let curCol = col('.')
                            	let oldStartSnip = self.start_col
                            	let i = 0
                            
                            	for mirror in self.mirrors
                            		for stop in values(filter(copy(self.stops), 'v:key != 0'))
                            			if type(stop.placeholder) == type(0)
                            				if mirror.line == stop.line && mirror.col > stop.col
                            							\ && mirror.col < stop.col + stop.placeholder
                            					let stop.placeholder += changeLen
                            				endif
                            			endif
                            		endfor
                            
                            		if has_key(mirror, 'oldSize')
                            			" recover the old size deduce the endline
                            			let oldSize = mirror.oldSize
                            		else
                            			" first time, we use the intitial size
                            			let oldSize = strlen(newWord)
                            		endif
                            
                            		" Split the line into three parts: the mirror, what's before it, and
                            		" what's after it. Then combine them using the new mirror string.
                            		" Subtract one to go from column index to byte index
                            
                            		let theline = getline(mirror.line)
                            
                            		" part before the current mirror
                            		let beginline  = strpart(theline, 0, mirror.col - 1)
                            
                            		" current mirror transformation, and save size
                            		let wordMirror= substitute(newWord, get(mirror, 'pat', ''), get(mirror, 'sub', ''), get(mirror, 'flags', ''))
                            		let mirror.oldSize = strlen(wordMirror)
                            
                            		" end of the line, use the oldSize because with the transformation,
                            		" the size of the mirror can be different from those of the snippet
                            		let endline    = strpart(theline, mirror.col + oldSize -1)
                            
                            		" Update other object on the line
                            		call self.update(mirror, changeLen, mirror.oldSize - oldSize)
                            
                            		" reconstruct the line
                            		let update = beginline.wordMirror.endline
                            
                            		call setline(mirror.line, update)
                            	endfor
                            
                            	" Reposition the cursor in case a var updates on the same line but before
                            	" the current tabstop
                            	if oldStartSnip != self.start_col || mode() == 'i'
                            		call cursor(0, curCol + self.start_col - oldStartSnip)
                            	endif
                            endfunction
                            
    1              0.000002 function! s:state_find_update_objects(item) dict abort
                            	let item = a:item
                            	let item.update_objects = []
                            
                            	" Filter the zeroth stop because it's duplicated as the last
                            	for stop in values(filter(copy(self.stops), 'v:key != 0'))
                            		if stop.line == item.line && stop.col > item.col
                            			call add(item.update_objects, stop)
                            		endif
                            
                            		for mirror in get(stop, 'mirrors', [])
                            			if mirror.line == item.line && mirror.col > item.col
                            				call add(item.update_objects, mirror)
                            			endif
                            		endfor
                            	endfor
                            
                            	return item.update_objects
                            endfunction
                            
    1              0.000002 function! s:state_update(item, change_len, mirror_change) dict abort
                            	let item = a:item
                            	if !exists('item.update_objects')
                            		let item.update_objects = self.find_update_objects(a:item)
                            	endif
                            	let to_update = item.update_objects
                            
                            	for obj in to_update
                            		" object does not necessarly have the same decalage
                            		" than mirrors if mirrors use regexp
                            		let obj.col += a:mirror_change
                            		if obj is self.cur_stop
                            			let self.start_col += a:change_len
                            			let self.end_col += a:change_len
                            		endif
                            	endfor
                            endfunction
                            
    1   0.000762   0.000553 call extend(s:state_proto, snipmate#util#add_methods(s:sfile(), 'state',
                            			\ [ 'remove', 'set_stop', 'jump_stop', 'remove_nested',
                            			\ 'select_word', 'update_changes', 'update_mirrors',
                            			\ 'find_next_stop', 'find_update_objects', 'update' ]), 'error')
                            
                            " vim:noet:sw=4:ts=4:ft=vim

SCRIPT  /Users/brettmz-admin/dev_trees/myvim/bundle/vim-snipmate/autoload/snipmate/util.vim
Sourced 1 time
Total time:   0.000041
 Self time:   0.000041

count  total (s)   self (s)
                            " The next function was based on s:function and s:add_methods in fugitive
                            " <https://github.com/tpope/vim-fugitive/blob/master/plugin/fugitive.vim>
    1              0.000004 function! snipmate#util#add_methods(sfile, namespace, methods) abort
                            	let dict = {}
                            	for name in a:methods
                            		let dict[name] = function(join([matchstr(a:sfile, '<SNR>\d\+'),
                                                \ a:namespace, name], '_'))
                            	endfor
                            	return dict
                            endfunction
                            
    1              0.000002 function! snipmate#util#eval(arg)
                                try
                                    let ret = eval(a:arg)
                                catch
                                    echohl ErrorMsg
                                    echom 'SnipMate:Expression: ' . v:exception
                                    echohl None
                                    let ret = ''
                                endtry
                                return type(ret) == type('') ? ret : string(ret)
                            endfunction
                            
    1              0.000002 function! snipmate#util#tabwidth()
                                if &sts > 0
                                    return &sts
                                else
                                    return exists('*shiftwidth') ? shiftwidth() : &sw
                                endif
                            endfunction

SCRIPT  /Users/brettmz-admin/dev_trees/myvim/bundle/vim-snipmate/autoload/snipmate/legacy.vim
Sourced 1 time
Total time:   0.000138
 Self time:   0.000138

count  total (s)   self (s)
    1              0.000006 let s:sigil = nr2char(31)
    1              0.000003 let snipmate#legacy#sigil = s:sigil
                            
                            " Prepare snippet to be processed by s:BuildTabStops
    1              0.000003 function! snipmate#legacy#process_snippet(snip) abort
                            	let snippet = a:snip
                            	let esc_bslash = '\%(\\\@<!\%(\\\\\)*\)\@<='
                            
                            	if exists('b:snipmate_visual')
                            		let visual = substitute(b:snipmate_visual, "\n$", '', '')
                            		unlet b:snipmate_visual
                            	else
                            		let visual = ''
                            	endif
                                    let snippet = s:substitute_visual(snippet, visual)
                            
                            	" Evaluate eval (`...`) expressions.
                            	" Backquotes prefixed with a backslash "\" are ignored.
                            	" And backslash can be escaped by doubling it.
                            	" Using a loop here instead of a regex fixes a bug with nested "\=".
                            	if stridx(snippet, '`') != -1
                            		let new = []
                            		let snip = split(snippet, esc_bslash . '`', 1)
                            		let isexp = 0
                            		for i in snip
                            			if isexp
                            				call add(new, substitute(snipmate#util#eval(i),
                                                                        \ "\n\\%$", '', ''))
                            			else
                            				call add(new, i)
                            			endif
                            			let isexp = !isexp
                            		endfor
                            		let snippet = join(new, '')
                            		let snippet = substitute(snippet, "\r", "\n", 'g')
                            		let snippet = substitute(snippet, '\\`', "`", 'g')
                            	endif
                            
                            	" Place all text after a colon in a tab stop after the tab stop
                            	" (e.g. "${#:foo}" becomes "${:foo}foo").
                            	" This helps tell the position of the tab stops later.
                            	let snippet = substitute(snippet, esc_bslash . '\$\({\d\+:\(.\{-}\)}\|{\d\+}\)', s:sigil . '\1\2', 'g')
                            	let snippet = substitute(snippet, esc_bslash . '\$\(\d\+\)', s:sigil . '\1', 'g')
                            	let snippet = substitute(snippet, esc_bslash . '\\\$', '$', 'g')
                            	let snippet = substitute(snippet, '\\\\', "\\", 'g')
                            
                            	" Update the a:snip so that all the $# become the text after
                            	" the colon in their associated ${#}.
                            	" (e.g. "${1:foo}" turns all "$1"'s into "foo")
                            	let i = 0
                            	if snippet !~ s:sigil . '{0'
                            		let snippet .= s:sigil . '{0}'
                            	endif
                            	while snippet =~ s:sigil.'{'.i
                            		let s = matchstr(snippet, s:sigil . '{' . i . ':\zs.\{-}\ze}')
                            		if s != ''
                            			let snippet = substitute(snippet, s:sigil . i, s.'&', 'g')
                            		endif
                            		let i += 1
                            	endw
                            
                            	if &et " Expand tabs to spaces if 'expandtab' is set.
                            		return substitute(snippet, '\t', repeat(' ', snipmate#util#tabwidth()), 'g')
                            	endif
                            	return snippet
                            endfunction
                            
                            " Builds a list of a list of each tab stop in the snippet containing:
                            " 1.) The tab stop's line number.
                            " 2.) The tab stop's column number
                            "     (by getting the length of the string between the last "\n" and the
                            "     tab stop).
                            " 3.) The length of the text after the colon for the current tab stop
                            "     (e.g. "${1:foo}" would return 3).
                            " 4.) If the "${#:}" construct is given, another list containing all
                            "     the matches of "$#", to be replaced with the placeholder. This list is
                            "     composed the same way as the parent; the first item is the line number,
                            "     and the second is the column.
    1              0.000004 function! snipmate#legacy#build_stops(snip, lnum, col, indent) abort
                            	let stops = {}
                            	let i = 0
                            	let withoutVars = substitute(a:snip, s:sigil . '\d\+', '', 'g')
                            	while a:snip =~ s:sigil . '{' . i
                            		let beforeTabStop = matchstr(withoutVars, '^.*\ze'.s:sigil .'{'.i.'\D')
                            		let withoutOthers = substitute(withoutVars, ''.s:sigil .'{\('.i.'\D\)\@!\d\+.\{-}}', '', 'g')
                            
                            		let stops[i] = {}
                            		let stops[i].line = a:lnum + s:count(beforeTabStop, "\n")
                            		let stops[i].col = a:indent + len(matchstr(withoutOthers, '[^\n]\{-}\ze'.s:sigil .'{'.i.'\D'))
                            		let stops[i].placeholder = 0
                            		let stops[i].mirrors = []
                            		if stops[i].line == a:lnum
                            			let stops[i].col += a:col
                            		endif
                            
                            		" Get all $# matches in another list, if ${#:name} is given
                            		if withoutVars =~ printf('%s{%d:', s:sigil, i)
                            			let stops[i].placeholder = len(matchstr(withoutVars, ''.s:sigil .'{'.i.':\zs.\{-}\ze}'))
                            			let withoutOthers = substitute(a:snip, ''.s:sigil .'{\d\+.\{-}}\|'.s:sigil .''.i.'\@!\d\+', '', 'g')
                            
                            			while match(withoutOthers, ''.s:sigil .''.i.'\(\D\|$\)') != -1
                            				let stops[i].mirrors = get(stops[i], 'mirrors', [])
                            				let beforeMark = matchstr(withoutOthers,
                            							\ printf('^.\{-}\ze%s%s%d\(\D\|$\)',
                            							\ repeat('.', stops[i].placeholder), s:sigil, i))
                            				let line = a:lnum + s:count(beforeMark, "\n")
                            				let col = a:indent + (line > a:lnum
                            				                           \ ? len(matchstr(beforeMark, '.*\n\zs.*'))
                            				                           \ : a:col + len(beforeMark))
                            				call add(stops[i].mirrors, { 'line' : line, 'col' : col })
                            				let withoutOthers = substitute(withoutOthers, ''.s:sigil .''.i.'\ze\(\D\|$\)', '', '')
                            			endw
                            		endif
                            		let i += 1
                            	endw
                            	let stops[i] = stops[0]
                            	return [stops, i + 1]
                            endfunction
                            
    1              0.000004 function! s:substitute_visual(snippet, visual) abort
                                let lines = []
                                for line in split(a:snippet, "\n")
                                    let indent = matchstr(line, '^\t\+')
                                    call add(lines, substitute(line, '{VISUAL}',
                                                \ substitute(escape(a:visual, '%\'), "\n", "\n" . indent, 'g'), 'g'))
                                endfor
                                return join(lines, "\n")
                            endfunction
                            
                            " Counts occurences of haystack in needle
    1              0.000002 function! s:count(haystack, needle) abort
                            	let counter = 0
                            	let index = stridx(a:haystack, a:needle)
                            	while index != -1
                            		let index = stridx(a:haystack, a:needle, index+1)
                            		let counter += 1
                            	endw
                            	return counter
                            endfunction

FUNCTION  <SNR>100_substitute_visual()
    Defined: ~/dev_trees/myvim/bundle/vim-snipmate/autoload/snipmate/legacy.vim:120
Called 1 time
Total time:   0.000082
 Self time:   0.000082

count  total (s)   self (s)
    1              0.000001     let lines = []
    4              0.000012     for line in split(a:snippet, "\n")
    3              0.000016         let indent = matchstr(line, '^\t\+')
    3              0.000039         call add(lines, substitute(line, '{VISUAL}', substitute(escape(a:visual, '%\'), "\n", "\n" . indent, 'g'), 'g'))
    4              0.000002     endfor
    1              0.000004     return join(lines, "\n")

FUNCTION  <SNR>87_CachedSnips()
    Defined: ~/dev_trees/myvim/bundle/vim-snipmate/autoload/snipMate.vim:328
Called 2 times
Total time:   0.007231
 Self time:   0.000106

count  total (s)   self (s)
    2              0.000026 	let mtime = getftime(a:file)
    2              0.000009 	if has_key(s:cache, a:file) && s:cache[a:file].mtime >= mtime
                            		return s:cache[a:file].contents
    2              0.000001 	endif
    2              0.000008 	let s:cache[a:file] = {}
    2              0.000007 	let s:cache[a:file].mtime = mtime
    2   0.007167   0.000042 	let s:cache[a:file].contents = snipMate#ReadSnippetsFile(a:file)
    2              0.000004 	return s:cache[a:file].contents

FUNCTION  snipMate#ReadSnippetsFile()
    Defined: ~/dev_trees/myvim/bundle/vim-snipmate/autoload/snipMate.vim:208
Called 2 times
Total time:   0.007125
 Self time:   0.007125

count  total (s)   self (s)
    2              0.000004 	let result = []
    2              0.000003 	let new_scopes = []
    2              0.000129 	if !filereadable(a:file) | return [result, new_scopes] | endif
    2              0.000004 	let inSnip = 0
    2              0.000003 	let line_no = 0
    2              0.000008 	let snipversion = get(g:snipMate, 'snippet_version', 0)
  374              0.002075 	for line in readfile(a:file) + ["\n"]
  372              0.000424 		let line_no += 1
                            
  372              0.000792 		if inSnip && (line[0] == "\t" || line == '')
  333              0.001122 			let content .= strpart(line, 1)."\n"
  333              0.000262 			continue
   39              0.000040 		elseif inSnip
   34              0.000182 			call add(result, [trigger, name,     content[:-2], bang, snipversion])
   34              0.000044 			let inSnip = 0
   39              0.000029 		endif
                            
   39              0.000082 		if line[:6] == 'snippet'
   34              0.000035 			let inSnip = 1
   34              0.000070 			let bang = (line[7] == '!')
   34              0.000032 			if bang
                            				let bang += line[8] == '!'
   34              0.000028 			endif
   34              0.000095 			let trigger = strpart(line, 8 + bang)
   34              0.000040 			let name = ''
   34              0.000097 			let space = stridx(trigger, ' ') + 1
   34              0.000033 			if space " Process multi snip
    1              0.000003 				let name = strpart(trigger, space)
    1              0.000003 				let trigger = strpart(trigger, 0, space - 1)
   34              0.000020 			endif
   34              0.000040 			let content = ''
   34              0.000157 			if trigger =~ '^\s*$' " discard snippets with empty triggers
                            				echom 'Invalid snippet in' a:file 'near line' line_no
                            				let inSnip = 0
   34              0.000023 			endif
    5              0.000009 		elseif line[:6] == 'extends'
                            			call extend(new_scopes, map(split(strpart(line, 8)), "substitute(v:val, ',*$', '', '')"))
    5              0.000009 		elseif line[:6] == 'version'
                            			let snipversion = +strpart(line, 8)
   39              0.000023 		endif
   41              0.000034 	endfor
    2              0.000007 	return [result, new_scopes]

FUNCTION  <SNR>98_state_set_stop()
    Defined: ~/dev_trees/myvim/bundle/vim-snipmate/autoload/snipmate/jumping.vim:36
Called 1 time
Total time:   0.000386
 Self time:   0.000058

count  total (s)   self (s)
    1   0.000024   0.000007 	call self.find_next_stop(a:backwards)
    1              0.000003 	let self.cur_stop    = self.stops[self.stop_no]
    1              0.000008 	let self.stop_len = (type(self.cur_stop.placeholder) == type(0)) ? self.cur_stop.placeholder : len(snipMate#placeholder_str(self.stop_no, self.stops))
    1              0.000002 	let self.start_col   = self.cur_stop.col
    1              0.000002 	let self.end_col     = self.start_col + self.stop_len
    1              0.000003 	let self.mirrors     = get(self.cur_stop, 'mirrors', [])
    1              0.000003 	let self.old_mirrors = deepcopy(self.mirrors)
    1              0.000004 	call cursor(self.cur_stop.line, self.cur_stop.col)
    1              0.000002 	let self.prev_len    = col('$')
    1              0.000001 	let self.changed = 0
    1   0.000025   0.000007 	let ret = self.select_word()
    1              0.000003 	if (self.stop_no == 0 || self.stop_no == self.stop_count - 1) && !a:backwards
    1   0.000299   0.000006 		call self.remove()
    1              0.000001 	endif
    1              0.000001 	return ret

FUNCTION  <SNR>87_insert_snippet_text()
    Defined: ~/dev_trees/myvim/bundle/vim-snipmate/autoload/snipMate.vim:60
Called 1 time
Total time:   0.000183
 Self time:   0.000183

count  total (s)   self (s)
    1              0.000003 	let line = getline(a:lnum)
    1              0.000002 	let col = a:col
    1              0.000008 	let snippet = type(a:snippet) == type([]) ? a:snippet : split(a:snippet, "\n", 1)
    1              0.000001 	let lnum = a:lnum
                            
                            	" Keep text after the cursor
    1              0.000003 	let afterCursor = strpart(line, col - 1)
    1              0.000002 	if afterCursor != "\t" && afterCursor != ' '
    1              0.000003 		let line = strpart(line, 0, col - 1)
                            	else
                            		let afterCursor = ''
                            		" For some reason the cursor needs to move one right after this
                            		if line != '' && col == 1 && &ve != 'all' && &ve != 'onemore'
                            			let col += 1
                            		endif
    1              0.000000 	endif
                            
    1              0.000006 	call setline(lnum, '')
    1              0.000013 	call append(lnum, repeat([''], len(snippet) - 1))
                            
    4              0.000005 	for item in snippet
    3              0.000011 		let add = lnum == a:lnum ? line : strpart(line, 0, a:indent - 1)
                            
    3              0.000016 		if !(empty(item) || (type(item) == type([]) && empty(item[0])))
    3              0.000007 			if type(item) == type([])
                            				call setline(lnum, add . snipMate#sniplist_str(item, b:snip_state.stops))
    3              0.000003 			else
    3              0.000039 				call setline(lnum, add . substitute(item, printf('%s\d\+\|%s{\d\+.\{-}}', g:snipmate#legacy#sigil, g:snipmate#legacy#sigil), '', 'g'))
    3              0.000001 			endif
    3              0.000002 		endif
                            
    3              0.000003 		let lnum += 1
    4              0.000005 	endfor
                            
    1              0.000005 	call setline(lnum - 1, getline(lnum - 1) . afterCursor)
                            
    1              0.000001 	return col

FUNCTION  1()
    Defined: ~/dev_trees/myvim/bundle/tlib_vim/autoload/tlib/Object.vim:57
Called 5 times
Total time:   0.000518
 Self time:   0.000224

count  total (s)   self (s)
    5              0.000127     let object = deepcopy(self)
    5              0.000013     let s:id_counter += 1
    5              0.000012     let object._id = s:id_counter
    5              0.000017     if a:0 >= 1 && !empty(a:1)
                                    " call object.Extend(deepcopy(a:1))
    4   0.000323   0.000029         call object.Extend(a:1)
    5              0.000004     endif
    5              0.000008     return object

FUNCTION  8()
    Defined: ~/dev_trees/myvim/bundle/tlib_vim/autoload/tlib/World.vim:118
Called 1 time
Total time:   0.000012
 Self time:   0.000012

count  total (s)   self (s)
    1              0.000003     if a:value ==# 'filename'
                                    call self.Set_highlight_filename()
                                    let self.display_format = 'world.FormatFilename(%s)'
    1              0.000001     else
    1              0.000002         let self.display_format = a:value
    1              0.000001     endif

FUNCTION  <SNR>98_state_select_word()
    Defined: ~/dev_trees/myvim/bundle/vim-snipmate/autoload/snipmate/jumping.vim:93
Called 1 time
Total time:   0.000018
 Self time:   0.000018

count  total (s)   self (s)
    1              0.000001 	let len = self.stop_len
    1              0.000003 	if !len | return '' | endif
    1              0.000002 	let l = col('.') != 1 ? 'l' : ''
    1              0.000003 	if &sel == 'exclusive'
                            		return "\<esc>".l.'v'.len."l\<c-g>"
    1              0.000001 	endif
    1              0.000005 	return len == 1 ? "\<esc>".l.'gh' : "\<esc>".l.'v'.(len - 1)."l\<c-g>"

FUNCTION  tlib#Filter_cnf#New()
    Defined: ~/dev_trees/myvim/bundle/tlib_vim/autoload/tlib/Filter_cnf.vim:22
Called 1 time
Total time:   0.000101
 Self time:   0.000010

count  total (s)   self (s)
    1   0.000099   0.000008     let object = s:prototype.New(a:0 >= 1 ? a:1 : {})
    1              0.000001     return object

FUNCTION  <SNR>98_state_remove()
    Defined: ~/dev_trees/myvim/bundle/vim-snipmate/autoload/snipmate/jumping.vim:16
Called 1 time
Total time:   0.000293
 Self time:   0.000293

count  total (s)   self (s)
                            	" Remove all autocmds in group snipmate_changes in the current buffer
    1              0.000002 	unlet! b:snip_state
    1              0.000290 	silent! au! snipmate_changes * <buffer>

FUNCTION  35()
    Defined: ~/dev_trees/myvim/bundle/tlib_vim/autoload/tlib/World.vim:633
Called 1 time
Total time:   0.001568
 Self time:   0.000530

count  total (s)   self (s)
    1              0.000004     Tlibtrace 'tlib', a:match_mode
    1              0.000004     if !empty(a:match_mode)
    1              0.000002         unlet self.matcher
    1              0.000001         try
    1   0.001543   0.000505             let self.matcher = tlib#Filter_{a:match_mode}#New()
    1              0.000006             call self.matcher.Init(self)
                                    catch /^Vim\%((\a\+)\)\=:E117/
                                        throw 'tlib: Unknown mode for tlib#input#filter_mode: '. a:match_mode
    1              0.000001         endtry
    1              0.000001     endif

FUNCTION  <SNR>87_snippet_filenames()
    Defined: ~/dev_trees/myvim/bundle/vim-snipmate/autoload/snipMate.vim:339
Called 2 times
Total time:   0.000102
 Self time:   0.000102

count  total (s)   self (s)
    2              0.000006 	let mid = ['', '_*', '/*']
    2              0.000031 	let mid += map(copy(mid), "'/' . a:trigger . '*' . v:val")
    2              0.000037 	call map(mid, "'snippets/' . a:scope . v:val . '.snippet'")
    2              0.000027 	return map(mid[:2], 'v:val . "s"') + mid[3:]

FUNCTION  <SNR>87_info_from_filename()
    Defined: ~/dev_trees/myvim/bundle/vim-snipmate/autoload/snipMate.vim:294
Called 2 times
Total time:   0.000101
 Self time:   0.000101

count  total (s)   self (s)
    2              0.000025 	let parts = split(fnamemodify(a:file, ':r'), '/')
    2              0.000023 	let snipidx = len(parts) - index(reverse(copy(parts)), 'snippets') - 1
    2              0.000021 	let rtp_prefix = join(parts[(snipidx - (parts[snipidx - 1] == 'after' ? 3 : 2)):snipidx - 1], '/')
    2              0.000006 	let trigger = get(parts, snipidx + 2, '')
    2              0.000015 	let desc = get(parts, snipidx + 3, get(g:snipMate, 'override', 0) ? '' : fnamemodify(a:file, ':t'))
    2              0.000005 	return [rtp_prefix, trigger, desc]

FUNCTION  <SNR>29_SetDefaultCompletionType()
    Defined: ~/dev_trees/myvim/bundle/supertab/plugin/supertab.vim:308
Called 2 times
Total time:   0.000060
 Self time:   0.000060

count  total (s)   self (s)
    2              0.000036   if exists('b:SuperTabDefaultCompletionType') && (!exists('b:complCommandLine') || !b:complCommandLine)
                                call SuperTabSetCompletionType(b:SuperTabDefaultCompletionType)
    2              0.000005   endif

FUNCTION  tlib#World#New()
    Defined: ~/dev_trees/myvim/bundle/tlib_vim/autoload/tlib/World.vim:110
Called 1 time
Total time:   0.001819
 Self time:   0.000028

count  total (s)   self (s)
    1   0.000189   0.000009     let object = s:prototype.New(a:0 >= 1 ? a:1 : {})
    1   0.001628   0.000017     call object.SetMatchMode(tlib#var#Get('tlib#input#filter_mode', 'g', 'cnf'))
    1              0.000001     return object

FUNCTION  tlib#Filter_glob#New()
    Defined: ~/dev_trees/myvim/bundle/tlib_vim/autoload/tlib/Filter_glob.vim:24
Called 1 time
Total time:   0.000050
 Self time:   0.000011

count  total (s)   self (s)
    1   0.000048   0.000009     let object = s:prototype.New(a:0 >= 1 ? a:1 : {})
    1              0.000001     return object

FUNCTION  tlib#Object#New()
    Defined: ~/dev_trees/myvim/bundle/tlib_vim/autoload/tlib/Object.vim:52
Called 2 times
Total time:   0.000228
 Self time:   0.000020

count  total (s)   self (s)
    2   0.000228   0.000020     return s:prototype.New(a:0 >= 1 ? a:1 : {})

FUNCTION  47()
    Defined: ~/dev_trees/myvim/bundle/tlib_vim/autoload/tlib/World.vim:788
Called 1 time
Total time:   0.000203
 Self time:   0.000043

count  total (s)   self (s)
    1   0.000069   0.000016     TVarArg ['reset_scratch', 0]
                                " TVarArg ['reset_scratch', 1]
    1              0.000003     Tlibtrace 'tlib', reset_scratch
    1              0.000001     if self.sticky
                                    return 0
    1              0.000001     else
    1   0.000116   0.000009         let rv = tlib#scratch#CloseScratch(self, reset_scratch)
    1              0.000002         Tlibtrace 'tlib', rv
    1              0.000002         if rv
                                        call self.SwitchWindow('win')
    1              0.000001         endif
    1              0.000001         return rv
                                endif

FUNCTION  <SNR>37_YRInsertLeave()
    Defined: ~/dev_trees/myvim/bundle/yankring/plugin/yankring.vim:2395
Called 2 times
Total time:   0.013834
 Self time:   0.000142

count  total (s)   self (s)
                                " The YankRing uses omaps to execute the prescribed motion
                                " and then appends to the motion a call to a YankRing 
                                " function to record the contents of the changed register.
                                "
                                " We cannot append a function call to the end of a motion
                                " that results in Insert mode.  For example, any command
                                " like 'cw' enters insert mode.  Appending a function call
                                " after the w, simply writes out the call as if the user 
                                " typed it.
                                "
                                " Using the InsertLeave event, allows us to capture the 
                                " contents of any changed register after it completes.
                                
    2   0.013141   0.000067     call YRRecord(s:YRRegister())
                            
                                " When performing a change (not a yank or delete)
                                " it is not possible to call <SID>yrrecord at the end
                                " of the command (or it's contents will be inserted 
                                " into the buffer instead of executed).
                                " So, when using ".", we have to remove the _zap_
                                " keys and then re-add them back again after we 
                                " record the updates.
    2              0.000004     if s:yr_remove_omap_dot == 1
    2   0.000648   0.000030         call s:YRMapsCreate('add_only_zap_keys')
    2              0.000002     endif
                            

FUNCTION  <SNR>98_state_find_next_stop()
    Defined: ~/dev_trees/myvim/bundle/vim-snipmate/autoload/snipmate/jumping.vim:22
Called 1 time
Total time:   0.000017
 Self time:   0.000017

count  total (s)   self (s)
    1              0.000002 	let self.stop_no += a:backwards? -1 : 1
    1              0.000004 	while !has_key(self.stops, self.stop_no)
                            		if self.stop_no == self.stop_count
                            			let self.stop_no = 0
                            		endif
                            		if self.stop_no <= 0 && a:backwards
                            			let self.stop_no = self.stop_count - 1
                            		endif
                            		let self.stop_no += a:backwards? -1 : 1
    1              0.000001 	endwhile

FUNCTION  <SNR>37_YRWindowUpdate()
    Defined: ~/dev_trees/myvim/bundle/yankring/plugin/yankring.vim:1880
Called 2 times
Total time:   0.000048
 Self time:   0.000048

count  total (s)   self (s)
    2              0.000014     let orig_win_bufnr = bufwinnr('%')
                            
                                " Switch to the yankring buffer
                                " only if it is already visible
    2              0.000010     if bufwinnr(s:yr_buffer_id) != -1
                                    call s:YRShow(0)
                                    " Switch back to the original buffer
                                    exec orig_win_bufnr . "wincmd w"
    2              0.000002     endif

FUNCTION  tlib#arg#Let()
    Defined: ~/dev_trees/myvim/bundle/tlib_vim/autoload/tlib/arg.vim:26
Called 4 times
Total time:   0.000491
 Self time:   0.000258

count  total (s)   self (s)
    4              0.000013     let default = a:0 >= 1 ? a:1 : ''
    4              0.000053     let list = map(copy(a:list), 'type(v:val) == 3 ? v:val : [v:val, default]')
    4   0.000405   0.000172     let args = map(range(1, len(list)), 'call("tlib#arg#Get", [v:val] + list[v:val - 1])')
    4              0.000015     return join(args, ' | ')

FUNCTION  <SNR>98_sfile()
    Defined: ~/dev_trees/myvim/bundle/vim-snipmate/autoload/snipmate/jumping.vim:1
Called 1 time
Total time:   0.000007
 Self time:   0.000007

count  total (s)   self (s)
    1              0.000006 	return expand('<sfile>')

FUNCTION  <SNR>37_YRHistoryRead()
    Defined: ~/dev_trees/myvim/bundle/yankring/plugin/yankring.vim:1795
Called 2 times
Total time:   0.000573
 Self time:   0.000573

count  total (s)   self (s)
    2              0.000006     let refresh_needed  = 1
    2              0.000005     let yr_history_list = []
    2              0.000014     let yr_filename     = s:yr_history_file_{s:yr_history_version}
                            
    2              0.000404     if filereadable(yr_filename)
    2              0.000076         let last_upd = getftime(yr_filename)
                            
    2              0.000012         if s:yr_history_last_upd != 0 && last_upd <= s:yr_history_last_upd
    2              0.000006             let refresh_needed = 0
    2              0.000003         endif
                            
    2              0.000005         if refresh_needed == 1
                                        let s:yr_history_list = readfile(yr_filename)
                                        let s:yr_history_last_upd = last_upd
                                        let s:yr_count = len(s:yr_history_list)
                                        return
    2              0.000003         else
    2              0.000003             return
                                    endif
                                else
                                    if s:yr_history_version == 'v2'
                                        " Check to see if an upgrade is required
                                        " else, let the empty yr_history_list be returned.
                                        if filereadable(s:yr_history_file_v1)
                                            " Perform upgrade to v2 of the history file
                                            call s:YRHistoryUpgrade('v1')
                                            return
                                        endif
                                    endif
                                endif
                            
                                let s:yr_history_list = yr_history_list
                                call s:YRHistorySave()
                            

FUNCTION  GetRmdIndent()
    Defined: /usr/local/Cellar/macvim/8.1-161_1/MacVim.app/Contents/Resources/vim/runtime/indent/rmd.vim:49
Called 6 times
Total time:   0.004109
 Self time:   0.003598

count  total (s)   self (s)
    6              0.000284   if getline(".") =~ '^[ \t]*```{r .*}$' || getline(".") =~ '^[ \t]*```$'
                                return 0
    6              0.000015   endif
    6              0.002506   if search('^[ \t]*```{r', "bncW") > search('^[ \t]*```$', "bncW")
                                return s:RIndent()
    6              0.000471   elseif v:lnum > 1 && search('^---$', "bnW") == 1 && (search('^---$', "nW") > v:lnum || search('^...$', "nW") > v:lnum)
                                return s:GetYamlIndent()
    6              0.000014   else
    6   0.000641   0.000130     return s:GetMdIndent()
                              endif

FUNCTION  snipmate#jumping#state()
    Defined: ~/dev_trees/myvim/bundle/vim-snipmate/autoload/snipmate/jumping.vim:7
Called 1 time
Total time:   0.000007
 Self time:   0.000007

count  total (s)   self (s)
    1              0.000006 	return copy(s:state_proto)

FUNCTION  3()
    Defined: ~/dev_trees/myvim/bundle/tlib_vim/autoload/tlib/Object.vim:89
Called 4 times
Total time:   0.000294
 Self time:   0.000294

count  total (s)   self (s)
    4              0.000070     let super = copy(self)
    4              0.000014     let class = copy(self._class)
                                " TLogVAR class
    4              0.000006     let objid = self._id
    4              0.000018     let thisclass = get(a:dictionary, '_class', [])
    7              0.000025     for c in type(thisclass) == 3 ? thisclass : [thisclass]
                                    " TLogVAR c
    3              0.000010         if index(class, c) == -1
    3              0.000010             call add(class, c)
    3              0.000003         endif
    7              0.000011     endfor
    4              0.000048     call extend(self, a:dictionary)
    4              0.000009     let self._class = class
                                " TLogVAR self._class
    4              0.000006     let self._id    = objid
                                " let self._super = [super] + self._super
    4              0.000013     call insert(self._super, super)
    4              0.000007     return self

FUNCTION  <SNR>73_GetMdIndent()
    Defined: /usr/local/Cellar/macvim/8.1-161_1/MacVim.app/Contents/Resources/vim/runtime/indent/rmd.vim:26
Called 6 times
Total time:   0.000511
 Self time:   0.000511

count  total (s)   self (s)
    6              0.000115   let pline = getline(v:lnum - 1)
    6              0.000050   let cline = getline(v:lnum)
    6              0.000155   if prevnonblank(v:lnum - 1) < v:lnum - 1 || cline =~ '^\s*[-\+\*]\s' || cline =~ '^\s*\d\+\.\s\+'
    3              0.000020     return indent(v:lnum)
    3              0.000036   elseif pline =~ '^\s*[-\+\*]\s'
                                return indent(v:lnum - 1) + 2
    3              0.000028   elseif pline =~ '^\s*\d\+\.\s\+'
                                return indent(v:lnum - 1) + 3
    3              0.000005   endif
    3              0.000029   return indent(prevnonblank(v:lnum - 1))

FUNCTION  snipMate#GetSnippetsForWordBelowCursor()
    Defined: ~/dev_trees/myvim/bundle/vim-snipmate/autoload/snipMate.vim:452
Called 1 time
Total time:   0.029272
 Self time:   0.000154

count  total (s)   self (s)
                            	" Split non-word characters into their own piece
                            	" so 'foo.bar..baz' becomes ['foo', '.', 'bar', '.', '.', 'baz']
                            	" First split just after a \W and then split each resultant string just
                            	" before a \W
    1   0.000090   0.000029 	let parts = filter(tlib#list#Flatten( map(split(a:word, '\W\zs'), 'split(v:val, "\\ze\\W")')), '!empty(v:val)')
                            	" Only look at the last few possibilities. Too many can be slow.
    1              0.000003 	if len(parts) > 5
                            		let parts = parts[-5:]
    1              0.000001 	endif
    1              0.000002 	let lookups = [a:word]
    1              0.000002 	let lookup = ''
    2              0.000004 	for w in reverse(parts)
    1              0.000003 		let lookup = w . lookup
    1              0.000003 		if index(lookups, lookup) == -1
                            			call add(lookups, lookup)
    1              0.000001 		endif
    2              0.000002 	endfor
                            
                            	" Remove empty lookup entries, but only if there are other nonempty lookups
    1              0.000002 	if len(lookups) > 1
                            		call filter(lookups, 'v:val != ""')
    1              0.000000 	endif
                            
    1              0.000002 	let matching_snippets = []
    1              0.000002 	let snippet = ''
                            	" prefer longest word
    2              0.000002 	for word in lookups
    1              0.000006 		let g:snipMate.word = word
    1   0.029093   0.000036 		for [k,snippetD] in items(funcref#Call(g:snipMate['get_snippets'], [snipMate#ScopesByFile(), word]))
                            			" hack: require exact match
    1              0.000003 			if a:exact && k !=# word
                            				continue
    1              0.000001 			endif
    1              0.000003 			call add(matching_snippets, [k, snippetD])
    1              0.000001 			if a:exact
    1              0.000000 				break
                            			endif
    1              0.000003 		endfor
    2              0.000002 	endfor
    1              0.000002 	return matching_snippets

FUNCTION  tlib#arg#Get()
    Defined: ~/dev_trees/myvim/bundle/tlib_vim/autoload/tlib/arg.vim:11
Called 8 times
Total time:   0.000233
 Self time:   0.000233

count  total (s)   self (s)
    8              0.000024     let default = a:0 >= 1 ? a:1 : ''
    8              0.000018     let atest   = a:0 >= 2 ? a:2 : ''
                                " TLogVAR default, atest
    8              0.000023     if !empty(atest)
                                    let atest = ' && (a:'. a:n .' '. atest .')'
    8              0.000008     endif
    8              0.000047     let test = printf('a:0 >= %d', a:n) . atest
    8              0.000072     return printf('let %s = %s ? a:%d : %s', a:var, test, a:n, string(default))

FUNCTION  tlib#var#Get()
    Defined: ~/dev_trees/myvim/bundle/tlib_vim/autoload/tlib/var.vim:52
Called 3 times
Total time:   0.000232
 Self time:   0.000232

count  total (s)   self (s)
    3              0.000035     let var_ = substitute(a:var, '#', '_', 'g')
    6              0.000039     for namespace in split(a:namespace, '\zs')
    5              0.000019         let vname = namespace ==# 'g' ? a:var : var_
    5              0.000019         let var = namespace .':'. vname
    5              0.000019         if exists(var)
    2              0.000008             return {var}
    3              0.000007         elseif namespace ==# 'g'
    1              0.000001             try
    1              0.000007                 let val = {var}
    1              0.000014             catch /^Vim\%((\a\+)\)\=:E\(121\|15\)/
    1              0.000002                 continue
    1              0.000002             endtry
                                        return val
    2              0.000002         endif
    3              0.000005     endfor
    1              0.000002     return a:0 >= 1 ? a:1 : ''

FUNCTION  tlib#list#Flatten()
    Defined: ~/dev_trees/myvim/bundle/tlib_vim/autoload/tlib/list.vim:40
Called 2 times
Total time:   0.000091
 Self time:   0.000061

count  total (s)   self (s)
    2              0.000003     let acc = []
    4              0.000006     for e in a:list
    2              0.000004         if type(e) == 3
    1              0.000003             let acc += tlib#list#Flatten(e)
    1              0.000001         else
    1              0.000003             call add(acc, e)
    2              0.000002         endif
    2              0.000003         unlet e
    4              0.000006     endfor
    2              0.000003     return acc

FUNCTION  snipMate#expandSnip()
    Defined: ~/dev_trees/myvim/bundle/vim-snipmate/autoload/snipMate.vim:20
Called 1 time
Total time:   0.003600
 Self time:   0.001250

count  total (s)   self (s)
    1              0.000002 	let lnum = line('.')
    1              0.000002 	let col = a:col
    1              0.000002 	let line = getline(lnum)
    1              0.000007 	let indent = match(line, '\S\|$') + 1
    1   0.001594   0.000614 	let b:snip_state = snipmate#jumping#state()
                            
    1              0.000002 	if a:version == 1
                            		let [snippet, b:snip_state.stops] = snipmate#parse#snippet(a:snip)
                            		" Build stop/mirror info
                            		let b:snip_state.stop_count = s:build_stops(snippet, b:snip_state.stops, lnum, col, indent)
    1              0.000001 	else
    1   0.001107   0.000534 		let snippet = snipmate#legacy#process_snippet(a:snip)
    1   0.000242   0.000014 		let [b:snip_state.stops, b:snip_state.stop_count] = snipmate#legacy#build_stops(snippet, lnum, col - indent, indent)
    1              0.000001 	endif
                            
                            	" Abort if the snippet is empty
    1              0.000002 	if empty(snippet)
                            		return ''
    1              0.000000 	endif
                            
    1   0.000195   0.000012 	let col = s:insert_snippet_text(snippet, lnum, col, indent)
                            
                            	" Open any folds snippet expands into
    1              0.000001 	if &foldenable
    1              0.000010 		silent! exec lnum . ',' . (lnum + len(snipLines) - 1) . 'foldopen'
    1              0.000000 	endif
                            
    1              0.000002 	aug snipmate_changes
    1              0.000008 		au CursorMoved,CursorMovedI <buffer> if exists('b:snip_state') |     call b:snip_state.update_changes() | else |     silent! au! snipmate_changes * <buffer> | endif
    1              0.000001 	aug END
                            
    1              0.000002 	let b:snip_state.stop_no = 0
    1   0.000401   0.000015 	return b:snip_state.set_stop(0)

FUNCTION  tlib#list#Find()
    Defined: ~/dev_trees/myvim/bundle/tlib_vim/autoload/tlib/list.vim:74
Called 13 times
Total time:   0.000346
 Self time:   0.000195

count  total (s)   self (s)
   13              0.000029     let default = a:0 >= 1 ? a:1 : ''
   13              0.000024     let expr    = a:0 >= 2 ? a:2 : ''
   13   0.000283   0.000132     return get(tlib#list#FindAll(a:list, a:filter, expr), 0, default)

FUNCTION  snipmate#util#add_methods()
    Defined: ~/dev_trees/myvim/bundle/vim-snipmate/autoload/snipmate/util.vim:3
Called 1 time
Total time:   0.000142
 Self time:   0.000142

count  total (s)   self (s)
    1              0.000002 	let dict = {}
   11              0.000013 	for name in a:methods
   10              0.000110 		let dict[name] = function(join([matchstr(a:sfile, '<SNR>\d\+'), a:namespace, name], '_'))
   11              0.000008 	endfor
    1              0.000001 	return dict

FUNCTION  funcref#Call()
    Defined: ~/dev_trees/myvim/bundle/vim-addon-mw-utils/autoload/funcref.vim:28
Called 4 times
Total time:   0.057920
 Self time:   0.000273

count  total (s)   self (s)
    4              0.000013   let args = copy(a:000)
                            
                              " add parameters:
    4              0.000010   if (len(args) < 2)
    2              0.000005     call add(args, [])
    4              0.000003   endif
                            
                            
    4              0.000018   let isDict = type(args[0]) == type({})
                            
                              " prepend parameters which were passed by faked function reference:
    4              0.000014   if isDict &&  has_key(args[0], 'args')
                                let args[1] = args[0]['args']+args[1]
    4              0.000004   endif
                            
                              " always pass self. this way you can call functions from dictionaries not
                              " refering to self
    4              0.000007   if (len(args) < 3)
    4              0.000010     call add(args, {})
    4              0.000004   endif
                            
                              " the funcref overrides self:
    4              0.000009   if isDict && has_key(args[0], 'self')
                                let args[2] = args[0]['self']
    4              0.000002   endif
                            
    4              0.000007   if type(a:1) == 2
                                " funcref: function must have been laoded
                                return call(function('call'), args)
    4              0.000012   elseif isDict && has_key(args[0], 'faked_function_reference')
    3              0.000010     let Fun = args[0]['faked_function_reference']
    3              0.000055     if type(Fun) == type('') && (Fun[:len('return ')-1] == 'return '  || Fun[:len('call ')-1] == 'call ' || Fun[:len('if ')-1] == 'if ' || Fun[:len('let ')-1] == 'let ' || Fun[:len('echo ')-1] == 'echo ' || Fun[:len('exec ')-1] == 'exec ' || Fun[:len('debug ')-1] == 'debug ')
                                  " it doesn't make sense to list all vim commands here
                                  " So if you want to execute another action consider using 
                                  " funcref#Function('exec  '.string('aw')) or such
                            
                                  " function is a String, call exec
    1              0.000002       let ARGS = args[1]
    1              0.000002       let SELF = args[2]
    1              0.000016       exec Fun
    2              0.000002     else 
                                  " pseudo function, let's load it..
    2              0.000004       if type(Fun) == 1
    2              0.000008         if !exists('*'.Fun)
                                      " lazily load function
                                      let file = substitute(substitute(Fun,'#[^#]*$','',''),'#','/','g')
                                      exec 'runtime /autoload/'.file.'.vim'
    2              0.000001         endif
    2              0.000006         let Fun2 = function(Fun)
                                  else
                                    let Fun2 = Fun
    2              0.000002       endif
    2              0.000005       let args[0] = Fun
    2   0.028740   0.000041       return call(function('call'), args)
                                endif
    1              0.000001   else
                                " no function, return the value
    1              0.000002     return args[0]
                              endif

FUNCTION  <SNR>37_YRMRUHas()
    Defined: ~/dev_trees/myvim/bundle/yankring/plugin/yankring.vim:1712
Called 2 times
Total time:   0.000035
 Self time:   0.000035

count  total (s)   self (s)
                                " This function will find a string and return the element #
    2              0.000025     let find_idx = index({a:mru_list}, a:find_str)
                            
    2              0.000004     return find_idx

FUNCTION  <SNR>21_record()
    Defined: ~/dev_trees/myvim/bundle/ctrlp.vim/autoload/ctrlp/mrufiles.vim:59
Called 1 time
Total time:   0.038544
 Self time:   0.000097

count  total (s)   self (s)
    1              0.000013 	if s:locked | retu | en
    1              0.000009 	let bufnr = a:bufnr + 0
    1              0.000010 	let bufname = bufname(bufnr)
    1              0.000008 	if bufnr > 0 && !empty(bufname)
    1              0.000016 		cal filter(s:mrbs, 'v:val != bufnr')
    1              0.000007 		cal insert(s:mrbs, bufnr)
    1   0.038473   0.000026 		cal s:addtomrufs(bufname)
    1              0.000001 	en

FUNCTION  74()
    Defined: ~/dev_trees/myvim/bundle/tlib_vim/autoload/tlib/Filter_cnf.vim:29
Called 1 time
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)

FUNCTION  <SNR>37_YRMRUAdd()
    Defined: ~/dev_trees/myvim/bundle/yankring/plugin/yankring.vim:1727
Called 2 times
Total time:   0.012641
 Self time:   0.000277

count  total (s)   self (s)
                                " Only add new items if they do not already exist in the MRU.
                                " If the item is found, move it to the start of the MRU.
    2              0.000005     let found   = -1
                                " let elem    = a:element
                                " if g:yankring_max_element_length != 0
                                "     let elem    = strpart(a:element, 0, g:yankring_max_element_length)
                                " endif
                                " if s:yr_history_version == 'v1'
                                "     let elem    = escape(elem, '@')
                                "     let elem    = substitute(elem, "\n", s:yr_history_v1_nl, 'g')
                                " else
                                "     let elem    = substitute(elem, "\n", s:yr_history_v2_nl, 'g')
                                " endif
                                " " Append the regtype to the end so we have it available
                                " let elem    = elem.",".a:element_type
                            
    2              0.000012     if strlen(a:element) < g:yankring_min_element_length
                                    return 1
    2              0.000003     endif
                            
    2   0.000191   0.000041     let elem = s:YRMRUElemFormat(a:element, a:element_type)
                            
                                " Refresh the List
    2   0.000602   0.000029     call s:YRHistoryRead()
                            
    2   0.000074   0.000039     let found   = s:YRMRUHas(a:mru_list, elem)
                            
                                " Special case for efficiency, if it is first item in the 
                                " List, do nothing
    2              0.000004     if found != 0
    1              0.000002         if found != -1
                                        " Remove found item since we will add it to the top
    1              0.000014             call remove({a:mru_list}, found)
    1              0.000002         endif
    1              0.000011         call insert({a:mru_list}, elem, 0)
    1   0.011661   0.000055         call s:YRHistorySave()
    2              0.000003     endif
                            
    2              0.000004     return 1

FUNCTION  <SNR>87_source_snippet()
    Defined: ~/dev_trees/myvim/bundle/vim-snipmate/autoload/snipMate.vim:305
Called 2 times
Total time:   0.008028
 Self time:   0.000696

count  total (s)   self (s)
    2              0.000099 	let file = expand('<afile>:p')
    2   0.000132   0.000031 	let [rtp_prefix, trigger, desc] = s:info_from_filename(file)
    2              0.000003 	let new_snips = []
    2              0.000008 	if fnamemodify(file, ':e') == 'snippet'
                            		call add(new_snips, [trigger, desc, join(readfile(file), "\n"), 0, get(g:snipMate, 'snippet_version', 0)])
    2              0.000002 	else
    2   0.007250   0.000019 		let [snippets, extends] = s:CachedSnips(file)
    2              0.000046 		let new_snips = deepcopy(snippets)
    2              0.000008 		call extend(s:lookup_state.extends, extends)
    2              0.000001 	endif
   36              0.000031 	for snip in new_snips
   34              0.000070 		if get(g:snipMate, 'override', 0)
                            			let snip[1] = join([s:lookup_state.scope, snip[1]])
   34              0.000022 		else
   34              0.000200 			let snip[1] = join([s:lookup_state.scope, rtp_prefix, empty(snip[1]) ? desc : snip[1]])
   34              0.000021 		endif
   36              0.000021 	endfor
    2              0.000010 	call extend(s:lookup_state.snips, new_snips)

FUNCTION  <SNR>37_YRHistorySave()
    Defined: ~/dev_trees/myvim/bundle/yankring/plugin/yankring.vim:1832
Called 1 time
Total time:   0.011606
 Self time:   0.011606

count  total (s)   self (s)
    1              0.000016     let yr_filename     = s:yr_history_file_{s:yr_history_version}
                            
    1              0.000048     if len(s:yr_history_list) > g:yankring_max_history
                                    " Remove items which exceed the max # specified
                                    call remove(s:yr_history_list, g:yankring_max_history)
    1              0.000002     endif
                            
    1              0.011368     let rc = writefile(s:yr_history_list, yr_filename)
                            
    1              0.000010     if rc == 0
    1              0.000106         let s:yr_history_last_upd = getftime(yr_filename)
    1              0.000013         let s:yr_count = len(s:yr_history_list)
                                else
                                    call s:YRErrorMsg( 'YRHistorySave: Unable to save yankring history file: '. yr_filename )
    1              0.000003     endif

FUNCTION  snipmate#legacy#build_stops()
    Defined: ~/dev_trees/myvim/bundle/vim-snipmate/autoload/snipmate/legacy.vim:79
Called 1 time
Total time:   0.000228
 Self time:   0.000208

count  total (s)   self (s)
    1              0.000002 	let stops = {}
    1              0.000001 	let i = 0
    1              0.000007 	let withoutVars = substitute(a:snip, s:sigil . '\d\+', '', 'g')
    2              0.000009 	while a:snip =~ s:sigil . '{' . i
    1              0.000011 		let beforeTabStop = matchstr(withoutVars, '^.*\ze'.s:sigil .'{'.i.'\D')
    1              0.000011 		let withoutOthers = substitute(withoutVars, ''.s:sigil .'{\('.i.'\D\)\@!\d\+.\{-}}', '', 'g')
                            
    1              0.000003 		let stops[i] = {}
    1   0.000041   0.000021 		let stops[i].line = a:lnum + s:count(beforeTabStop, "\n")
    1              0.000015 		let stops[i].col = a:indent + len(matchstr(withoutOthers, '[^\n]\{-}\ze'.s:sigil .'{'.i.'\D'))
    1              0.000002 		let stops[i].placeholder = 0
    1              0.000002 		let stops[i].mirrors = []
    1              0.000003 		if stops[i].line == a:lnum
                            			let stops[i].col += a:col
    1              0.000000 		endif
                            
                            		" Get all $# matches in another list, if ${#:name} is given
    1              0.000006 		if withoutVars =~ printf('%s{%d:', s:sigil, i)
    1              0.000010 			let stops[i].placeholder = len(matchstr(withoutVars, ''.s:sigil .'{'.i.':\zs.\{-}\ze}'))
    1              0.000017 			let withoutOthers = substitute(a:snip, ''.s:sigil .'{\d\+.\{-}}\|'.s:sigil .''.i.'\@!\d\+', '', 'g')
                            
    1              0.000007 			while match(withoutOthers, ''.s:sigil .''.i.'\(\D\|$\)') != -1
                            				let stops[i].mirrors = get(stops[i], 'mirrors', [])
                            				let beforeMark = matchstr(withoutOthers, printf('^.\{-}\ze%s%s%d\(\D\|$\)', repeat('.', stops[i].placeholder), s:sigil, i))
                            				let line = a:lnum + s:count(beforeMark, "\n")
                            				let col = a:indent + (line > a:lnum ? len(matchstr(beforeMark, '.*\n\zs.*')) : a:col + len(beforeMark))
                            				call add(stops[i].mirrors, { 'line' : line, 'col' : col })
                            				let withoutOthers = substitute(withoutOthers, ''.s:sigil .''.i.'\ze\(\D\|$\)', '', '')
    1              0.000001 			endw
    1              0.000001 		endif
    1              0.000001 		let i += 1
    2              0.000003 	endw
    1              0.000003 	let stops[i] = stops[0]
    1              0.000002 	return [stops, i + 1]

FUNCTION  pandoc#command#AutoPandoc()
    Defined: ~/dev_trees/myvim/bundle/vim-pandoc/autoload/pandoc/command.vim:132
Called 1 time
Total time:   0.000027
 Self time:   0.000027

count  total (s)   self (s)
    1              0.000004     if g:pandoc#command#autoexec_on_writes == 1
                                    let command = ''
                                    if exists('g:pandoc#command#autoexec_command')
                                        let command = g:pandoc#command#autoexec_command
                                    endif
                                    if exists('b:pandoc_command_autoexec_command')
                                        let command = b:pandoc_command_autoexec_command
                                    endif
                                    exe command
    1              0.000001     endif

FUNCTION  <SNR>87_Glob()
    Defined: ~/dev_trees/myvim/bundle/vim-snipmate/autoload/snipMate.vim:369
Called 456 times
Total time:   0.014172
 Self time:   0.014172

count  total (s)   self (s)
  456              0.013952 		return split(globpath(a:path, a:expr), "\n")

FUNCTION  <SNR>100_count()
    Defined: ~/dev_trees/myvim/bundle/vim-snipmate/autoload/snipmate/legacy.vim:131
Called 1 time
Total time:   0.000020
 Self time:   0.000020

count  total (s)   self (s)
    1              0.000001 	let counter = 0
    1              0.000003 	let index = stridx(a:haystack, a:needle)
    2              0.000003 	while index != -1
    1              0.000003 		let index = stridx(a:haystack, a:needle, index+1)
    1              0.000002 		let counter += 1
    2              0.000003 	endw
    1              0.000001 	return counter

FUNCTION  tlib#input#ListW()
    Defined: ~/dev_trees/myvim/bundle/tlib_vim/autoload/tlib/input.vim:333
Called 1 time
Total time:   0.000337
 Self time:   0.000074

count  total (s)   self (s)
    1   0.000076   0.000016     TVarArg 'cmd'
    1              0.000028     let time0 = str2float(reltimestr(reltime()))
    1              0.000004     Tlibtrace 'tlib', time0
    1              0.000002     let world = a:world
    1              0.000007     if world.pick_last_item >= 1 && stridx(world.type, 'e') == -1 && len(world.base) <= 1
    1   0.000209   0.000006         call world.CloseScratch(1)
    1              0.000003         let rv = get(world.base, 0, world.rv)
    1              0.000003         if stridx(world.type, 'm') != -1
    1              0.000002             return [rv]
                                    else
                                        return rv
                                    endif
                                endif
                                call s:Init(world, cmd)
                                Tlibtrace 'tlib', world.state, world.sticky, world.initial_index
                                " let statusline  = &l:statusline
                                " let laststatus  = &laststatus
                                let showmode = &showmode
                                set noshowmode
                                let lastsearch  = @/
                                let scrolloff = &l:scrolloff
                                let &l:scrolloff = 0
                                let @/ = ''
                                let dlist = []
                                let post_keys = ''
                                " let &laststatus = 2
                            
                                try
                                    while !empty(world.state) && world.state !~ '^exit' && (world.show_empty || !empty(world.base))
                                        let post_keys = ''
                                        Tlibtrace 'tlib', 'while', world.state
                                        let time01 = str2float(reltimestr(reltime()))
                                        Tlibtrace 'tlib', time01, time01 - time0
                                        try
                                            let world = s:RunStateHandlers(world)
                            
                                            let time02 = str2float(reltimestr(reltime()))
                                            Tlibtrace 'tlib', time02, time02 - time0
                                            if world.state =~ '\<reset\>'
                                                call world.Reset()
                                                continue
                                            endif
                            
                                            call s:SetOffset(world)
                            
                                            let time02 = str2float(reltimestr(reltime()))
                                            Tlibtrace 'tlib', time02, time02 - time0
                                            Tlibtrace 'tlib', world.state
                                            if world.state == 'scroll'
                                                let world.prefidx = world.offset
                                                let world.state = 'redisplay'
                                            endif
                            
                                            if world.state =~ '\<sticky\>'
                                                let world.sticky = 1
                                            endif
                            
                                            Tlibtrace 'tlib', world.filter
                                            Tlibtrace 'tlib', world.sticky
                                            if world.state =~ '\<picked\>'
                                                Tlibtrace 'tlib', world.rv
                                                throw 'picked'
                                            elseif world.state =~ '\<pick\>'
                                                let world.rv = world.CurrentItem()
                                                Tlibtrace 'tlib', world.rv
                                                throw 'picked'
                                            elseif world.state =~ 'display'
                                                if world.state =~ '^display'
                                                    let time03 = str2float(reltimestr(reltime()))
                                                    Tlibtrace 'tlib', time03, time03 - time0
                                                    if world.IsValidFilter()
                                                        let time1 = str2float(reltimestr(reltime()))
                                                        Tlibtrace 'tlib', time1, time1 - time0
                                                        call world.BuildTableList()
                                                        let time2 = str2float(reltimestr(reltime()))
                                                        Tlibtrace 'tlib', time2, time2 - time0
                                                        let world.llen = len(world.list)
                                                        if empty(world.index_table)
                                                            let dindex = range(1, world.llen)
                                                            let world.index_width = len(world.llen)
                                                        else
                                                            let dindex = world.index_table
                                                            let world.index_width = len(max(dindex))
                                                        endif
                                                        let time3 = str2float(reltimestr(reltime()))
                                                        Tlibtrace 'tlib', time3, time3 - time0
                                                        if world.llen == 0 && !world.show_empty
                                                            call world.ReduceFilter()
                                                            let world.offset = 1
                                                            continue
                                                        else
                                                            if world.llen == 1
                                                                let world.last_item = world.list[0]
                                                                if world.pick_last_item >= 2
                                                                    " echom 'Pick last item: '. world.list[0]
                                                                    let world.prefidx = '1'
                                                                    throw 'pick'
                                                                endif
                                                            else
                                                                let world.last_item = ''
                                                            endif
                                                        endif
                                                        let time4 = str2float(reltimestr(reltime()))
                                                        Tlibtrace 'tlib', time4, time4 - time0
                                                        Tlibtrace 'tlib', world.idx, world.llen, world.state
                                                        if world.state == 'display'
                                                            if world.idx == '' && world.llen < g:tlib#input#sortprefs_threshold && !world.FilterIsEmpty()
                                                                call world.SetPrefIdx()
                                                            else
                                                                let world.prefidx = world.idx == '' ? world.initial_index : world.idx
                                                            endif
                                                            if world.prefidx > world.llen
                                                                let world.prefidx = world.llen
                                                            elseif world.prefidx < 1
                                                                let world.prefidx = 1
                                                            endif
                                                        endif
                                                        let time5 = str2float(reltimestr(reltime()))
                                                        Tlibtrace 'tlib', time5, time5 - time0
                                                        Tlibtrace 'tlib', world.initial_index, world.prefidx
                                                        Tlibtrace 'tlib', len(world.list)
                                                        let dlist = world.DisplayFormat(world.list)
                                                        Tlibtrace 'tlib', world.prefidx
                                                        let time6 = str2float(reltimestr(reltime()))
                                                        Tlibtrace 'tlib', time6, time6 - time0
                                                        if world.offset_horizontal > 0
                                                            call map(dlist, 'tlib#string#Strcharpart(v:val, world.offset_horizontal)')
                                                        endif
                                                        let time7 = str2float(reltimestr(reltime()))
                                                        Tlibtrace 'tlib', time7, time7 - time0
                                                        let dlist = map(range(0, world.llen - 1), 'printf("%0'. world.index_width .'d", dindex[v:val]) .": ". dlist[v:val]')
                                                        let time8 = str2float(reltimestr(reltime()))
                                                        Tlibtrace 'tlib', time8, time8 - time0
                            
                                                    else
                            
                                                        let dlist = ['Malformed filter']
                            
                                                    endif
                                                else
                                                    if world.prefidx == 0
                                                        let world.prefidx = 1
                                                    endif
                                                endif
                                                Tlibtrace 'tlib', world.idx, world.prefidx
                            
                                                Tlibtrace 'tlib', world.prefidx, world.offset
                                                Tlibtrace 'tlib', world.initial_display, !tlib#char#IsAvailable()
                                                if world.state =~ '\<update\>' || world.initial_display || !tlib#char#IsAvailable()
                                                    call world.DisplayList(world.Query(), dlist)
                                                    call world.FollowCursor()
                                                    let world.initial_display = 0
                                                endif
                                                if world.state =~ '\<hibernate\>'
                                                    let world.state = 'suspend'
                                                else
                                                    let world.state = ''
                                                endif
                                            else
                                                " if world.state == 'scroll'
                                                "     let world.prefidx = world.offset
                                                " endif
                                                call world.DisplayList()
                                                if world.state == 'help' || world.state == 'printlines'
                                                    let world.state = 'display'
                                                else
                                                    let world.state = ''
                                                    call world.FollowCursor()
                                                endif
                                            endif
                                            " TAssert IsNotEmpty(world.scratch)
                                            let world.list_wid = tlib#win#GetID()
                                            let world.list_wnr = winnr()
                            
                                            Tlibtrace 'tlib', world.state, world.next_state
                                            if !empty(world.next_state)
                                                let world.state = world.next_state
                                                let world.next_state = ''
                                            endif
                            
                                            if world.state =~ '\<suspend\>'
                                                let world = tlib#agent#SuspendToParentWindow(world, world.rv)
                                                continue
                                            endif
                            
                                            if world.state =~ '\<eval\>'
                                                let query = matchstr(world.state, '\<eval\[\zs.\{-}\ze\]')
                                                if empty(query)
                                                    let query = 'Waiting for input ... Press ESC to continue'
                                                endif
                                                if has('gui_win32')
                                                    let exec_cmd = input(query, '')
                                                    Tlibtrace 'tlib', exec_cmd
                                                    if exec_cmd == ''
                                                        let world.state = 'redisplay'
                                                    else
                                                        exec exec_cmd
                                                    endif
                                                elseif has('gui_gtk') || has('gui_gtk2')
                                                    let c = s:GetModdedChar(world)
                                                    Tlibtrace 'tlib', c
                                                endif
                                            else
                                                Tlibtrace 'tlib', world.timeout
                                                let c = s:GetModdedChar(world)
                                                Tlibtrace 'tlib', c, has_key(world.key_map[world.key_mode],c)
                                            endif
                                            Tlibtrace 'tlib', c
                                            Tlibtrace 'tlib', world.next_agent, world.next_eval
                                            if !empty(world.next_agent)
                                                let nagent = world.next_agent
                                                let world.next_agent = ''
                                                " let world = call(nagent, [world, world.GetSelectedItems(world.CurrentItem())])
                                                " call s:CheckAgentReturnValue(nagent, world)
                                                let world = s:CallAgent({'agent': nagent}, world, world.GetSelectedItems(world.CurrentItem()))
                                            elseif !empty(world.next_eval)
                                                let selected = world.GetSelectedItems(world.CurrentItem())
                                                let neval = world.next_eval
                                                let world.next_eval = ''
                                                exec neval
                                                call s:CheckAgentReturnValue(neval, world)
                                            elseif world.state != ''
                                                " continue
                                            elseif has_key(world.key_map[world.key_mode], c)
                                                let sr = @/
                                                silent! let @/ = lastsearch
                                                Tlibtrace 'tlib', c, world.key_map[world.key_mode][c]
                                                " TLog "Agent: ". string(world.key_map[world.key_mode][c])
                                                let handler = world.key_map[world.key_mode][c]
                                                Tlibtrace 'tlib', handler
                                                let world = s:CallAgent(handler, world, world.GetSelectedItems(world.CurrentItem()))
                                                silent! let @/ = sr
                                                " continue
                                            elseif c == 13
                                                throw 'pick'
                                            elseif c == 27
                                                Tlibtrace 'tlib', c, world.key_mode
                                                if world.key_mode != 'default'
                                                    let world.key_mode = 'default'
                                                    let world.state = 'redisplay'
                                                else
                                                    let world.state = 'exit empty'
                                                endif
                                            elseif c == "\<LeftMouse>"
                                                if v:mouse_win == world.list_wnr
                                                    let world.prefidx = world.GetLineIdx(v:mouse_lnum)
                                                    " let world.offset  = world.prefidx
                                                    if empty(world.prefidx)
                                                        " call feedkeys(c, 't')
                                                        let c = s:GetModdedChar(world)
                                                        let world.state = 'help'
                                                        continue
                                                    endif
                                                    throw 'pick'
                                                else
                                                    let post_keys = v:mouse_lnum .'gg'. v:mouse_col .'|'. c
                                                    if world.allow_suspend
                                                        let world = tlib#agent#SuspendToParentWindow(world, world.rv)
                                                    else
                                                        let world.state = 'exit empty'
                                                    endif
                                                endif
                                            elseif c == "\<RightMouse>"
                                                if v:mouse_win == world.list_wnr
                                                    call s:BuildMenu(world)
                                                    let world.state = 'redisplay'
                                                    if s:PopupmenuExists() == 1
                                                        " if v:mouse_lnum != line('.')
                                                        " endif
                                                        let world.prefidx = world.GetLineIdx(v:mouse_lnum)
                                                        let world.next_state = 'eval[Waiting for popup menu ... Press ESC to continue]'
                                                        call world.DisplayList()
                                                        if line('w$') - v:mouse_lnum < 6
                                                            popup ]TLibInputListPopupMenu
                                                        else
                                                            popup! ]TLibInputListPopupMenu
                                                        endif
                                                    endif
                                                else
                                                    let post_keys = v:mouse_lnum .'gg'. v:mouse_col .'|'. c
                                                    if world.allow_suspend
                                                        let world = tlib#agent#SuspendToParentWindow(world, world.rv)
                                                    else
                                                        let world.state = 'exit empty'
                                                    endif
                                                endif
                                                Tlibtrace 'tlib', world.prefidx, world.state
                                            elseif has_key(world.key_map[world.key_mode], 'unknown_key')
                                                let agent = world.key_map[world.key_mode].unknown_key.agent
                                                " let world = call(agent, [world, c])
                                                " call s:CheckAgentReturnValue(agent, world)
                                                let world = s:CallAgent({'agent': agent}, world, c)
                                            elseif c >= 32
                                                let world.state = 'display'
                                                let numbase = get(world.numeric_chars, c, -99999)
                                                Tlibtrace 'tlib', numbase, world.numeric_chars, c
                                                if numbase != -99999
                                                    let world.idx .= (c - numbase)
                                                    if len(world.idx) == world.index_width
                                                        let world.prefidx = world.idx
                                                        Tlibtrace 'tlib', world.prefidx
                                                        throw 'pick'
                                                    endif
                                                else
                                                    let world.idx = ''
                                                    Tlibtrace 'tlib', world.filter
                                                    if world.llen > g:tlib#input#livesearch_threshold
                                                        let pattern = input('Filter: ', world.CleanFilter(world.filter[0][0]) . nr2char(c))
                                                        if empty(pattern)
                                                            let world.state = 'exit empty'
                                                        else
                                                            call world.SetFrontFilter(pattern)
                                                            echo
                                                        endif
                                                    elseif c == 124
                                                        call insert(world.filter[0], [])
                                                    else
                                                        call world.PushFrontFilter(c)
                                                    endif
                                                    " continue
                                                    if c == 45 && world.filter[0][0] == '-'
                                                        let world.state = 'redisplay'
                                                    end
                                                endif
                                            else
                                                let world.state = 'redisplay'
                                                " let world.state = 'continue'
                                            endif
                            
                                        catch /^picked$/
                                            call world.ClearAllMarks()
                                            call world.MarkCurrent(world.prefidx)
                                            let world.state = 'exit'
                            
                                        catch /^pick$/
                                            call world.ClearAllMarks()
                                            call world.MarkCurrent(world.prefidx)
                                            let world.state = ''
                            
                                        finally
                                            if world.state =~ '\<suspend\>'
                                                " if !world.allow_suspend
                                                "     echom "Cannot be suspended"
                                                "     let world.state = 'redisplay'
                                                " endif
                                            elseif !empty(world.list) && !empty(world.base)
                                                if empty(world.state)
                                                    let world.rv = world.CurrentItem()
                                                    Tlibtrace 'tlib', world.state, world.rv
                                                endif
                                                for handler in world.post_handlers
                                                    let state = get(handler, 'postprocess', '')
                                                    Tlibtrace 'tlib', handler
                                                    Tlibtrace 'tlib', state
                                                    Tlibtrace 'tlib', world.state
                                                    if state == world.state
                                                        let agent = handler.agent
                                                        let [world, world.rv] = call(agent, [world, world.rv])
                                                        Tlibtrace 'tlib', world.state, world.rv
                                                        call s:CheckAgentReturnValue(agent, world)
                                                    endif
                                                endfor
                                            endif
                                        endtry
                                    endwh
                            
                                    Tlibtrace 'tlib', world.state
                                    Tlibtrace 'tlib', len(world.list)
                                    Tlibtrace 'tlib', world.sel_idx
                                    Tlibtrace 'tlib', world.idx
                                    Tlibtrace 'tlib', world.prefidx
                                    Tlibtrace 'tlib', world.rv
                                    if world.state =~ '\<\(empty\|escape\)\>'
                                        let world.sticky = 0
                                    endif
                                    if world.state =~ '\<suspend\>'
                                        Tlibtrace 'tlib', world.prefidx
                                        " exec world.prefidx
                                        return
                                    elseif world.state =~ '\<empty\>'
                                        " TLog "empty"
                                        Tlibtrace 'tlib', world.type
                                        if stridx(world.type, 'm') != -1
                                            return []
                                        elseif stridx(world.type, 'i') != -1
                                            return 0
                                        else
                                            return ''
                                        endif
                                    elseif !empty(world.return_agent)
                                        Tlibtrace 'tlib', world.return_agent
                                        call world.CloseScratch(1)
                                        " TAssert IsNotEmpty(world.scratch)
                                        return call(world.return_agent, [world, world.GetSelectedItems(world.rv)])
                                    elseif stridx(world.type, 'w') != -1
                                        " TLog "return_world"
                                        return world
                                    elseif stridx(world.type, 'm') != -1
                                        " TLog "return_multi"
                                        return world.GetSelectedItems(world.rv)
                                    elseif stridx(world.type, 'i') != -1
                                        " TLog "return_index"
                                        if empty(world.index_table)
                                            return world.rv
                                        else
                                            return world.index_table[world.rv - 1]
                                        endif
                                    else
                                        " TLog "return_else"
                                        return world.rv
                                    endif
                            
                                finally
                                    call world.Leave()
                            
                                    " Tlibtrace 'tlib', statusline
                                    " let &l:statusline = statusline
                                    " let &laststatus = laststatus
                                    if &showmode != showmode
                                        let &showmode = showmode
                                    endif
                                    silent! let @/  = lastsearch
                                    let &l:scrolloff = scrolloff
                                    if s:PopupmenuExists() == 1
                                        silent! aunmenu ]TLibInputListPopupMenu
                                    endif
                            
                                    Tlibtrace 'tlib', world.state
                                    if world.state !~ '\<suspend\>'
                                        " redraw
                                        Tlibtrace 'tlib', world.sticky, bufnr("%")
                                        if world.sticky
                                            Tlibtrace 'tlib', world.bufnr
                                            if world.scratch_split > 0
                                                if bufwinnr(world.bufnr) == -1
                                                    call world.UseScratch()
                                                endif
                                                let world = tlib#agent#SuspendToParentWindow(world, world.GetSelectedItems(world.rv))
                                            endif
                                        else
                                            Tlibtrace 'tlib', world.state, world.win_id, world.bufnr
                                            if world.CloseScratch(1)
                                                Tlibtrace 'tlib', world.winview
                                                call tlib#win#SetLayout(world.winview)
                                            endif
                                        endif
                                    endif
                                    if world.state !~ '\<norestore\>'
                                        call world.RestoreWindow()
                                    endif
                                    " for i in range(0,5)
                                    "     call getchar(0)
                                    " endfor
                                    echo
                                    redraw!
                                    if !empty(post_keys)
                                        Tlibtrace 'tlib', post_keys
                                        call feedkeys(post_keys)
                                    endif
                                    let world.state = ''
                                endtry

FUNCTION  <SNR>37_YRMapsCreate()
    Defined: ~/dev_trees/myvim/bundle/yankring/plugin/yankring.vim:1460
Called 2 times
Total time:   0.000618
 Self time:   0.000618

count  total (s)   self (s)
                                " 7.1.patch205 introduces the v:operator function which was 
                                " essential to gain the omap support.
    2              0.000006     if s:yr_has_voperator == 1
    2              0.000006         let s:yr_remove_omap_dot   = 1
   16              0.000077         for key in split(g:yankring_zap_keys)
   14              0.000015             try
   14              0.000031                 if key != '@'
   12              0.000304                     exec 'omap <expr>' key 'YRMapsExpression("<SID>", "'. key. '", 1)'
   14              0.000019                 endif
                                        catch
   14              0.000015             endtry
   16              0.000020         endfor
    2              0.000003     endif
                            
    2              0.000039     silent! nmap <expr> @ YRMapsExpression("<SID>", "@", "1")
                            
    2              0.000008     let s:yr_maps_created_zap = 1
                            
    2              0.000005     if a:0 > 0
                                    " We have only removed the _zap_ keys temporarily
                                    " so abandon further changes.
    2              0.000004         return
                                endif
                            
                                " 7.1.patch205 introduces the v:operator function which was essential
                                " to gain the omap support.
                                if s:yr_has_voperator == 1
                                    let s:yr_remove_omap_dot   = 1
                                    " Set option to add and remove _zap_ keys when
                                    " repeating commands
                                    let o_maps = split(g:yankring_o_keys)
                                    " Loop through and prompt the user for all buffer connection parameters.
                                    for key in o_maps
                                        exec 'omap <expr>' key 'YRMapsExpression("<SID>", "'. escape(key,'\"'). '")'
                                    endfor
                                endif
                            
                                " Iterate through a space separated list of mappings and create
                                " calls to the YRYankCount function
                                let n_maps = split(g:yankring_n_keys)
                                " Loop through and prompt the user for all buffer connection parameters.
                                for key in n_maps
                                    " exec 'nnoremap <silent>'.key." :<C-U>YRYankCount '".key."'<CR>"
                                    " exec 'nnoremap <silent>'.key." :<C-U>YRYankCount '".key."'<CR>"
                                    " Andy Wokula's suggestion
                                    exec 'nmap' key key."<SID>yrrecord"
                                endfor
                            
                                if g:yankring_map_dot == 1
                                    if s:yr_has_voperator == 1
                                        nmap <expr> . YRMapsExpression("<SID>", ".")
                                    else
                                        nnoremap <silent> . :<C-U>YRYankCount '.'<CR>
                                    endif
                                endif
                            
                                if g:yankring_v_key != ''
                                    exec 'xnoremap <silent>'.g:yankring_v_key." :YRYankRange 'v'<CR>"
                                endif
                                if g:yankring_del_v_key != ''
                                    for v_map in split(g:yankring_del_v_key)
                                        if strlen(v_map) > 0
                                            try
                                                exec 'xnoremap <silent>'.v_map." :YRDeleteRange 'v'<CR>"
                                            catch
                                            endtry
                                        endif
                                    endfor
                                endif
                                if g:yankring_paste_n_bkey != ''
                                    exec 'nnoremap <silent>'.g:yankring_paste_n_bkey." :<C-U>YRPaste 'P'<CR>"
                                    if g:yankring_paste_using_g == 1
                                        exec 'nnoremap <silent> g'.g:yankring_paste_n_bkey." :<C-U>YRPaste 'gP'<CR>"
                                    endif
                                endif
                                if g:yankring_paste_n_akey != ''
                                    exec 'nnoremap <silent>'.g:yankring_paste_n_akey." :<C-U>YRPaste 'p'<CR>"
                                    if g:yankring_paste_using_g == 1
                                        exec 'nnoremap <silent> g'.g:yankring_paste_n_akey." :<C-U>YRPaste 'gp'<CR>"
                                    endif
                                endif
                                if g:yankring_paste_v_bkey != ''
                                    exec 'xnoremap <silent>'.g:yankring_paste_v_bkey." :<C-U>YRPaste 'P', 'v'<CR>"
                                endif
                                if g:yankring_paste_v_akey != ''
                                    exec 'xnoremap <silent>'.g:yankring_paste_v_akey." :<C-U>YRPaste 'p', 'v'<CR>"
                                endif
                                if g:yankring_replace_n_pkey != ''
                                    exec 'nnoremap <silent>'.g:yankring_replace_n_pkey." :<C-U>YRReplace '-1', 'P'<CR>"
                                endif
                                if g:yankring_replace_n_nkey != ''
                                    exec 'nnoremap <silent>'.g:yankring_replace_n_nkey." :<C-U>YRReplace '1', 'p'<CR>"
                                endif
                            
                                let g:yankring_enabled    = 1
                                let s:yr_maps_created     = 1
                            
                                if exists('*YRRunAfterMaps') 
                                    " This will allow you to override the default maps if necessary
                                    call YRRunAfterMaps()
                                endif

FUNCTION  <SNR>87_snippet_dirs()
    Defined: ~/dev_trees/myvim/bundle/vim-snipmate/autoload/snipMate.vim:419
Called 12 times
Total time:   0.000289
 Self time:   0.000289

count  total (s)   self (s)
   12              0.000284 	return get(g:snipMate, 'snippet_dirs', split(&rtp, ','))

FUNCTION  <SNR>87_ChooseSnippet()
    Defined: ~/dev_trees/myvim/bundle/vim-snipmate/autoload/snipMate.vim:499
Called 1 time
Total time:   0.000115
 Self time:   0.000043

count  total (s)   self (s)
    1              0.000001 	let snippet = []
    1              0.000003 	let keys = keys(a:snippets)
    1              0.000001 	let i = 1
    2              0.000003 	for snip in keys
    1              0.000005 		let snippet += [i.'. '.snip]
    1              0.000001 		let i += 1
    2              0.000001 	endfor
    1              0.000004 	if len(snippet) == 1 || get(g:snipMate, 'always_choose_first', 0) == 1
                            		" there's only a single snippet, choose it
    1              0.000001 		let idx = 0
                            	else
                            		let idx = tlib#input#List('si','select snippet by name',snippet) -1
                            		if idx == -1
                            			return ''
                            		endif
    1              0.000001 	endif
                            	" if a:snippets[..] is a String Call returns it
                            	" If it's a function or a function string the result is returned
    1   0.000082   0.000010 	return funcref#Call(a:snippets[keys(a:snippets)[idx]])

FUNCTION  <SNR>87_GetScopes()
    Defined: ~/dev_trees/myvim/bundle/vim-snipmate/autoload/snipMate.vim:255
Called 1 time
Total time:   0.000169
 Self time:   0.000169

count  total (s)   self (s)
    1              0.000006 	let ret = exists('b:snipMate.scope_aliases') ? copy(b:snipMate.scope_aliases) : {}
    1              0.000004 	let global = get(g:snipMate, 'scope_aliases', {})
   12              0.000021 	for alias in keys(global)
   11              0.000024 		if has_key(ret, alias)
                            			let ret[alias] = join(split(ret[alias], ',') + split(global[alias], ','), ',')
   11              0.000009 		else
   11              0.000028 			let ret[alias] = global[alias]
   11              0.000006 		endif
   12              0.000009 	endfor
    1              0.000001 	return ret

FUNCTION  <SNR>42_Highlight_Matching_Pair()
    Defined: /usr/local/Cellar/macvim/8.1-161_1/MacVim.app/Contents/Resources/vim/runtime/plugin/matchparen.vim:39
Called 210 times
Total time:   0.051059
 Self time:   0.051059

count  total (s)   self (s)
                              " Remove any previous match.
  210              0.002886   if exists('w:paren_hl_on') && w:paren_hl_on
                                silent! call matchdelete(3)
                                let w:paren_hl_on = 0
  210              0.000529   endif
                            
                              " Avoid that we remove the popup menu.
                              " Return when there are no colors (looks like the cursor jumps).
  210              0.002698   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
                                return
  210              0.000357   endif
                            
                              " Get the character under the cursor and check if it's in 'matchpairs'.
  210              0.001882   let c_lnum = line('.')
  210              0.001449   let c_col = col('.')
  210              0.000676   let before = 0
                            
  210              0.001535   let text = getline(c_lnum)
  210              0.009191   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
  210              0.001340   if empty(matches)
                                let [c_before, c] = ['', '']
  210              0.000409   else
  210              0.002642     let [c_before, c] = matches[1:2]
  210              0.000417   endif
  210              0.006816   let plist = split(&matchpairs, '.\zs[:,]')
  210              0.001589   let i = index(plist, c)
  210              0.000631   if i < 0
                                " not found, in Insert mode try character before the cursor
  210              0.002059     if c_col > 1 && (mode() == 'i' || mode() == 'R')
  184              0.001327       let before = strlen(c_before)
  184              0.000662       let c = c_before
  184              0.001096       let i = index(plist, c)
  210              0.000407     endif
  210              0.000495     if i < 0
                                  " not found, nothing to do
  210              0.000535       return
                                endif
                              endif
                            
                              " Figure out the arguments for searchpairpos().
                              if i % 2 == 0
                                let s_flags = 'nW'
                                let c2 = plist[i + 1]
                              else
                                let s_flags = 'nbW'
                                let c2 = c
                                let c = plist[i - 1]
                              endif
                              if c == '['
                                let c = '\['
                                let c2 = '\]'
                              endif
                            
                              " Find the match.  When it was just before the cursor move it there for a
                              " moment.
                              if before > 0
                                let has_getcurpos = exists("*getcurpos")
                                if has_getcurpos
                                  " getcurpos() is more efficient but doesn't exist before 7.4.313.
                                  let save_cursor = getcurpos()
                                else
                                  let save_cursor = winsaveview()
                                endif
                                call cursor(c_lnum, c_col - before)
                              endif
                            
                              if !has("syntax") || !exists("g:syntax_on")
                                let s_skip = "0"
                              else
                                " Build an expression that detects whether the current cursor position is
                                " in certain syntax types (string, comment, etc.), for use as
                                " searchpairpos()'s skip argument.
                                " We match "escape" for special items, such as lispEscapeSpecial.
                                let s_skip = '!empty(filter(map(synstack(line("."), col(".")), ''synIDattr(v:val, "name")''), ' . '''v:val =~? "string\\|character\\|singlequote\\|escape\\|comment"''))'
                                " If executing the expression determines that the cursor is currently in
                                " one of the syntax types, then we want searchpairpos() to find the pair
                                " within those syntax types (i.e., not skip).  Otherwise, the cursor is
                                " outside of the syntax types and s_skip should keep its value so we skip
                                " any matching pair inside the syntax types.
                                " Catch if this throws E363: pattern uses more memory than 'maxmempattern'.
                                try
                                  execute 'if ' . s_skip . ' | let s_skip = "0" | endif'
                                catch /^Vim\%((\a\+)\)\=:E363/
                                  " We won't find anything, so skip searching, should keep Vim responsive.
                                  return
                                endtry
                              endif
                            
                              " Limit the search to lines visible in the window.
                              let stoplinebottom = line('w$')
                              let stoplinetop = line('w0')
                              if i % 2 == 0
                                let stopline = stoplinebottom
                              else
                                let stopline = stoplinetop
                              endif
                            
                              " Limit the search time to 300 msec to avoid a hang on very long lines.
                              " This fails when a timeout is not supported.
                              if mode() == 'i' || mode() == 'R'
                                let timeout = exists("b:matchparen_insert_timeout") ? b:matchparen_insert_timeout : g:matchparen_insert_timeout
                              else
                                let timeout = exists("b:matchparen_timeout") ? b:matchparen_timeout : g:matchparen_timeout
                              endif
                              try
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline, timeout)
                              catch /E118/
                                " Can't use the timeout, restrict the stopline a bit more to avoid taking
                                " a long time on closed folds and long lines.
                                " The "viewable" variables give a range in which we can scroll while
                                " keeping the cursor at the same position.
                                " adjustedScrolloff accounts for very large numbers of scrolloff.
                                let adjustedScrolloff = min([&scrolloff, (line('w$') - line('w0')) / 2])
                                let bottom_viewable = min([line('$'), c_lnum + &lines - adjustedScrolloff - 2])
                                let top_viewable = max([1, c_lnum-&lines+adjustedScrolloff + 2])
                                " one of these stoplines will be adjusted below, but the current values are
                                " minimal boundaries within the current window
                                if i % 2 == 0
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = min([line2byte("$"), line2byte(".") + col(".") + &smc * 2])
                            	let stopline = min([bottom_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = min([bottom_viewable, c_lnum + 100])
                                  endif
                                  let stoplinebottom = stopline
                                else
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = max([1, line2byte(".") + col(".") - &smc * 2])
                            	let stopline = max([top_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = max([top_viewable, c_lnum - 100])
                                  endif
                                  let stoplinetop = stopline
                                endif
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline)
                              endtry
                            
                              if before > 0
                                if has_getcurpos
                                  call setpos('.', save_cursor)
                                else
                                  call winrestview(save_cursor)
                                endif
                              endif
                            
                              " If a match is found setup match highlighting.
                              if m_lnum > 0 && m_lnum >= stoplinetop && m_lnum <= stoplinebottom 
                                if exists('*matchaddpos')
                                  call matchaddpos('MatchParen', [[c_lnum, c_col - before], [m_lnum, m_col]], 10, 3)
                                else
                                  exe '3match MatchParen /\(\%' . c_lnum . 'l\%' . (c_col - before) . 'c\)\|\(\%' . m_lnum . 'l\%' . m_col . 'c\)/'
                                endif
                                let w:paren_hl_on = 1
                              endif

FUNCTION  snipmate#util#tabwidth()
    Defined: ~/dev_trees/myvim/bundle/vim-snipmate/autoload/snipmate/util.vim:24
Called 1 time
Total time:   0.000011
 Self time:   0.000011

count  total (s)   self (s)
    1              0.000003     if &sts > 0
                                    return &sts
    1              0.000001     else
    1              0.000005         return exists('*shiftwidth') ? shiftwidth() : &sw
                                endif

FUNCTION  snipMate#ScopesByFile()
    Defined: ~/dev_trees/myvim/bundle/vim-snipmate/autoload/snipMate.vim:446
Called 1 time
Total time:   0.000109
 Self time:   0.000017

count  total (s)   self (s)
                            	" duplicates are removed in AddScopeAliases
    1   0.000108   0.000016 	return filter(funcref#Call(g:snipMate.get_scopes), "v:val != ''")

FUNCTION  snipMate#TriggerSnippet()
    Defined: ~/dev_trees/myvim/bundle/vim-snipmate/autoload/snipMate.vim:562
Called 1 time
Total time:   0.033179
 Self time:   0.000192

count  total (s)   self (s)
    1              0.000005 	if exists('g:SuperTabMappingForward')
    1              0.000003 		if g:SuperTabMappingForward == "<tab>"
    1              0.000025 			let SuperTabPlug = maparg('<Plug>SuperTabForward', 'i')
    1              0.000002 			if SuperTabPlug == ""
                            				let SuperTabKey = "\<c-n>"
    1              0.000001 			else
    1              0.000013 				exec "let SuperTabKey = \"" . escape(SuperTabPlug, '<') . "\""
    1              0.000001 			endif
                            		elseif g:SuperTabMappingBackward == "<tab>"
                            			let SuperTabPlug = maparg('<Plug>SuperTabBackward', 'i')
                            			if SuperTabPlug == ""
                            				let SuperTabKey = "\<c-p>"
                            			else
                            				exec "let SuperTabKey = \"" . escape(SuperTabPlug, '<') . "\""
                            			endif
    1              0.000001 		endif
    1              0.000000 	endif
                            
    1              0.000002 	if pumvisible() " Update snippet if completion is used, or deal with supertab
                            		if exists('SuperTabKey')
                            			call feedkeys(SuperTabKey) | return ''
                            		endif
                            		call feedkeys("\<esc>a", 'n') " Close completion menu
                            		call feedkeys("\<tab>") | return ''
    1              0.000000 	endif
                            
    1              0.000003 	if exists('b:snip_state') && a:0 == 0 " Jump only if no arguments
                            		let jump = b:snip_state.jump_stop(0)
                            		if type(jump) == 1 " returned a string
                            			return jump
                            		endif
    1              0.000001 	endif
                            
    1              0.000015 	let word = matchstr(getline('.'), '\S\+\%'.col('.').'c')
    1   0.029286   0.000014 	let list = snipMate#GetSnippetsForWordBelowCursor(word, 1)
    1              0.000001 	if empty(list)
                            		let snippet = ''
    1              0.000000 	else
    1              0.000003 		let [trigger, snippetD] = list[0]
    1   0.000125   0.000010 		let snippet = s:ChooseSnippet(snippetD)
                            		" Before expanding snippet, create new undo point |i_CTRL-G|
    1              0.000006 		let &undolevels = &undolevels
    1              0.000004 		let col = col('.') - len(trigger)
    1              0.000030 		sil exe 's/\V'.escape(trigger, '/\.').'\%#//'
    1   0.003612   0.000012 		return snipMate#expandSnip(snippet[0], snippet[1], col)
                            	endif
                            
                            	" should allow other plugins to register hooks instead (duplicate code)
                            	if exists('SuperTabKey')
                            		call feedkeys(SuperTabKey)
                            		return ''
                            	endif
                            	return word == '' ? "\<tab>" : "\<c-r>=snipMate#ShowAvailableSnips()\<cr>"

FUNCTION  tlib#input#List()
    Defined: ~/dev_trees/myvim/bundle/tlib_vim/autoload/tlib/input.vim:266
Called 1 time
Total time:   0.010436
 Self time:   0.002050

count  total (s)   self (s)
    1   0.001521   0.000722     exec tlib#arg#Let([ ['query', ''], ['list', []], ['handlers', []], ['rv', ''], ['timeout', 0], ])
                                " let handlers = a:0 >= 1 ? a:1 : []
                                " let rv       = a:0 >= 2 ? a:2 : ''
                                " let timeout  = a:0 >= 3 ? a:3 : 0
                                " let backchar = ["\<bs>", "\<del>"]
                            
    1              0.000009     if a:type =~ '^resume'
                                    let world = b:tlib_{matchstr(a:type, ' \zs.\+')}
    1              0.000002     else
    1   0.007302   0.000694         let world = tlib#World#New({ 'type': a:type, 'base': list, 'query': query, 'timeout': timeout, 'rv': rv, 'handlers': handlers, })
    1   0.000709   0.000452         let scratch_name     = tlib#list#Find(handlers, 'has_key(v:val, "scratch_name")', '', 'v:val.scratch_name')
    1              0.000002         if !empty(scratch_name)
                                        let world.scratch = scratch_name
    1              0.000001         endif
    1   0.000038   0.000010         let world.scratch_vertical = tlib#list#Find(handlers, 'has_key(v:val, "scratch_vertical")', 0, 'v:val.scratch_vertical')
    1   0.000052   0.000015         call world.Set_display_format(tlib#list#Find(handlers, 'has_key(v:val, "display_format")', '', 'v:val.display_format'))
    1   0.000034   0.000009         let world.initial_index    = tlib#list#Find(handlers, 'has_key(v:val, "initial_index")', 1, 'v:val.initial_index')
    1   0.000033   0.000009         let world.index_table      = tlib#list#Find(handlers, 'has_key(v:val, "index_table")', [], 'v:val.index_table')
    1              0.000004         let world.state_handlers   = filter(copy(handlers),   'has_key(v:val, "state")')
    1              0.000004         let world.post_handlers    = filter(copy(handlers),   'has_key(v:val, "postprocess")')
    1   0.000033   0.000009         let world.filter_format    = tlib#list#Find(handlers, 'has_key(v:val, "filter_format")', '', 'v:val.filter_format')
    1   0.000033   0.000010         let world.return_agent     = tlib#list#Find(handlers, 'has_key(v:val, "return_agent")', '', 'v:val.return_agent')
    1   0.000045   0.000008         let world.help_extra       = tlib#list#Find(handlers, 'has_key(v:val, "help_extra")', '', 'v:val.help_extra')
    1   0.000033   0.000008         let world.resize           = tlib#list#Find(handlers, 'has_key(v:val, "resize")', '', 'v:val.resize')
    1   0.000032   0.000008         let world.show_empty       = tlib#list#Find(handlers, 'has_key(v:val, "show_empty")', 0, 'v:val.show_empty')
    1   0.000106   0.000017         let world.pick_last_item   = tlib#list#Find(handlers, 'has_key(v:val, "pick_last_item")',  tlib#var#Get('tlib_pick_last_item', 'bg'), 'v:val.pick_last_item')
    1   0.000034   0.000009         let world.numeric_chars    = tlib#list#Find(handlers, 'has_key(v:val, "numeric_chars")',  g:tlib#input#numeric_chars, 'v:val.numeric_chars')
    1              0.000005         let world.key_handlers     = filter(copy(handlers), 'has_key(v:val, "key")')
    1   0.000033   0.000009         let filter                 = tlib#list#Find(handlers, 'has_key(v:val, "filter")', '', 'v:val.filter')
    1              0.000002         if !empty(filter)
                                        " let world.initial_filter = [[''], [filter]]
                                        " let world.initial_filter = [[filter]]
                                        Tlibtrace 'tlib', world.initial_filter, filter
                                        call world.SetInitialFilter(filter)
    1              0.000001         endif
    1              0.000001     endif
    1   0.000345   0.000008     return tlib#input#ListW(world)

FUNCTION  snipMate#DefaultPool()
    Defined: ~/dev_trees/myvim/bundle/vim-snipmate/autoload/snipMate.vim:375
Called 1 time
Total time:   0.028699
 Self time:   0.005740

count  total (s)   self (s)
    1   0.000271   0.000013 	let scopes = s:AddScopeAliases(a:scopes)
    1              0.000002 	let scopes_done = []
    1              0.000002 	let s:lookup_state = {}
    1              0.000003 	let s:lookup_state.snips = []
                            
    3              0.000006 	while !empty(scopes)
    2              0.000007 		let scope = remove(scopes, 0)
    2              0.000005 		let s:lookup_state.scope = scope
    2              0.000004 		let s:lookup_state.extends = []
                            
   14   0.000155   0.000053 		for expr in s:snippet_filenames(scope, escape(a:trigger, "*[]?{}`'$|#%"))
  468   0.000947   0.000658 			for path in s:snippet_dirs()
  458   0.017119   0.002947 				for file in s:Glob(path, expr)
    2   0.008421   0.000317 					source `=file`
  458              0.000307 				endfor
  468              0.000267 			endfor
   14              0.000009 		endfor
                            
    2              0.000008 		call add(scopes_done, scope)
    2              0.000007 		call extend(scopes, s:lookup_state.extends)
    2              0.000011 		call filter(scopes, 'index(scopes_done, v:val) == -1')
    3              0.000004 	endwhile
                            
   35              0.000071 	for [trigger, desc, contents, bang, snipversion] in s:lookup_state.snips
   34              0.000139 		if trigger =~ '\V\^' . escape(a:trigger, '\')
    2   0.000066   0.000032 			call snipMate#SetByPath(a:result, trigger, desc, contents, bang, snipversion)
   34              0.000014 		endif
   35              0.000022 	endfor

FUNCTION  tlib#scratch#CloseScratch()
    Defined: ~/dev_trees/myvim/bundle/tlib_vim/autoload/tlib/scratch.vim:106
Called 1 time
Total time:   0.000107
 Self time:   0.000053

count  total (s)   self (s)
    1   0.000068   0.000014     TVarArg ['reset_scratch', 1]
    1              0.000004     let scratch = get(a:keyargs, 'scratch', '')
                                " TLogVAR scratch, reset_scratch
                                " TLogDBG string(tlib#win#List())
    1              0.000004     if !empty(scratch) && winnr('$') > 1
                                    let wn = bufwinnr(scratch)
                                    " TLogVAR wn
                                    try
                                        if wn != -1
                                            " TLogDBG winnr()
                                            let wb = tlib#win#Set(wn)
                                            let winpos = tlib#fixes#Winpos()
                                            wincmd c
                                            if get(a:keyargs, 'scratch_vertical') && !empty(winpos)
                                                exec winpos
                                            endif
                                            " exec wb 
                                            " redraw
                                            " TLogVAR winnr()
                                        endif
                                        return 1
                                    finally
                                        if reset_scratch
                                            let a:keyargs.scratch = ''
                                        endif
                                    endtry
    1              0.000001     endif
    1              0.000001     return 0

FUNCTION  <SNR>37_YRMRUElemFormat()
    Defined: ~/dev_trees/myvim/bundle/yankring/plugin/yankring.vim:1685
Called 2 times
Total time:   0.000150
 Self time:   0.000150

count  total (s)   self (s)
    2              0.000006     let elem    = a:element
    2              0.000005     if g:yankring_max_element_length != 0
    2              0.000012         let elem    = strpart(a:element, 0, g:yankring_max_element_length)
    2              0.000006         if (g:yankring_warn_on_truncate > 0)
    2              0.000017             let bytes = len (a:element) - len(elem)
    2              0.000003             if (bytes > 0)
                                            call s:YRWarningMsg("Yankring truncated its element by ". bytes. " bytes due to a g:yankring_max_element_length of ". g:yankring_max_element_length )
    2              0.000003             endif
    2              0.000002         endif
    2              0.000002     endif
    2              0.000007     if s:yr_history_version == 'v1'
                                    let elem    = escape(elem, '@')
                                    let elem    = substitute(elem, "\n", s:yr_history_v1_nl, 'g')
    2              0.000003     else
    2              0.000025         let elem    = substitute(elem, "\n", s:yr_history_v2_nl, 'g')
    2              0.000003     endif
                                " Append the regtype to the end so we have it available
    2              0.000009     let elem    = elem.",".a:element_type
                            
    2              0.000004     return elem

FUNCTION  <SNR>87_AddScopeAliases()
    Defined: ~/dev_trees/myvim/bundle/vim-snipmate/autoload/snipMate.vim:272
Called 1 time
Total time:   0.000258
 Self time:   0.000089

count  total (s)   self (s)
    1              0.000002   let did = {}
    1   0.000176   0.000007   let scope_aliases = s:GetScopes()
    1              0.000002   let new = a:list
    1              0.000001   let new2 =  []
    2              0.000005   while !empty(new)
    4              0.000005 	for i in new
    3              0.000007 	  if !has_key(did, i)
    2              0.000004 		let did[i] = 1
    2              0.000016 		call extend(new2, split(get(scope_aliases,i,''),','))
    3              0.000002 	  endif
    4              0.000003 	endfor
    1              0.000001 	let new = new2
    1              0.000002 	let new2 = []
    2              0.000002   endwhile
    1              0.000002   return keys(did)

FUNCTION  snipMate#SetByPath()
    Defined: ~/dev_trees/myvim/bundle/vim-snipmate/autoload/snipMate.vim:346
Called 2 times
Total time:   0.000034
 Self time:   0.000034

count  total (s)   self (s)
    2              0.000003 	let d = a:dict
    2              0.000003 	if a:bang == 2
                            		unlet! d[a:trigger]
                            		return
    2              0.000005 	elseif !has_key(d, a:trigger) || a:bang == 1
    2              0.000006 		let d[a:trigger] = {}
    2              0.000002 	endif
    2              0.000008 	let d[a:trigger][a:path] = [a:snippet, a:snipversion]

FUNCTION  <SNR>21_addtomrufs()
    Defined: ~/dev_trees/myvim/bundle/ctrlp.vim/autoload/ctrlp/mrufiles.vim:70
Called 1 time
Total time:   0.038447
 Self time:   0.038447

count  total (s)   self (s)
    1              0.000184 	let fn = fnamemodify(a:fname, get(g:, 'ctrlp_tilde_homedir', 0) ? ':p:~' : ':p')
    1              0.000020 	let fn = exists('+ssl') ? tr(fn, '/', '\') : fn
    1              0.000035 	let abs_fn = fnamemodify(fn,':p')
    1              0.038142 	if ( !empty({s:in}) && fn !~# {s:in} ) || ( !empty({s:ex}) && fn =~# {s:ex} ) || !empty(getbufvar('^' . abs_fn . '$', '&bt')) || !filereadable(abs_fn)
                            		retu
    1              0.000002 	en
    1              0.000024 	let idx = index(s:mrufs, fn, 0, !{s:cseno})
    1              0.000002 	if idx
                            		cal filter(s:mrufs, 'v:val !='.( {s:cseno} ? '#' : '?' ).' fn')
                            		cal insert(s:mrufs, fn)
                            		if {s:soup} && idx < 0
                            			cal s:savetofile(s:mergelists())
                            		en
    1              0.000001 	en

FUNCTION  <SNR>37_YRRegister()
    Defined: ~/dev_trees/myvim/bundle/yankring/plugin/yankring.vim:699
Called 2 times
Total time:   0.000137
 Self time:   0.000137

count  total (s)   self (s)
                                " v:register can be blank in some (unknown) cases
                                " so test for this condition and return the 
                                " default register
    2              0.000024     let user_register = ((v:register=='')?('"'):(v:register))
    2              0.000011     if &clipboard == 'unnamed' && user_register == '"'
                                    let user_register = '+'
    2              0.000003     endif
    2              0.000005     return user_register

FUNCTION  tlib#list#FindAll()
    Defined: ~/dev_trees/myvim/bundle/tlib_vim/autoload/tlib/list.vim:60
Called 13 times
Total time:   0.000151
 Self time:   0.000151

count  total (s)   self (s)
   13              0.000051     let rv   = filter(copy(a:list), a:filter)
   13              0.000033     if a:0 >= 1 && !empty(a:1)
   13              0.000029         let rv = map(rv, a:1)
   13              0.000008     endif
   13              0.000012     return rv

FUNCTION  YRRecord()
    Defined: ~/dev_trees/myvim/bundle/yankring/plugin/yankring.vim:773
Called 2 times
Total time:   0.012937
 Self time:   0.000248

count  total (s)   self (s)
                            
    2              0.000006     let register = '"'
    2              0.000007     if a:0 > 0
                                    " If no yank command has been supplied, assume it is
                                    " a full line yank
    2              0.000010         let register = ((a:1 == '') ? register : a:1)
    2              0.000001     endif
                            
                                " v:register can be blank in some (unknown) cases
                                " if v:register == '' || v:register == '_'
    2              0.000005     if v:register == '_'
                                    " Black hole register, ignore recording the operation
                                    return ""
    2              0.000002     endif
                            
    2              0.000009     let register = ((&clipboard=='unnamed')?'+':register)
                            
                                " let s:yr_prev_changenr    = changenr()
    2              0.000006     if register == '"'
                                    " If the change has occurred via an omap, we must delay
                                    " the capture of the default register until this event
                                    " since register updates are not reflected until the 
                                    " omap function completes
    2              0.000016         let s:yr_prev_reg_unnamed = getreg('"')
    2              0.000010         let s:yr_prev_reg_small   = getreg('-')
    2              0.000003     endif
                            
                                " Add item to list
                                " This will also account for duplicates.
    2   0.012680   0.000039     call s:YRMRUAdd( 's:yr_history_list' , getreg(register) , getregtype(register)  )
                            
    2              0.000030     if register =~ '[+*]'
                                    let s:yr_prev_clipboard = @+
    2              0.000002     endif
                            
                                " If the yankring window is open, refresh it
    2   0.000080   0.000032     call s:YRWindowUpdate()
                            
                                " Manage the numbered registers
    2              0.000005     if g:yankring_manage_numbered_reg == 1
                                    call s:YRSetNumberedReg()
    2              0.000001     endif
                            
    2              0.000003     return ""

FUNCTION  snipmate#legacy#process_snippet()
    Defined: ~/dev_trees/myvim/bundle/vim-snipmate/autoload/snipmate/legacy.vim:5
Called 1 time
Total time:   0.000427
 Self time:   0.000334

count  total (s)   self (s)
    1              0.000003 	let snippet = a:snip
    1              0.000002 	let esc_bslash = '\%(\\\@<!\%(\\\\\)*\)\@<='
                            
    1              0.000003 	if exists('b:snipmate_visual')
                            		let visual = substitute(b:snipmate_visual, "\n$", '', '')
                            		unlet b:snipmate_visual
    1              0.000001 	else
    1              0.000001 		let visual = ''
    1              0.000000 	endif
    1   0.000093   0.000011         let snippet = s:substitute_visual(snippet, visual)
                            
                            	" Evaluate eval (`...`) expressions.
                            	" Backquotes prefixed with a backslash "\" are ignored.
                            	" And backslash can be escaped by doubling it.
                            	" Using a loop here instead of a regex fixes a bug with nested "\=".
    1              0.000003 	if stridx(snippet, '`') != -1
    1              0.000001 		let new = []
    1              0.000097 		let snip = split(snippet, esc_bslash . '`', 1)
    1              0.000001 		let isexp = 0
    2              0.000004 		for i in snip
    1              0.000001 			if isexp
                            				call add(new, substitute(snipmate#util#eval(i), "\n\\%$", '', ''))
    1              0.000001 			else
    1              0.000003 				call add(new, i)
    1              0.000000 			endif
    1              0.000001 			let isexp = !isexp
    2              0.000002 		endfor
    1              0.000003 		let snippet = join(new, '')
    1              0.000005 		let snippet = substitute(snippet, "\r", "\n", 'g')
    1              0.000006 		let snippet = substitute(snippet, '\\`', "`", 'g')
    1              0.000001 	endif
                            
                            	" Place all text after a colon in a tab stop after the tab stop
                            	" (e.g. "${#:foo}" becomes "${:foo}foo").
                            	" This helps tell the position of the tab stops later.
    1              0.000062 	let snippet = substitute(snippet, esc_bslash . '\$\({\d\+:\(.\{-}\)}\|{\d\+}\)', s:sigil . '\1\2', 'g')
    1              0.000014 	let snippet = substitute(snippet, esc_bslash . '\$\(\d\+\)', s:sigil . '\1', 'g')
    1              0.000008 	let snippet = substitute(snippet, esc_bslash . '\\\$', '$', 'g')
    1              0.000005 	let snippet = substitute(snippet, '\\\\', "\\", 'g')
                            
                            	" Update the a:snip so that all the $# become the text after
                            	" the colon in their associated ${#}.
                            	" (e.g. "${1:foo}" turns all "$1"'s into "foo")
    1              0.000001 	let i = 0
    1              0.000004 	if snippet !~ s:sigil . '{0'
                            		let snippet .= s:sigil . '{0}'
    1              0.000001 	endif
    2              0.000010 	while snippet =~ s:sigil.'{'.i
    1              0.000012 		let s = matchstr(snippet, s:sigil . '{' . i . ':\zs.\{-}\ze}')
    1              0.000002 		if s != ''
    1              0.000007 			let snippet = substitute(snippet, s:sigil . i, s.'&', 'g')
    1              0.000001 		endif
    1              0.000001 		let i += 1
    2              0.000003 	endw
                            
    1              0.000005 	if &et " Expand tabs to spaces if 'expandtab' is set.
    1   0.000023   0.000012 		return substitute(snippet, '\t', repeat(' ', snipmate#util#tabwidth()), 'g')
                            	endif
                            	return snippet

FUNCTION  <SNR>29_SelectCompletion()
    Defined: ~/dev_trees/myvim/bundle/supertab/plugin/supertab.vim:684
Called 5 times
Total time:   0.000927
 Self time:   0.000927

count  total (s)   self (s)
                                  " selecting a completion
    5              0.000062       if pumvisible()
                                    " ugly hack to let other <cr> mappings for other plugins cooperate
                                    " with supertab
                                    let b:supertab_pumwasvisible = 1
                                    return "\<c-y>"
    5              0.000015       endif
                            
    5              0.000062       if exists('b:supertab_pumwasvisible')
                                    unlet b:supertab_pumwasvisible
                                    return ''
    5              0.000009       endif
                            
                                  " not so pleasant hack to keep <cr> working for abbreviations
    5              0.000369       let word = substitute(getline('.'), '^.*\s\+\(.*\%' . col('.') . 'c\).*', '\1', '')
    5              0.000079       if maparg(word, 'i', 1) != ''
                                    call feedkeys("\<c-]>", 't')
                                    call feedkeys("\<cr>", 'n')
                                    return ''
    5              0.000011       endif
                            
                                  " only return a cr if nothing else is mapped to it since we don't want
                                  " to duplicate a cr returned by another mapping.
    5              0.000043       return a:cr ? "\<cr>" : ""

FUNCTION  snipMate#GetSnippets()
    Defined: ~/dev_trees/myvim/bundle/vim-snipmate/autoload/snipMate.vim:410
Called 1 time
Total time:   0.028837
 Self time:   0.000029

count  total (s)   self (s)
    1              0.000002 	let result = {}
                            
    2              0.000009 	for F in values(g:snipMateSources)
    1   0.028818   0.000010 	  call funcref#Call(F, [a:scopes, a:trigger, result])
    2              0.000002 	endfor
    1              0.000001 	return result

FUNCTIONS SORTED ON TOTAL TIME
count  total (s)   self (s)  function
    4   0.057920   0.000273  funcref#Call()
  210   0.051059             <SNR>42_Highlight_Matching_Pair()
    1   0.038544   0.000097  <SNR>21_record()
    1   0.038447             <SNR>21_addtomrufs()
    1   0.033179   0.000192  snipMate#TriggerSnippet()
    1   0.029272   0.000154  snipMate#GetSnippetsForWordBelowCursor()
    1   0.028837   0.000029  snipMate#GetSnippets()
    1   0.028699   0.005740  snipMate#DefaultPool()
  456   0.014172             <SNR>87_Glob()
    2   0.013834   0.000142  <SNR>37_YRInsertLeave()
    2   0.012937   0.000248  YRRecord()
    2   0.012641   0.000277  <SNR>37_YRMRUAdd()
    1   0.011606             <SNR>37_YRHistorySave()
    1   0.010436   0.002050  tlib#input#List()
    2   0.008028   0.000696  <SNR>87_source_snippet()
    2   0.007231   0.000106  <SNR>87_CachedSnips()
    2   0.007125             snipMate#ReadSnippetsFile()
    6   0.004109   0.003598  GetRmdIndent()
    1   0.003600   0.001250  snipMate#expandSnip()
    1   0.001819   0.000028  tlib#World#New()

FUNCTIONS SORTED ON SELF TIME
count  total (s)   self (s)  function
  210              0.051059  <SNR>42_Highlight_Matching_Pair()
    1              0.038447  <SNR>21_addtomrufs()
  456              0.014172  <SNR>87_Glob()
    1              0.011606  <SNR>37_YRHistorySave()
    2              0.007125  snipMate#ReadSnippetsFile()
    1   0.028699   0.005740  snipMate#DefaultPool()
    6   0.004109   0.003598  GetRmdIndent()
    1   0.010436   0.002050  tlib#input#List()
    1   0.003600   0.001250  snipMate#expandSnip()
    5              0.000927  <SNR>29_SelectCompletion()
    2   0.008028   0.000696  <SNR>87_source_snippet()
    2              0.000618  <SNR>37_YRMapsCreate()
    2              0.000573  <SNR>37_YRHistoryRead()
    1   0.001568   0.000530  35()
    6              0.000511  <SNR>73_GetMdIndent()
    1   0.000427   0.000334  snipmate#legacy#process_snippet()
    4              0.000294  3()
    1              0.000293  <SNR>98_state_remove()
   12              0.000289  <SNR>87_snippet_dirs()
    2   0.012641   0.000277  <SNR>37_YRMRUAdd()

