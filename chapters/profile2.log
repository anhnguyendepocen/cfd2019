FUNCTION  <SNR>44_Highlight_Matching_Pair()
    Defined: /usr/local/Cellar/macvim/8.1-161_1/MacVim.app/Contents/Resources/vim/runtime/plugin/matchparen.vim:39
Called 270 times
Total time:   0.060411
 Self time:   0.060411

count  total (s)   self (s)
                              " Remove any previous match.
  270              0.003412   if exists('w:paren_hl_on') && w:paren_hl_on
                                silent! call matchdelete(3)
                                let w:paren_hl_on = 0
  270              0.000612   endif
                            
                              " Avoid that we remove the popup menu.
                              " Return when there are no colors (looks like the cursor jumps).
  270              0.005075   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
                                return
  270              0.000376   endif
                            
                              " Get the character under the cursor and check if it's in 'matchpairs'.
  270              0.001950   let c_lnum = line('.')
  270              0.001449   let c_col = col('.')
  270              0.000735   let before = 0
                            
  270              0.001753   let text = getline(c_lnum)
  270              0.010695   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
  270              0.001471   if empty(matches)
                                let [c_before, c] = ['', '']
  270              0.000502   else
  270              0.003013     let [c_before, c] = matches[1:2]
  270              0.000460   endif
  270              0.007506   let plist = split(&matchpairs, '.\zs[:,]')
  270              0.001902   let i = index(plist, c)
  270              0.000711   if i < 0
                                " not found, in Insert mode try character before the cursor
  270              0.002460     if c_col > 1 && (mode() == 'i' || mode() == 'R')
  254              0.001674       let before = strlen(c_before)
  254              0.000838       let c = c_before
  254              0.001387       let i = index(plist, c)
  270              0.000437     endif
  270              0.000585     if i < 0
                                  " not found, nothing to do
  270              0.000680       return
                                endif
                              endif
                            
                              " Figure out the arguments for searchpairpos().
                              if i % 2 == 0
                                let s_flags = 'nW'
                                let c2 = plist[i + 1]
                              else
                                let s_flags = 'nbW'
                                let c2 = c
                                let c = plist[i - 1]
                              endif
                              if c == '['
                                let c = '\['
                                let c2 = '\]'
                              endif
                            
                              " Find the match.  When it was just before the cursor move it there for a
                              " moment.
                              if before > 0
                                let has_getcurpos = exists("*getcurpos")
                                if has_getcurpos
                                  " getcurpos() is more efficient but doesn't exist before 7.4.313.
                                  let save_cursor = getcurpos()
                                else
                                  let save_cursor = winsaveview()
                                endif
                                call cursor(c_lnum, c_col - before)
                              endif
                            
                              if !has("syntax") || !exists("g:syntax_on")
                                let s_skip = "0"
                              else
                                " Build an expression that detects whether the current cursor position is
                                " in certain syntax types (string, comment, etc.), for use as
                                " searchpairpos()'s skip argument.
                                " We match "escape" for special items, such as lispEscapeSpecial.
                                let s_skip = '!empty(filter(map(synstack(line("."), col(".")), ''synIDattr(v:val, "name")''), ' . '''v:val =~? "string\\|character\\|singlequote\\|escape\\|comment"''))'
                                " If executing the expression determines that the cursor is currently in
                                " one of the syntax types, then we want searchpairpos() to find the pair
                                " within those syntax types (i.e., not skip).  Otherwise, the cursor is
                                " outside of the syntax types and s_skip should keep its value so we skip
                                " any matching pair inside the syntax types.
                                " Catch if this throws E363: pattern uses more memory than 'maxmempattern'.
                                try
                                  execute 'if ' . s_skip . ' | let s_skip = "0" | endif'
                                catch /^Vim\%((\a\+)\)\=:E363/
                                  " We won't find anything, so skip searching, should keep Vim responsive.
                                  return
                                endtry
                              endif
                            
                              " Limit the search to lines visible in the window.
                              let stoplinebottom = line('w$')
                              let stoplinetop = line('w0')
                              if i % 2 == 0
                                let stopline = stoplinebottom
                              else
                                let stopline = stoplinetop
                              endif
                            
                              " Limit the search time to 300 msec to avoid a hang on very long lines.
                              " This fails when a timeout is not supported.
                              if mode() == 'i' || mode() == 'R'
                                let timeout = exists("b:matchparen_insert_timeout") ? b:matchparen_insert_timeout : g:matchparen_insert_timeout
                              else
                                let timeout = exists("b:matchparen_timeout") ? b:matchparen_timeout : g:matchparen_timeout
                              endif
                              try
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline, timeout)
                              catch /E118/
                                " Can't use the timeout, restrict the stopline a bit more to avoid taking
                                " a long time on closed folds and long lines.
                                " The "viewable" variables give a range in which we can scroll while
                                " keeping the cursor at the same position.
                                " adjustedScrolloff accounts for very large numbers of scrolloff.
                                let adjustedScrolloff = min([&scrolloff, (line('w$') - line('w0')) / 2])
                                let bottom_viewable = min([line('$'), c_lnum + &lines - adjustedScrolloff - 2])
                                let top_viewable = max([1, c_lnum-&lines+adjustedScrolloff + 2])
                                " one of these stoplines will be adjusted below, but the current values are
                                " minimal boundaries within the current window
                                if i % 2 == 0
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = min([line2byte("$"), line2byte(".") + col(".") + &smc * 2])
                            	let stopline = min([bottom_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = min([bottom_viewable, c_lnum + 100])
                                  endif
                                  let stoplinebottom = stopline
                                else
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = max([1, line2byte(".") + col(".") - &smc * 2])
                            	let stopline = max([top_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = max([top_viewable, c_lnum - 100])
                                  endif
                                  let stoplinetop = stopline
                                endif
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline)
                              endtry
                            
                              if before > 0
                                if has_getcurpos
                                  call setpos('.', save_cursor)
                                else
                                  call winrestview(save_cursor)
                                endif
                              endif
                            
                              " If a match is found setup match highlighting.
                              if m_lnum > 0 && m_lnum >= stoplinetop && m_lnum <= stoplinebottom 
                                if exists('*matchaddpos')
                                  call matchaddpos('MatchParen', [[c_lnum, c_col - before], [m_lnum, m_col]], 10, 3)
                                else
                                  exe '3match MatchParen /\(\%' . c_lnum . 'l\%' . (c_col - before) . 'c\)\|\(\%' . m_lnum . 'l\%' . m_col . 'c\)/'
                                endif
                                let w:paren_hl_on = 1
                              endif

FUNCTION  GetRmdIndent()
    Defined: /usr/local/Cellar/macvim/8.1-161_1/MacVim.app/Contents/Resources/vim/runtime/indent/rmd.vim:49
Called 4 times
Total time:   0.001683
 Self time:   0.001418

count  total (s)   self (s)
    4              0.000153   if getline(".") =~ '^[ \t]*```{r .*}$' || getline(".") =~ '^[ \t]*```$'
                                return 0
    4              0.000006   endif
    4              0.000800   if search('^[ \t]*```{r', "bncW") > search('^[ \t]*```$', "bncW")
                                return s:RIndent()
    4              0.000289   elseif v:lnum > 1 && search('^---$', "bnW") == 1 && (search('^---$', "nW") > v:lnum || search('^...$', "nW") > v:lnum)
                                return s:GetYamlIndent()
    4              0.000008   else
    4   0.000334   0.000069     return s:GetMdIndent()
                              endif

FUNCTION  <SNR>39_YRInsertLeave()
    Defined: ~/dev_trees/myvim/bundle/yankring/plugin/yankring.vim:2395
Called 1 time
Total time:   0.001273
 Self time:   0.000075

count  total (s)   self (s)
                                " The YankRing uses omaps to execute the prescribed motion
                                " and then appends to the motion a call to a YankRing 
                                " function to record the contents of the changed register.
                                "
                                " We cannot append a function call to the end of a motion
                                " that results in Insert mode.  For example, any command
                                " like 'cw' enters insert mode.  Appending a function call
                                " after the w, simply writes out the call as if the user 
                                " typed it.
                                "
                                " Using the InsertLeave event, allows us to capture the 
                                " contents of any changed register after it completes.
                                
    1   0.000837   0.000030     call YRRecord(s:YRRegister())
                            
                                " When performing a change (not a yank or delete)
                                " it is not possible to call <SID>yrrecord at the end
                                " of the command (or it's contents will be inserted 
                                " into the buffer instead of executed).
                                " So, when using ".", we have to remove the _zap_
                                " keys and then re-add them back again after we 
                                " record the updates.
    1              0.000003     if s:yr_remove_omap_dot == 1
    1   0.000409   0.000018         call s:YRMapsCreate('add_only_zap_keys')
    1              0.000001     endif
                            

FUNCTION  <SNR>39_YRWindowUpdate()
    Defined: ~/dev_trees/myvim/bundle/yankring/plugin/yankring.vim:1880
Called 1 time
Total time:   0.000032
 Self time:   0.000032

count  total (s)   self (s)
    1              0.000010     let orig_win_bufnr = bufwinnr('%')
                            
                                " Switch to the yankring buffer
                                " only if it is already visible
    1              0.000006     if bufwinnr(s:yr_buffer_id) != -1
                                    call s:YRShow(0)
                                    " Switch back to the original buffer
                                    exec orig_win_bufnr . "wincmd w"
    1              0.000001     endif

FUNCTION  <SNR>39_YRHistoryRead()
    Defined: ~/dev_trees/myvim/bundle/yankring/plugin/yankring.vim:1795
Called 1 time
Total time:   0.000300
 Self time:   0.000300

count  total (s)   self (s)
    1              0.000004     let refresh_needed  = 1
    1              0.000004     let yr_history_list = []
    1              0.000010     let yr_filename     = s:yr_history_file_{s:yr_history_version}
                            
    1              0.000207     if filereadable(yr_filename)
    1              0.000031         let last_upd = getftime(yr_filename)
                            
    1              0.000008         if s:yr_history_last_upd != 0 && last_upd <= s:yr_history_last_upd
    1              0.000004             let refresh_needed = 0
    1              0.000002         endif
                            
    1              0.000003         if refresh_needed == 1
                                        let s:yr_history_list = readfile(yr_filename)
                                        let s:yr_history_last_upd = last_upd
                                        let s:yr_count = len(s:yr_history_list)
                                        return
    1              0.000002         else
    1              0.000002             return
                                    endif
                                else
                                    if s:yr_history_version == 'v2'
                                        " Check to see if an upgrade is required
                                        " else, let the empty yr_history_list be returned.
                                        if filereadable(s:yr_history_file_v1)
                                            " Perform upgrade to v2 of the history file
                                            call s:YRHistoryUpgrade('v1')
                                            return
                                        endif
                                    endif
                                endif
                            
                                let s:yr_history_list = yr_history_list
                                call s:YRHistorySave()
                            

FUNCTION  <SNR>39_YRMRUAdd()
    Defined: ~/dev_trees/myvim/bundle/yankring/plugin/yankring.vim:1727
Called 1 time
Total time:   0.000565
 Self time:   0.000137

count  total (s)   self (s)
                                " Only add new items if they do not already exist in the MRU.
                                " If the item is found, move it to the start of the MRU.
    1              0.000005     let found   = -1
                                " let elem    = a:element
                                " if g:yankring_max_element_length != 0
                                "     let elem    = strpart(a:element, 0, g:yankring_max_element_length)
                                " endif
                                " if s:yr_history_version == 'v1'
                                "     let elem    = escape(elem, '@')
                                "     let elem    = substitute(elem, "\n", s:yr_history_v1_nl, 'g')
                                " else
                                "     let elem    = substitute(elem, "\n", s:yr_history_v2_nl, 'g')
                                " endif
                                " " Append the regtype to the end so we have it available
                                " let elem    = elem.",".a:element_type
                            
    1              0.000009     if strlen(a:element) < g:yankring_min_element_length
                                    return 1
    1              0.000002     endif
                            
    1   0.000128   0.000022     let elem = s:YRMRUElemFormat(a:element, a:element_type)
                            
                                " Refresh the List
    1   0.000319   0.000019     call s:YRHistoryRead()
                            
    1   0.000043   0.000021     let found   = s:YRMRUHas(a:mru_list, elem)
                            
                                " Special case for efficiency, if it is first item in the 
                                " List, do nothing
    1              0.000003     if found != 0
                                    if found != -1
                                        " Remove found item since we will add it to the top
                                        call remove({a:mru_list}, found)
                                    endif
                                    call insert({a:mru_list}, elem, 0)
                                    call s:YRHistorySave()
    1              0.000001     endif
                            
    1              0.000002     return 1

FUNCTION  <SNR>31_SetDefaultCompletionType()
    Defined: ~/dev_trees/myvim/bundle/supertab/plugin/supertab.vim:308
Called 1 time
Total time:   0.000036
 Self time:   0.000036

count  total (s)   self (s)
    1              0.000021   if exists('b:SuperTabDefaultCompletionType') && (!exists('b:complCommandLine') || !b:complCommandLine)
                                call SuperTabSetCompletionType(b:SuperTabDefaultCompletionType)
    1              0.000002   endif

FUNCTION  <SNR>31_SelectCompletion()
    Defined: ~/dev_trees/myvim/bundle/supertab/plugin/supertab.vim:684
Called 3 times
Total time:   0.000437
 Self time:   0.000437

count  total (s)   self (s)
                                  " selecting a completion
    3              0.000036       if pumvisible()
                                    " ugly hack to let other <cr> mappings for other plugins cooperate
                                    " with supertab
                                    let b:supertab_pumwasvisible = 1
                                    return "\<c-y>"
    3              0.000008       endif
                            
    3              0.000029       if exists('b:supertab_pumwasvisible')
                                    unlet b:supertab_pumwasvisible
                                    return ''
    3              0.000005       endif
                            
                                  " not so pleasant hack to keep <cr> working for abbreviations
    3              0.000156       let word = substitute(getline('.'), '^.*\s\+\(.*\%' . col('.') . 'c\).*', '\1', '')
    3              0.000032       if maparg(word, 'i', 1) != ''
                                    call feedkeys("\<c-]>", 't')
                                    call feedkeys("\<cr>", 'n')
                                    return ''
    3              0.000004       endif
                            
                                  " only return a cr if nothing else is mapped to it since we don't want
                                  " to duplicate a cr returned by another mapping.
    3              0.000023       return a:cr ? "\<cr>" : ""

FUNCTION  <SNR>39_YRMRUElemFormat()
    Defined: ~/dev_trees/myvim/bundle/yankring/plugin/yankring.vim:1685
Called 1 time
Total time:   0.000106
 Self time:   0.000106

count  total (s)   self (s)
    1              0.000005     let elem    = a:element
    1              0.000004     if g:yankring_max_element_length != 0
    1              0.000009         let elem    = strpart(a:element, 0, g:yankring_max_element_length)
    1              0.000004         if (g:yankring_warn_on_truncate > 0)
    1              0.000014             let bytes = len (a:element) - len(elem)
    1              0.000003             if (bytes > 0)
                                            call s:YRWarningMsg("Yankring truncated its element by ". bytes. " bytes due to a g:yankring_max_element_length of ". g:yankring_max_element_length )
    1              0.000002             endif
    1              0.000002         endif
    1              0.000001     endif
    1              0.000004     if s:yr_history_version == 'v1'
                                    let elem    = escape(elem, '@')
                                    let elem    = substitute(elem, "\n", s:yr_history_v1_nl, 'g')
    1              0.000002     else
    1              0.000018         let elem    = substitute(elem, "\n", s:yr_history_v2_nl, 'g')
    1              0.000002     endif
                                " Append the regtype to the end so we have it available
    1              0.000008     let elem    = elem.",".a:element_type
                            
    1              0.000003     return elem

FUNCTION  pandoc#command#AutoPandoc()
    Defined: ~/dev_trees/myvim/bundle/vim-pandoc/autoload/pandoc/command.vim:132
Called 1 time
Total time:   0.000045
 Self time:   0.000045

count  total (s)   self (s)
    1              0.000007     if g:pandoc#command#autoexec_on_writes == 1
                                    let command = ''
                                    if exists('g:pandoc#command#autoexec_command')
                                        let command = g:pandoc#command#autoexec_command
                                    endif
                                    if exists('b:pandoc_command_autoexec_command')
                                        let command = b:pandoc_command_autoexec_command
                                    endif
                                    exe command
    1              0.000002     endif

FUNCTION  <SNR>39_YRMRUHas()
    Defined: ~/dev_trees/myvim/bundle/yankring/plugin/yankring.vim:1712
Called 1 time
Total time:   0.000022
 Self time:   0.000022

count  total (s)   self (s)
                                " This function will find a string and return the element #
    1              0.000016     let find_idx = index({a:mru_list}, a:find_str)
                            
    1              0.000003     return find_idx

FUNCTION  <SNR>23_record()
    Defined: ~/dev_trees/myvim/bundle/ctrlp.vim/autoload/ctrlp/mrufiles.vim:59
Called 1 time
Total time:   0.040686
 Self time:   0.000133

count  total (s)   self (s)
    1              0.000017 	if s:locked | retu | en
    1              0.000013 	let bufnr = a:bufnr + 0
    1              0.000013 	let bufname = bufname(bufnr)
    1              0.000011 	if bufnr > 0 && !empty(bufname)
    1              0.000021 		cal filter(s:mrbs, 'v:val != bufnr')
    1              0.000010 		cal insert(s:mrbs, bufnr)
    1   0.040591   0.000038 		cal s:addtomrufs(bufname)
    1              0.000002 	en

FUNCTION  <SNR>23_addtomrufs()
    Defined: ~/dev_trees/myvim/bundle/ctrlp.vim/autoload/ctrlp/mrufiles.vim:70
Called 1 time
Total time:   0.040553
 Self time:   0.040553

count  total (s)   self (s)
    1              0.000273 	let fn = fnamemodify(a:fname, get(g:, 'ctrlp_tilde_homedir', 0) ? ':p:~' : ':p')
    1              0.000029 	let fn = exists('+ssl') ? tr(fn, '/', '\') : fn
    1              0.000056 	let abs_fn = fnamemodify(fn,':p')
    1              0.040112 	if ( !empty({s:in}) && fn !~# {s:in} ) || ( !empty({s:ex}) && fn =~# {s:ex} ) || !empty(getbufvar('^' . abs_fn . '$', '&bt')) || !filereadable(abs_fn)
                            		retu
    1              0.000003 	en
    1              0.000029 	let idx = index(s:mrufs, fn, 0, !{s:cseno})
    1              0.000003 	if idx
                            		cal filter(s:mrufs, 'v:val !='.( {s:cseno} ? '#' : '?' ).' fn')
                            		cal insert(s:mrufs, fn)
                            		if {s:soup} && idx < 0
                            			cal s:savetofile(s:mergelists())
                            		en
    1              0.000001 	en

FUNCTION  <SNR>39_YRRegister()
    Defined: ~/dev_trees/myvim/bundle/yankring/plugin/yankring.vim:699
Called 1 time
Total time:   0.000035
 Self time:   0.000035

count  total (s)   self (s)
                                " v:register can be blank in some (unknown) cases
                                " so test for this condition and return the 
                                " default register
    1              0.000014     let user_register = ((v:register=='')?('"'):(v:register))
    1              0.000007     if &clipboard == 'unnamed' && user_register == '"'
                                    let user_register = '+'
    1              0.000001     endif
    1              0.000004     return user_register

FUNCTION  <SNR>76_GetMdIndent()
    Defined: /usr/local/Cellar/macvim/8.1-161_1/MacVim.app/Contents/Resources/vim/runtime/indent/rmd.vim:26
Called 4 times
Total time:   0.000265
 Self time:   0.000265

count  total (s)   self (s)
    4              0.000046   let pline = getline(v:lnum - 1)
    4              0.000024   let cline = getline(v:lnum)
    4              0.000079   if prevnonblank(v:lnum - 1) < v:lnum - 1 || cline =~ '^\s*[-\+\*]\s' || cline =~ '^\s*\d\+\.\s\+'
    2              0.000012     return indent(v:lnum)
    2              0.000021   elseif pline =~ '^\s*[-\+\*]\s'
                                return indent(v:lnum - 1) + 2
    2              0.000019   elseif pline =~ '^\s*\d\+\.\s\+'
                                return indent(v:lnum - 1) + 3
    2              0.000003   endif
    2              0.000017   return indent(prevnonblank(v:lnum - 1))

FUNCTION  <SNR>39_YRMapsCreate()
    Defined: ~/dev_trees/myvim/bundle/yankring/plugin/yankring.vim:1460
Called 1 time
Total time:   0.000391
 Self time:   0.000391

count  total (s)   self (s)
                                " 7.1.patch205 introduces the v:operator function which was 
                                " essential to gain the omap support.
    1              0.000004     if s:yr_has_voperator == 1
    1              0.000005         let s:yr_remove_omap_dot   = 1
    8              0.000055         for key in split(g:yankring_zap_keys)
    7              0.000012             try
    7              0.000021                 if key != '@'
    6              0.000174                     exec 'omap <expr>' key 'YRMapsExpression("<SID>", "'. key. '", 1)'
    7              0.000013                 endif
                                        catch
    7              0.000013             endtry
    8              0.000015         endfor
    1              0.000002     endif
                            
    1              0.000021     silent! nmap <expr> @ YRMapsExpression("<SID>", "@", "1")
                            
    1              0.000005     let s:yr_maps_created_zap = 1
                            
    1              0.000003     if a:0 > 0
                                    " We have only removed the _zap_ keys temporarily
                                    " so abandon further changes.
    1              0.000002         return
                                endif
                            
                                " 7.1.patch205 introduces the v:operator function which was essential
                                " to gain the omap support.
                                if s:yr_has_voperator == 1
                                    let s:yr_remove_omap_dot   = 1
                                    " Set option to add and remove _zap_ keys when
                                    " repeating commands
                                    let o_maps = split(g:yankring_o_keys)
                                    " Loop through and prompt the user for all buffer connection parameters.
                                    for key in o_maps
                                        exec 'omap <expr>' key 'YRMapsExpression("<SID>", "'. escape(key,'\"'). '")'
                                    endfor
                                endif
                            
                                " Iterate through a space separated list of mappings and create
                                " calls to the YRYankCount function
                                let n_maps = split(g:yankring_n_keys)
                                " Loop through and prompt the user for all buffer connection parameters.
                                for key in n_maps
                                    " exec 'nnoremap <silent>'.key." :<C-U>YRYankCount '".key."'<CR>"
                                    " exec 'nnoremap <silent>'.key." :<C-U>YRYankCount '".key."'<CR>"
                                    " Andy Wokula's suggestion
                                    exec 'nmap' key key."<SID>yrrecord"
                                endfor
                            
                                if g:yankring_map_dot == 1
                                    if s:yr_has_voperator == 1
                                        nmap <expr> . YRMapsExpression("<SID>", ".")
                                    else
                                        nnoremap <silent> . :<C-U>YRYankCount '.'<CR>
                                    endif
                                endif
                            
                                if g:yankring_v_key != ''
                                    exec 'xnoremap <silent>'.g:yankring_v_key." :YRYankRange 'v'<CR>"
                                endif
                                if g:yankring_del_v_key != ''
                                    for v_map in split(g:yankring_del_v_key)
                                        if strlen(v_map) > 0
                                            try
                                                exec 'xnoremap <silent>'.v_map." :YRDeleteRange 'v'<CR>"
                                            catch
                                            endtry
                                        endif
                                    endfor
                                endif
                                if g:yankring_paste_n_bkey != ''
                                    exec 'nnoremap <silent>'.g:yankring_paste_n_bkey." :<C-U>YRPaste 'P'<CR>"
                                    if g:yankring_paste_using_g == 1
                                        exec 'nnoremap <silent> g'.g:yankring_paste_n_bkey." :<C-U>YRPaste 'gP'<CR>"
                                    endif
                                endif
                                if g:yankring_paste_n_akey != ''
                                    exec 'nnoremap <silent>'.g:yankring_paste_n_akey." :<C-U>YRPaste 'p'<CR>"
                                    if g:yankring_paste_using_g == 1
                                        exec 'nnoremap <silent> g'.g:yankring_paste_n_akey." :<C-U>YRPaste 'gp'<CR>"
                                    endif
                                endif
                                if g:yankring_paste_v_bkey != ''
                                    exec 'xnoremap <silent>'.g:yankring_paste_v_bkey." :<C-U>YRPaste 'P', 'v'<CR>"
                                endif
                                if g:yankring_paste_v_akey != ''
                                    exec 'xnoremap <silent>'.g:yankring_paste_v_akey." :<C-U>YRPaste 'p', 'v'<CR>"
                                endif
                                if g:yankring_replace_n_pkey != ''
                                    exec 'nnoremap <silent>'.g:yankring_replace_n_pkey." :<C-U>YRReplace '-1', 'P'<CR>"
                                endif
                                if g:yankring_replace_n_nkey != ''
                                    exec 'nnoremap <silent>'.g:yankring_replace_n_nkey." :<C-U>YRReplace '1', 'p'<CR>"
                                endif
                            
                                let g:yankring_enabled    = 1
                                let s:yr_maps_created     = 1
                            
                                if exists('*YRRunAfterMaps') 
                                    " This will allow you to override the default maps if necessary
                                    call YRRunAfterMaps()
                                endif

FUNCTION  YRRecord()
    Defined: ~/dev_trees/myvim/bundle/yankring/plugin/yankring.vim:773
Called 1 time
Total time:   0.000772
 Self time:   0.000175

count  total (s)   self (s)
                            
    1              0.000005     let register = '"'
    1              0.000004     if a:0 > 0
                                    " If no yank command has been supplied, assume it is
                                    " a full line yank
    1              0.000007         let register = ((a:1 == '') ? register : a:1)
    1              0.000001     endif
                            
                                " v:register can be blank in some (unknown) cases
                                " if v:register == '' || v:register == '_'
    1              0.000004     if v:register == '_'
                                    " Black hole register, ignore recording the operation
                                    return ""
    1              0.000001     endif
                            
    1              0.000007     let register = ((&clipboard=='unnamed')?'+':register)
                            
                                " let s:yr_prev_changenr    = changenr()
    1              0.000003     if register == '"'
                                    " If the change has occurred via an omap, we must delay
                                    " the capture of the default register until this event
                                    " since register updates are not reflected until the 
                                    " omap function completes
    1              0.000010         let s:yr_prev_reg_unnamed = getreg('"')
    1              0.000007         let s:yr_prev_reg_small   = getreg('-')
    1              0.000002     endif
                            
                                " Add item to list
                                " This will also account for duplicates.
    1   0.000600   0.000035     call s:YRMRUAdd( 's:yr_history_list' , getreg(register) , getregtype(register)  )
                            
    1              0.000023     if register =~ '[+*]'
                                    let s:yr_prev_clipboard = @+
    1              0.000001     endif
                            
                                " If the yankring window is open, refresh it
    1   0.000051   0.000019     call s:YRWindowUpdate()
                            
                                " Manage the numbered registers
    1              0.000004     if g:yankring_manage_numbered_reg == 1
                                    call s:YRSetNumberedReg()
    1              0.000001     endif
                            
    1              0.000002     return ""

FUNCTIONS SORTED ON TOTAL TIME
count  total (s)   self (s)  function
  270   0.060411             <SNR>44_Highlight_Matching_Pair()
    1   0.040686   0.000133  <SNR>23_record()
    1   0.040553             <SNR>23_addtomrufs()
    4   0.001683   0.001418  GetRmdIndent()
    1   0.001273   0.000075  <SNR>39_YRInsertLeave()
    1   0.000772   0.000175  YRRecord()
    1   0.000565   0.000137  <SNR>39_YRMRUAdd()
    3   0.000437             <SNR>31_SelectCompletion()
    1   0.000391             <SNR>39_YRMapsCreate()
    1   0.000300             <SNR>39_YRHistoryRead()
    4   0.000265             <SNR>76_GetMdIndent()
    1   0.000106             <SNR>39_YRMRUElemFormat()
    1   0.000045             pandoc#command#AutoPandoc()
    1   0.000036             <SNR>31_SetDefaultCompletionType()
    1   0.000035             <SNR>39_YRRegister()
    1   0.000032             <SNR>39_YRWindowUpdate()
    1   0.000022             <SNR>39_YRMRUHas()

FUNCTIONS SORTED ON SELF TIME
count  total (s)   self (s)  function
  270              0.060411  <SNR>44_Highlight_Matching_Pair()
    1              0.040553  <SNR>23_addtomrufs()
    4   0.001683   0.001418  GetRmdIndent()
    3              0.000437  <SNR>31_SelectCompletion()
    1              0.000391  <SNR>39_YRMapsCreate()
    1              0.000300  <SNR>39_YRHistoryRead()
    4              0.000265  <SNR>76_GetMdIndent()
    1   0.000772   0.000175  YRRecord()
    1   0.000565   0.000137  <SNR>39_YRMRUAdd()
    1   0.040686   0.000133  <SNR>23_record()
    1              0.000106  <SNR>39_YRMRUElemFormat()
    1   0.001273   0.000075  <SNR>39_YRInsertLeave()
    1              0.000045  pandoc#command#AutoPandoc()
    1              0.000036  <SNR>31_SetDefaultCompletionType()
    1              0.000035  <SNR>39_YRRegister()
    1              0.000032  <SNR>39_YRWindowUpdate()
    1              0.000022  <SNR>39_YRMRUHas()

